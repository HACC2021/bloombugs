"use strict";

exports.__esModule = true;
exports.nonASCIIwhitespace = exports.lineBreakG = exports.lineBreak = exports.isNewLine = exports.Token = exports.isIdentifierStart = exports.isIdentifierChar = exports.tokContexts = exports.TokContext = exports.keywordTypes = exports.tokTypes = exports.TokenType = exports.Node = exports.getLineInfo = exports.SourceLocation = exports.Position = exports.defaultOptions = exports.Parser = exports.version = undefined;
exports.parse = parse;
exports.parseExpressionAt = parseExpressionAt;
exports.tokenizer = tokenizer;

var _state = require("./state.js");

require("./parseutil.js");

require("./statement.js");

require("./lval.js");

require("./expression.js");

require("./location.js");

require("./scope.js");

var _options = require("./options.js");

var _locutil = require("./locutil.js");

var _node = require("./node.js");

var _tokentype = require("./tokentype.js");

var _tokencontext = require("./tokencontext.js");

var _identifier = require("./identifier.js");

var _tokenize = require("./tokenize.js");

var _whitespace = require("./whitespace.js");

var _util = require("./util");

var utils = _interopRequireWildcard(_util);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

// Acorn is a tiny, fast JavaScript parser written in JavaScript.
//
// Acorn was written by Marijn Haverbeke, Ingvar Stepanyan, and
// various contributors and released under an MIT license.
//
// Git repositories for Acorn are available at
//
//     http://marijnhaverbeke.nl/git/acorn
//     https://github.com/acornjs/acorn.git
//
// Please use the [github bug tracker][ghbt] to report issues.
//
// [ghbt]: https://github.com/acornjs/acorn/issues
//
// [walk]: util/walk.js

const version = exports.version = "8.1.0";
exports.Parser = _state.Parser;
exports.defaultOptions = _options.defaultOptions;
exports.Position = _locutil.Position;
exports.SourceLocation = _locutil.SourceLocation;
exports.getLineInfo = _locutil.getLineInfo;
exports.Node = _node.Node;
exports.TokenType = _tokentype.TokenType;
exports.tokTypes = _tokentype.types;
exports.keywordTypes = _tokentype.keywords;
exports.TokContext = _tokencontext.TokContext;
exports.tokContexts = _tokencontext.types;
exports.isIdentifierChar = _identifier.isIdentifierChar;
exports.isIdentifierStart = _identifier.isIdentifierStart;
exports.Token = _tokenize.Token;
exports.isNewLine = _whitespace.isNewLine;
exports.lineBreak = _whitespace.lineBreak;
exports.lineBreakG = _whitespace.lineBreakG;
exports.nonASCIIwhitespace = _whitespace.nonASCIIwhitespace;


_state.Parser.acorn = {
  Parser: _state.Parser,
  version,
  defaultOptions: _options.defaultOptions,
  Position: _locutil.Position,
  SourceLocation: _locutil.SourceLocation,
  getLineInfo: _locutil.getLineInfo,
  Node: _node.Node,
  TokenType: _tokentype.TokenType,
  tokTypes: _tokentype.types,
  keywordTypes: _tokentype.keywords,
  TokContext: _tokencontext.TokContext,
  tokContexts: _tokencontext.types,
  isIdentifierChar: _identifier.isIdentifierChar,
  isIdentifierStart: _identifier.isIdentifierStart,
  Token: _tokenize.Token,
  isNewLine: _whitespace.isNewLine,
  lineBreak: _whitespace.lineBreak,
  lineBreakG: _whitespace.lineBreakG,
  nonASCIIwhitespace: _whitespace.nonASCIIwhitespace

  // The main exported interface (under `self.acorn` when in the
  // browser) is a `parse` function that takes a code string and
  // returns an abstract syntax tree as specified by [Mozilla parser
  // API][api].
  //
  // [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API

};function parse(input, options) {
  return _state.Parser.parse(input, options);
}

// This function tries to parse a single expression at a given
// offset in a string. Useful for parsing mixed-language formats
// that embed JavaScript expressions.

function parseExpressionAt(input, pos, options) {
  return _state.Parser.parseExpressionAt(input, pos, options);
}

// Acorn is organized as a tokenizer and a recursive-descent parser.
// The `tokenizer` export provides an interface to the tokenizer.

function tokenizer(input, options) {
  return _state.Parser.tokenizer(input, options);
}

// =============================================================================
// =============================================================================
// ===================== TestCafe performance patch ============================
// =====================||||||||||||||||||||||||||||============================
// =====================vvvvvvvvvvvvvvvvvvvvvvvvvvvv============================

const storedWordsRegexp = utils.wordsRegexp;
const wordsRegexpCache = {};

utils.wordsRegexp = function (words) {
  if (!wordsRegexpCache[words]) wordsRegexpCache[words] = storedWordsRegexp(words);

  return wordsRegexpCache[words];
};

// =====================^^^^^^^^^^^^^^^^^^^^^^^^^^^^============================
// =====================||||||||||||||||||||||||||||============================
// ===================== TestCafe performance patch ============================
// =============================================================================
// =============================================================================