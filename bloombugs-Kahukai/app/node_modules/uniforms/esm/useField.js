import { __assign } from "tslib";
import get from 'lodash/get';
import mapValues from 'lodash/mapValues';
import { useCallback, useEffect, useMemo } from 'react';
import { joinName } from './joinName';
import { useForm } from './useForm';
function propagate(prop, schema, state, fallback) {
    var forcedFallbackInProp = prop === true || prop === undefined;
    var forcedFallbackInSchema = schema === true || schema === undefined;
    var schemaValue = forcedFallbackInSchema ? fallback : schema;
    var value = prop === '' ||
        prop === false ||
        prop === null ||
        (forcedFallbackInProp && (forcedFallbackInSchema || !state))
        ? ''
        : forcedFallbackInProp
            ? schemaValue
            : prop;
    return [value, schemaValue];
}
export function useField(fieldName, props, options) {
    var _a;
    var context = useForm();
    var name = joinName((options === null || options === void 0 ? void 0 : options.absoluteName) ? '' : context.name, fieldName);
    var state = mapValues(context.state, function (prev, key) {
        var next = props[key];
        return next !== null && next !== undefined ? !!next : prev;
    });
    var changed = !!get(context.changedMap, name);
    var error = context.schema.getError(name, context.error);
    var errorMessage = context.schema.getErrorMessage(name, context.error);
    var field = context.schema.getField(name);
    var fieldType = context.schema.getType(name);
    var fields = context.schema.getSubfields(name);
    var schemaProps = context.schema.getProps(name, __assign(__assign({}, state), props));
    var _b = propagate(props.label, schemaProps.label, state.label, ''), label = _b[0], labelFallback = _b[1];
    var placeholder = propagate(props.placeholder, schemaProps.placeholder, state.placeholder, label || labelFallback)[0];
    // eslint-disable-next-line react-hooks/exhaustive-deps
    var id = useMemo(function () { return context.randomId(); }, []);
    var onChange = useCallback(function (value, key) {
        if (key === void 0) { key = name; }
        context.onChange(key, value);
    }, 
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [context.onChange, name]);
    var valueFromModel = get(context.model, name);
    var initialValue;
    var value = (_a = props.value) !== null && _a !== void 0 ? _a : valueFromModel;
    if (value === undefined) {
        value = context.schema.getInitialValue(name, props);
        initialValue = value;
    }
    else if (props.value !== undefined && props.value !== valueFromModel) {
        initialValue = props.value;
    }
    if ((options === null || options === void 0 ? void 0 : options.initialValue) !== false) {
        // eslint-disable-next-line react-hooks/rules-of-hooks
        useEffect(function () {
            var _a;
            var required = (_a = props.required) !== null && _a !== void 0 ? _a : schemaProps.required;
            if (required && initialValue !== undefined) {
                onChange(initialValue);
            }
            // eslint-disable-next-line react-hooks/exhaustive-deps
        }, []);
    }
    var fieldProps = __assign(__assign(__assign(__assign(__assign({ id: id }, state), { changed: changed,
        error: error,
        errorMessage: errorMessage,
        field: field,
        fieldType: fieldType,
        fields: fields,
        onChange: onChange,
        value: value }), schemaProps), props), { label: label,
        name: name, 
        // TODO: Should we assert `typeof placeholder === 'string'`?
        placeholder: placeholder });
    return [fieldProps, context];
}
