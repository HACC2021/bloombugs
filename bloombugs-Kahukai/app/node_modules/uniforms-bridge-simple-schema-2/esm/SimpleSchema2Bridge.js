import { __assign, __extends } from "tslib";
import invariant from 'invariant';
import cloneDeep from 'lodash/cloneDeep';
import memoize from 'lodash/memoize';
import SimpleSchema from 'simpl-schema';
import { Bridge, joinName } from 'uniforms';
var propsToRemove = ['optional', 'type', 'uniforms'];
var SimpleSchema2Bridge = /** @class */ (function (_super) {
    __extends(SimpleSchema2Bridge, _super);
    function SimpleSchema2Bridge(schema) {
        var _this = _super.call(this) || this;
        _this.schema = schema;
        // Memoize for performance and referential equality.
        _this.getField = memoize(_this.getField.bind(_this));
        _this.getSubfields = memoize(_this.getSubfields.bind(_this));
        _this.getType = memoize(_this.getType.bind(_this));
        return _this;
    }
    SimpleSchema2Bridge.prototype.getError = function (name, error) {
        var details = error === null || error === void 0 ? void 0 : error.details;
        if (!Array.isArray(details)) {
            return null;
        }
        return details.find(function (error) { return error.name === name; }) || null;
    };
    SimpleSchema2Bridge.prototype.getErrorMessage = function (name, error) {
        var scopedError = this.getError(name, error);
        // @ts-expect-error: `messageForError` has incorrect typing.
        return !scopedError ? '' : this.schema.messageForError(scopedError);
    };
    SimpleSchema2Bridge.prototype.getErrorMessages = function (error) {
        var _this = this;
        if (!error) {
            return [];
        }
        var details = error.details;
        return Array.isArray(details)
            ? // @ts-expect-error: `messageForError` has incorrect typing.
                details.map(function (error) { return _this.schema.messageForError(error); })
            : [error.message || error];
    };
    SimpleSchema2Bridge.prototype.getField = function (name) {
        var definition = this.schema.getDefinition(name);
        invariant(definition, 'Field not found in schema: "%s"', name);
        var merged = __assign(__assign({}, definition), definition.type[0]);
        // aldeed/node-simple-schema#27
        if (merged.autoValue &&
            (merged.autoValue.name === 'defaultAutoValueFunction' ||
                merged.autoValue.toString().indexOf('$setOnInsert:') !== -1) // FIXME: Hack.
        ) {
            try {
                merged.defaultValue = merged.autoValue.call({ operator: null });
            }
            catch (_) {
                // It's fine.
            }
        }
        return merged;
    };
    SimpleSchema2Bridge.prototype.getInitialValue = function (name, props) {
        var field = this.getField(name);
        var defaultValue = field.defaultValue;
        if (defaultValue !== undefined) {
            return cloneDeep(defaultValue);
        }
        if (field.type === Array) {
            var item_1 = this.getInitialValue(joinName(name, '0'));
            var items = Math.max((props === null || props === void 0 ? void 0 : props.initialCount) || 0, field.minCount || 0);
            return Array.from({ length: items }, function () { return item_1; });
        }
        if (field.type === Object || field.type instanceof SimpleSchema) {
            return {};
        }
        return undefined;
    };
    // eslint-disable-next-line complexity
    SimpleSchema2Bridge.prototype.getProps = function (name, fieldProps) {
        var props = Object.assign({}, this.getField(name));
        props.required = !props.optional;
        if (typeof props.uniforms === 'function' ||
            typeof props.uniforms === 'string') {
            props.component = props.uniforms;
        }
        else {
            Object.assign(props, props.uniforms);
        }
        if (props.type === Number) {
            props.decimal = true;
        }
        var options = (fieldProps === null || fieldProps === void 0 ? void 0 : fieldProps.options) || props.options;
        if (options) {
            if (typeof options === 'function') {
                options = options();
            }
            if (Array.isArray(options)) {
                props.allowedValues = options.map(function (option) { return option.value; });
                props.transform = function (value) {
                    return options.find(function (option) { return option.value === value; }).label;
                };
            }
            else {
                props.allowedValues = Object.keys(options);
                props.transform = function (value) { return options[value]; };
            }
        }
        else if (props.type === Array) {
            try {
                var itemProps = this.getProps(name + ".$", fieldProps);
                if (itemProps.allowedValues && !(fieldProps === null || fieldProps === void 0 ? void 0 : fieldProps.allowedValues)) {
                    props.allowedValues = itemProps.allowedValues;
                }
                if (itemProps.transform && !(fieldProps === null || fieldProps === void 0 ? void 0 : fieldProps.transform)) {
                    props.transform = itemProps.transform;
                }
            }
            catch (_) {
                // It's fine.
            }
        }
        propsToRemove.forEach(function (key) {
            if (key in props) {
                delete props[key];
            }
        });
        return props;
    };
    SimpleSchema2Bridge.prototype.getSubfields = function (name) {
        // @ts-expect-error: Typing for `_makeGeneric` is missing.
        return this.schema.objectKeys(SimpleSchema._makeGeneric(name));
    };
    SimpleSchema2Bridge.prototype.getType = function (name) {
        var type = this.getField(name).type;
        if (type === SimpleSchema.Integer) {
            return Number;
        }
        if (type instanceof SimpleSchema) {
            return Object;
        }
        return type;
    };
    // TODO: `ValidationOption` is not exported.
    SimpleSchema2Bridge.prototype.getValidator = function (options) {
        if (options === void 0) { options = { clean: true, mutate: true }; }
        var validator = this.schema.validator(options);
        return function (model) {
            try {
                // Clean mutate its argument, even if mutate is false.
                validator(options.clean ? cloneDeep(__assign({}, model)) : model);
                return null;
            }
            catch (error) {
                return error;
            }
        };
    };
    return SimpleSchema2Bridge;
}(Bridge));
export default SimpleSchema2Bridge;
