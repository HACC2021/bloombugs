window['%hammerhead%'].utils.removeInjectedScript();

// NOTE: We should have the capability to initialize scripts with different contexts.
// This is required for iframes without the src attribute because Hammerhead does not
// inject scripts into such iframes. So, we wrap all scripts in initialization functions.
(function () {
    function initTestCafeClientDrivers(window, isIFrameWithoutSrc) {
        var document = window.document;

        (function (hammerhead, Promise$8, testCafeCore, testcafeAutomation, testCafeUI) {
    var hammerhead__default = 'default' in hammerhead ? hammerhead['default'] : hammerhead;
    Promise$8 = Promise$8 && Object.prototype.hasOwnProperty.call(Promise$8, 'default') ? Promise$8['default'] : Promise$8;
    var testCafeCore__default = 'default' in testCafeCore ? testCafeCore['default'] : testCafeCore;
    var testCafeUI__default = 'default' in testCafeUI ? testCafeUI['default'] : testCafeUI;

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise$8))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }

    // -------------------------------------------------------------
    // WARNING: this file is used by both the client and the server.
    // Do not use any browser or node-specific API!
    // -------------------------------------------------------------
    var HEARTBEAT_TIMEOUT = 2 * 60 * 1000;
    var CHECK_IFRAME_DRIVER_LINK_DELAY = 500;
    var CHECK_CHILD_WINDOW_DRIVER_LINK_DELAY = 500;
    var SEND_STATUS_REQUEST_TIME_LIMIT = 5000;
    var SEND_STATUS_REQUEST_RETRY_DELAY = 300;
    var SEND_STATUS_REQUEST_RETRY_COUNT = Math.floor(HEARTBEAT_TIMEOUT / SEND_STATUS_REQUEST_RETRY_DELAY - 1);
    var CHECK_STATUS_RETRY_DELAY = 1000;

    var ClientMessages;
    (function (ClientMessages) {
        ClientMessages["ready"] = "ready";
        ClientMessages["readyForBrowserManipulation"] = "ready-for-browser-manipulation";
        ClientMessages["waitForFileDownload"] = "wait-for-file-download";
    })(ClientMessages || (ClientMessages = {}));
    var TEST_RUN_MESSAGES = ClientMessages;

    // -------------------------------------------------------------
    // WARNING: this file is used by both the client and the server.
    // Do not use any browser or node-specific API!
    // -------------------------------------------------------------
    var COMMAND_TYPE = {
        dispatchEvent: 'dispatch-event',
        click: 'click',
        rightClick: 'right-click',
        doubleClick: 'double-click',
        drag: 'drag',
        dragToElement: 'drag-to-element',
        hover: 'hover',
        scroll: 'scroll',
        scrollBy: 'scroll-by',
        scrollIntoView: 'scroll-into-view',
        typeText: 'type-text',
        selectText: 'select-text',
        selectTextAreaContent: 'select-text-area-content',
        selectEditableContent: 'select-editable-content',
        pressKey: 'press-key',
        wait: 'wait',
        navigateTo: 'navigate-to',
        setFilesToUpload: 'set-files-to-upload',
        clearUpload: 'clear-upload',
        executeClientFunction: 'execute-client-function',
        executeSelector: 'execute-selector',
        takeScreenshot: 'take-screenshot',
        takeElementScreenshot: 'take-element-screenshot',
        takeScreenshotOnFail: 'take-screenshot-on-fail',
        prepareBrowserManipulation: 'prepare-browser-manipulation',
        showAssertionRetriesStatus: 'show-assertion-retries-status',
        hideAssertionRetriesStatus: 'hide-assertion-retries-status',
        setBreakpoint: 'set-breakpoint',
        resizeWindow: 'resize-window',
        resizeWindowToFitDevice: 'resize-window-to-fit-device',
        maximizeWindow: 'maximize-window',
        switchToIframe: 'switch-to-iframe',
        switchToMainWindow: 'switch-to-main-window',
        openWindow: 'open-window',
        closeWindow: 'close-window',
        getCurrentWindow: 'get-current-window',
        getCurrentWindows: 'get-current-windows',
        switchToWindow: 'switch-to-window',
        switchToWindowByPredicate: 'switch-to-window-by-predicate',
        switchToParentWindow: 'switch-to-parent-window',
        switchToPreviousWindow: 'switch-to-previous-window',
        setNativeDialogHandler: 'set-native-dialog-handler',
        getNativeDialogHistory: 'get-native-dialog-history',
        getBrowserConsoleMessages: 'get-browser-console-messages',
        getActiveElement: 'get-active-element',
        setTestSpeed: 'set-test-speed',
        setPageLoadTimeout: 'set-page-load-timeout',
        debug: 'debug',
        disableDebug: 'disable-debug',
        assertion: 'assertion',
        useRole: 'useRole',
        testDone: 'test-done',
        backupStorages: 'backup-storages',
        executeExpression: 'execute-expression',
        executeAsyncExpression: 'execute-async-expression',
        unlockPage: 'unlock-page',
        recorder: 'recorder',
    };

    // -------------------------------------------------------------
    // WARNING: this file is used by both the client and the server.
    // Do not use any browser or node-specific API!
    // -------------------------------------------------------------
    var TEST_RUN_ERRORS = {
        uncaughtErrorOnPage: 'E1',
        uncaughtErrorInTestCode: 'E2',
        uncaughtNonErrorObjectInTestCode: 'E3',
        uncaughtErrorInClientFunctionCode: 'E4',
        uncaughtErrorInCustomDOMPropertyCode: 'E5',
        unhandledPromiseRejection: 'E6',
        uncaughtException: 'E7',
        missingAwaitError: 'E8',
        actionIntegerOptionError: 'E9',
        actionPositiveIntegerOptionError: 'E10',
        actionBooleanOptionError: 'E11',
        actionSpeedOptionError: 'E12',
        actionOptionsTypeError: 'E14',
        actionBooleanArgumentError: 'E15',
        actionStringArgumentError: 'E16',
        actionNullableStringArgumentError: 'E17',
        actionStringOrStringArrayArgumentError: 'E18',
        actionStringArrayElementError: 'E19',
        actionIntegerArgumentError: 'E20',
        actionRoleArgumentError: 'E21',
        actionPositiveIntegerArgumentError: 'E22',
        actionSelectorError: 'E23',
        actionElementNotFoundError: 'E24',
        actionElementIsInvisibleError: 'E26',
        actionSelectorMatchesWrongNodeTypeError: 'E27',
        actionAdditionalElementNotFoundError: 'E28',
        actionAdditionalElementIsInvisibleError: 'E29',
        actionAdditionalSelectorMatchesWrongNodeTypeError: 'E30',
        actionElementNonEditableError: 'E31',
        actionElementNotTextAreaError: 'E32',
        actionElementNonContentEditableError: 'E33',
        actionElementIsNotFileInputError: 'E34',
        actionRootContainerNotFoundError: 'E35',
        actionIncorrectKeysError: 'E36',
        actionCannotFindFileToUploadError: 'E37',
        actionUnsupportedDeviceTypeError: 'E38',
        actionIframeIsNotLoadedError: 'E39',
        actionElementNotIframeError: 'E40',
        actionInvalidScrollTargetError: 'E41',
        currentIframeIsNotLoadedError: 'E42',
        currentIframeNotFoundError: 'E43',
        currentIframeIsInvisibleError: 'E44',
        nativeDialogNotHandledError: 'E45',
        uncaughtErrorInNativeDialogHandler: 'E46',
        setTestSpeedArgumentError: 'E47',
        setNativeDialogHandlerCodeWrongTypeError: 'E48',
        clientFunctionExecutionInterruptionError: 'E49',
        domNodeClientFunctionResultError: 'E50',
        invalidSelectorResultError: 'E51',
        cannotObtainInfoForElementSpecifiedBySelectorError: 'E52',
        externalAssertionLibraryError: 'E53',
        pageLoadError: 'E54',
        windowDimensionsOverflowError: 'E55',
        forbiddenCharactersInScreenshotPathError: 'E56',
        invalidElementScreenshotDimensionsError: 'E57',
        roleSwitchInRoleInitializerError: 'E58',
        assertionExecutableArgumentError: 'E59',
        assertionWithoutMethodCallError: 'E60',
        assertionUnawaitedPromiseError: 'E61',
        requestHookNotImplementedError: 'E62',
        requestHookUnhandledError: 'E63',
        uncaughtErrorInCustomClientScriptCode: 'E64',
        uncaughtErrorInCustomClientScriptCodeLoadedFromModule: 'E65',
        uncaughtErrorInCustomScript: 'E66',
        uncaughtTestCafeErrorInCustomScript: 'E67',
        childWindowIsNotLoadedError: 'E68',
        childWindowNotFoundError: 'E69',
        cannotSwitchToWindowError: 'E70',
        closeChildWindowError: 'E71',
        childWindowClosedBeforeSwitchingError: 'E72',
        cannotCloseWindowWithChildrenError: 'E73',
        targetWindowNotFoundError: 'E74',
        parentWindowNotFoundError: 'E76',
        previousWindowNotFoundError: 'E77',
        switchToWindowPredicateError: 'E78',
        actionFunctionArgumentError: 'E79',
        multipleWindowsModeIsDisabledError: 'E80',
        multipleWindowsModeIsNotSupportedInRemoteBrowserError: 'E81',
        cannotCloseWindowWithoutParent: 'E82',
        cannotRestoreChildWindowError: 'E83',
    };

    // -------------------------------------------------------------
    function isCommandRejectableByPageError(command) {
        return !isObservationCommand(command) && !isBrowserManipulationCommand(command) && !isServiceCommand(command) ||
            isResizeWindowCommand(command)
                && !isWindowSwitchingCommand(command);
    }
    function isClientFunctionCommand(command) {
        return command.type === COMMAND_TYPE.executeClientFunction ||
            command.type === COMMAND_TYPE.executeSelector;
    }
    function isObservationCommand(command) {
        return isClientFunctionCommand(command) ||
            command.type === COMMAND_TYPE.wait ||
            command.type === COMMAND_TYPE.assertion ||
            command.type === COMMAND_TYPE.executeExpression;
    }
    function isWindowSwitchingCommand(command) {
        return command.type === COMMAND_TYPE.switchToIframe || command.type === COMMAND_TYPE.switchToMainWindow;
    }
    function isScreenshotCommand(command) {
        return command.type === COMMAND_TYPE.takeScreenshot ||
            command.type === COMMAND_TYPE.takeElementScreenshot ||
            command.type === COMMAND_TYPE.takeScreenshotOnFail;
    }
    function isResizeWindowCommand(command) {
        return command.type === COMMAND_TYPE.resizeWindow ||
            command.type === COMMAND_TYPE.resizeWindowToFitDevice ||
            command.type === COMMAND_TYPE.maximizeWindow;
    }
    function isBrowserManipulationCommand(command) {
        return isScreenshotCommand(command) || isResizeWindowCommand(command);
    }
    function isServiceCommand(command) {
        return command.type === COMMAND_TYPE.testDone ||
            command.type === COMMAND_TYPE.showAssertionRetriesStatus ||
            command.type === COMMAND_TYPE.hideAssertionRetriesStatus ||
            command.type === COMMAND_TYPE.setBreakpoint ||
            command.type === COMMAND_TYPE.takeScreenshotOnFail ||
            command.type === COMMAND_TYPE.recorder;
    }
    function isExecutableInTopWindowOnly(command) {
        return command.type === COMMAND_TYPE.testDone ||
            command.type === COMMAND_TYPE.switchToMainWindow ||
            command.type === COMMAND_TYPE.setNativeDialogHandler ||
            command.type === COMMAND_TYPE.getNativeDialogHistory ||
            command.type === COMMAND_TYPE.setTestSpeed ||
            command.type === COMMAND_TYPE.showAssertionRetriesStatus ||
            command.type === COMMAND_TYPE.hideAssertionRetriesStatus ||
            command.type === COMMAND_TYPE.setBreakpoint ||
            isBrowserManipulationCommand(command) && command.type !== COMMAND_TYPE.takeElementScreenshot;
    }

    var STATUS_BAR_DEBUG_ACTION = {
        step: 'step',
        resume: 'resume',
    };

    // Base
    //--------------------------------------------------------------------
    var TestRunErrorBase = /** @class */ (function () {
        function TestRunErrorBase(code, callsite) {
            this.code = code;
            this.isTestCafeError = true;
            this.callsite = callsite || null;
        }
        return TestRunErrorBase;
    }());
    var ActionOptionErrorBase = /** @class */ (function (_super) {
        __extends(ActionOptionErrorBase, _super);
        function ActionOptionErrorBase(code, optionName, actualValue) {
            var _this = _super.call(this, code) || this;
            _this.optionName = optionName;
            _this.actualValue = actualValue;
            return _this;
        }
        return ActionOptionErrorBase;
    }(TestRunErrorBase));
    // Client function errors
    //--------------------------------------------------------------------
    var ClientFunctionExecutionInterruptionError = /** @class */ (function (_super) {
        __extends(ClientFunctionExecutionInterruptionError, _super);
        function ClientFunctionExecutionInterruptionError(instantiationCallsiteName, callsite) {
            var _this = _super.call(this, TEST_RUN_ERRORS.clientFunctionExecutionInterruptionError, callsite) || this;
            _this.instantiationCallsiteName = instantiationCallsiteName;
            return _this;
        }
        return ClientFunctionExecutionInterruptionError;
    }(TestRunErrorBase));
    var DomNodeClientFunctionResultError = /** @class */ (function (_super) {
        __extends(DomNodeClientFunctionResultError, _super);
        function DomNodeClientFunctionResultError(instantiationCallsiteName, callsite) {
            var _this = _super.call(this, TEST_RUN_ERRORS.domNodeClientFunctionResultError, callsite) || this;
            _this.instantiationCallsiteName = instantiationCallsiteName;
            return _this;
        }
        return DomNodeClientFunctionResultError;
    }(TestRunErrorBase));
    // Selector errors
    //--------------------------------------------------------------------
    var SelectorErrorBase = /** @class */ (function (_super) {
        __extends(SelectorErrorBase, _super);
        function SelectorErrorBase(code, _a) {
            var apiFnChain = _a.apiFnChain, apiFnIndex = _a.apiFnIndex;
            var _this = _super.call(this, code) || this;
            _this.apiFnChain = apiFnChain;
            _this.apiFnIndex = apiFnIndex;
            return _this;
        }
        return SelectorErrorBase;
    }(TestRunErrorBase));
    var InvalidSelectorResultError = /** @class */ (function (_super) {
        __extends(InvalidSelectorResultError, _super);
        function InvalidSelectorResultError(callsite) {
            return _super.call(this, TEST_RUN_ERRORS.invalidSelectorResultError, callsite) || this;
        }
        return InvalidSelectorResultError;
    }(TestRunErrorBase));
    var CannotObtainInfoForElementSpecifiedBySelectorError = /** @class */ (function (_super) {
        __extends(CannotObtainInfoForElementSpecifiedBySelectorError, _super);
        function CannotObtainInfoForElementSpecifiedBySelectorError(callsite, apiFnArgs) {
            var _this = _super.call(this, TEST_RUN_ERRORS.cannotObtainInfoForElementSpecifiedBySelectorError, apiFnArgs) || this;
            _this.callsite = callsite;
            return _this;
        }
        return CannotObtainInfoForElementSpecifiedBySelectorError;
    }(SelectorErrorBase));
    // Uncaught errors
    //--------------------------------------------------------------------
    var UncaughtErrorOnPage = /** @class */ (function (_super) {
        __extends(UncaughtErrorOnPage, _super);
        function UncaughtErrorOnPage(errStack, pageDestUrl) {
            var _this = _super.call(this, TEST_RUN_ERRORS.uncaughtErrorOnPage) || this;
            _this.errStack = errStack;
            _this.pageDestUrl = pageDestUrl;
            return _this;
        }
        return UncaughtErrorOnPage;
    }(TestRunErrorBase));
    var UncaughtErrorInClientFunctionCode = /** @class */ (function (_super) {
        __extends(UncaughtErrorInClientFunctionCode, _super);
        function UncaughtErrorInClientFunctionCode(instantiationCallsiteName, err, callsite) {
            var _this = _super.call(this, TEST_RUN_ERRORS.uncaughtErrorInClientFunctionCode, callsite) || this;
            _this.errMsg = String(err);
            _this.instantiationCallsiteName = instantiationCallsiteName;
            return _this;
        }
        return UncaughtErrorInClientFunctionCode;
    }(TestRunErrorBase));
    var UncaughtErrorInCustomDOMPropertyCode = /** @class */ (function (_super) {
        __extends(UncaughtErrorInCustomDOMPropertyCode, _super);
        function UncaughtErrorInCustomDOMPropertyCode(instantiationCallsiteName, err, prop, callsite) {
            var _this = _super.call(this, TEST_RUN_ERRORS.uncaughtErrorInCustomDOMPropertyCode, callsite) || this;
            _this.errMsg = String(err);
            _this.property = prop;
            _this.instantiationCallsiteName = instantiationCallsiteName;
            return _this;
        }
        return UncaughtErrorInCustomDOMPropertyCode;
    }(TestRunErrorBase));
    var UncaughtErrorInCustomClientScriptCode = /** @class */ (function (_super) {
        __extends(UncaughtErrorInCustomClientScriptCode, _super);
        function UncaughtErrorInCustomClientScriptCode(err) {
            var _this = _super.call(this, TEST_RUN_ERRORS.uncaughtErrorInCustomClientScriptCode) || this;
            _this.errMsg = String(err);
            return _this;
        }
        return UncaughtErrorInCustomClientScriptCode;
    }(TestRunErrorBase));
    var UncaughtErrorInCustomClientScriptLoadedFromModule = /** @class */ (function (_super) {
        __extends(UncaughtErrorInCustomClientScriptLoadedFromModule, _super);
        function UncaughtErrorInCustomClientScriptLoadedFromModule(err, moduleName) {
            var _this = _super.call(this, TEST_RUN_ERRORS.uncaughtErrorInCustomClientScriptCodeLoadedFromModule) || this;
            _this.errMsg = String(err);
            _this.moduleName = moduleName;
            return _this;
        }
        return UncaughtErrorInCustomClientScriptLoadedFromModule;
    }(TestRunErrorBase));
    // Action parameters errors
    //--------------------------------------------------------------------
    // Options errors
    //--------------------------------------------------------------------
    var ActionIntegerOptionError = /** @class */ (function (_super) {
        __extends(ActionIntegerOptionError, _super);
        function ActionIntegerOptionError(optionName, actualValue) {
            return _super.call(this, TEST_RUN_ERRORS.actionIntegerOptionError, optionName, actualValue) || this;
        }
        return ActionIntegerOptionError;
    }(ActionOptionErrorBase));
    var ActionPositiveIntegerOptionError = /** @class */ (function (_super) {
        __extends(ActionPositiveIntegerOptionError, _super);
        function ActionPositiveIntegerOptionError(optionName, actualValue) {
            return _super.call(this, TEST_RUN_ERRORS.actionPositiveIntegerOptionError, optionName, actualValue) || this;
        }
        return ActionPositiveIntegerOptionError;
    }(ActionOptionErrorBase));
    var ActionBooleanOptionError = /** @class */ (function (_super) {
        __extends(ActionBooleanOptionError, _super);
        function ActionBooleanOptionError(optionName, actualValue) {
            return _super.call(this, TEST_RUN_ERRORS.actionBooleanOptionError, optionName, actualValue) || this;
        }
        return ActionBooleanOptionError;
    }(ActionOptionErrorBase));
    var ActionSpeedOptionError = /** @class */ (function (_super) {
        __extends(ActionSpeedOptionError, _super);
        function ActionSpeedOptionError(optionName, actualValue) {
            return _super.call(this, TEST_RUN_ERRORS.actionSpeedOptionError, optionName, actualValue) || this;
        }
        return ActionSpeedOptionError;
    }(ActionOptionErrorBase));
    // Action execution errors
    //--------------------------------------------------------------------
    var ActionElementNotFoundError = /** @class */ (function (_super) {
        __extends(ActionElementNotFoundError, _super);
        function ActionElementNotFoundError(apiFnArgs) {
            return _super.call(this, TEST_RUN_ERRORS.actionElementNotFoundError, apiFnArgs) || this;
        }
        return ActionElementNotFoundError;
    }(SelectorErrorBase));
    var ActionElementIsInvisibleError = /** @class */ (function (_super) {
        __extends(ActionElementIsInvisibleError, _super);
        function ActionElementIsInvisibleError() {
            return _super.call(this, TEST_RUN_ERRORS.actionElementIsInvisibleError) || this;
        }
        return ActionElementIsInvisibleError;
    }(TestRunErrorBase));
    var ActionSelectorMatchesWrongNodeTypeError = /** @class */ (function (_super) {
        __extends(ActionSelectorMatchesWrongNodeTypeError, _super);
        function ActionSelectorMatchesWrongNodeTypeError(nodeDescription) {
            var _this = _super.call(this, TEST_RUN_ERRORS.actionSelectorMatchesWrongNodeTypeError) || this;
            _this.nodeDescription = nodeDescription;
            return _this;
        }
        return ActionSelectorMatchesWrongNodeTypeError;
    }(TestRunErrorBase));
    var ActionAdditionalElementNotFoundError = /** @class */ (function (_super) {
        __extends(ActionAdditionalElementNotFoundError, _super);
        function ActionAdditionalElementNotFoundError(argumentName, apiFnArgs) {
            var _this = _super.call(this, TEST_RUN_ERRORS.actionAdditionalElementNotFoundError, apiFnArgs) || this;
            _this.argumentName = argumentName;
            return _this;
        }
        return ActionAdditionalElementNotFoundError;
    }(SelectorErrorBase));
    var ActionAdditionalElementIsInvisibleError = /** @class */ (function (_super) {
        __extends(ActionAdditionalElementIsInvisibleError, _super);
        function ActionAdditionalElementIsInvisibleError(argumentName) {
            var _this = _super.call(this, TEST_RUN_ERRORS.actionAdditionalElementIsInvisibleError) || this;
            _this.argumentName = argumentName;
            return _this;
        }
        return ActionAdditionalElementIsInvisibleError;
    }(TestRunErrorBase));
    var ActionAdditionalSelectorMatchesWrongNodeTypeError = /** @class */ (function (_super) {
        __extends(ActionAdditionalSelectorMatchesWrongNodeTypeError, _super);
        function ActionAdditionalSelectorMatchesWrongNodeTypeError(argumentName, nodeDescription) {
            var _this = _super.call(this, TEST_RUN_ERRORS.actionAdditionalSelectorMatchesWrongNodeTypeError) || this;
            _this.argumentName = argumentName;
            _this.nodeDescription = nodeDescription;
            return _this;
        }
        return ActionAdditionalSelectorMatchesWrongNodeTypeError;
    }(TestRunErrorBase));
    var ActionElementNonEditableError = /** @class */ (function (_super) {
        __extends(ActionElementNonEditableError, _super);
        function ActionElementNonEditableError() {
            return _super.call(this, TEST_RUN_ERRORS.actionElementNonEditableError) || this;
        }
        return ActionElementNonEditableError;
    }(TestRunErrorBase));
    var ActionElementNotTextAreaError = /** @class */ (function (_super) {
        __extends(ActionElementNotTextAreaError, _super);
        function ActionElementNotTextAreaError() {
            return _super.call(this, TEST_RUN_ERRORS.actionElementNotTextAreaError) || this;
        }
        return ActionElementNotTextAreaError;
    }(TestRunErrorBase));
    var ActionElementNonContentEditableError = /** @class */ (function (_super) {
        __extends(ActionElementNonContentEditableError, _super);
        function ActionElementNonContentEditableError(argumentName) {
            var _this = _super.call(this, TEST_RUN_ERRORS.actionElementNonContentEditableError) || this;
            _this.argumentName = argumentName;
            return _this;
        }
        return ActionElementNonContentEditableError;
    }(TestRunErrorBase));
    var ActionRootContainerNotFoundError = /** @class */ (function (_super) {
        __extends(ActionRootContainerNotFoundError, _super);
        function ActionRootContainerNotFoundError() {
            return _super.call(this, TEST_RUN_ERRORS.actionRootContainerNotFoundError) || this;
        }
        return ActionRootContainerNotFoundError;
    }(TestRunErrorBase));
    var ActionIncorrectKeysError = /** @class */ (function (_super) {
        __extends(ActionIncorrectKeysError, _super);
        function ActionIncorrectKeysError(argumentName) {
            var _this = _super.call(this, TEST_RUN_ERRORS.actionIncorrectKeysError) || this;
            _this.argumentName = argumentName;
            return _this;
        }
        return ActionIncorrectKeysError;
    }(TestRunErrorBase));
    var ActionCannotFindFileToUploadError = /** @class */ (function (_super) {
        __extends(ActionCannotFindFileToUploadError, _super);
        function ActionCannotFindFileToUploadError(filePaths, scannedFilePaths) {
            var _this = _super.call(this, TEST_RUN_ERRORS.actionCannotFindFileToUploadError) || this;
            _this.filePaths = filePaths;
            _this.scannedFilePaths = scannedFilePaths;
            return _this;
        }
        return ActionCannotFindFileToUploadError;
    }(TestRunErrorBase));
    var ActionElementIsNotFileInputError = /** @class */ (function (_super) {
        __extends(ActionElementIsNotFileInputError, _super);
        function ActionElementIsNotFileInputError() {
            return _super.call(this, TEST_RUN_ERRORS.actionElementIsNotFileInputError) || this;
        }
        return ActionElementIsNotFileInputError;
    }(TestRunErrorBase));
    var ActionInvalidScrollTargetError = /** @class */ (function (_super) {
        __extends(ActionInvalidScrollTargetError, _super);
        function ActionInvalidScrollTargetError(scrollTargetXValid, scrollTargetYValid) {
            var _this = _super.call(this, TEST_RUN_ERRORS.actionInvalidScrollTargetError) || this;
            if (!scrollTargetXValid) {
                if (!scrollTargetYValid)
                    _this.properties = 'scrollTargetX and scrollTargetY properties';
                else
                    _this.properties = 'scrollTargetX property';
            }
            else
                _this.properties = 'scrollTargetY property';
            return _this;
        }
        return ActionInvalidScrollTargetError;
    }(TestRunErrorBase));
    var InvalidElementScreenshotDimensionsError = /** @class */ (function (_super) {
        __extends(InvalidElementScreenshotDimensionsError, _super);
        function InvalidElementScreenshotDimensionsError(width, height) {
            var _this = _super.call(this, TEST_RUN_ERRORS.invalidElementScreenshotDimensionsError) || this;
            var widthIsInvalid = width <= 0;
            var heightIsInvalid = height <= 0;
            if (widthIsInvalid) {
                if (heightIsInvalid) {
                    _this.verb = 'are';
                    _this.dimensions = 'width and height';
                }
                else {
                    _this.verb = 'is';
                    _this.dimensions = 'width';
                }
            }
            else {
                _this.verb = 'is';
                _this.dimensions = 'height';
            }
            return _this;
        }
        return InvalidElementScreenshotDimensionsError;
    }(TestRunErrorBase));
    // Iframe errors
    //--------------------------------------------------------------------
    var ActionElementNotIframeError = /** @class */ (function (_super) {
        __extends(ActionElementNotIframeError, _super);
        function ActionElementNotIframeError() {
            return _super.call(this, TEST_RUN_ERRORS.actionElementNotIframeError) || this;
        }
        return ActionElementNotIframeError;
    }(TestRunErrorBase));
    var ActionIframeIsNotLoadedError = /** @class */ (function (_super) {
        __extends(ActionIframeIsNotLoadedError, _super);
        function ActionIframeIsNotLoadedError() {
            return _super.call(this, TEST_RUN_ERRORS.actionIframeIsNotLoadedError) || this;
        }
        return ActionIframeIsNotLoadedError;
    }(TestRunErrorBase));
    var CurrentIframeIsNotLoadedError = /** @class */ (function (_super) {
        __extends(CurrentIframeIsNotLoadedError, _super);
        function CurrentIframeIsNotLoadedError() {
            return _super.call(this, TEST_RUN_ERRORS.currentIframeIsNotLoadedError) || this;
        }
        return CurrentIframeIsNotLoadedError;
    }(TestRunErrorBase));
    var ChildWindowNotFoundError = /** @class */ (function (_super) {
        __extends(ChildWindowNotFoundError, _super);
        function ChildWindowNotFoundError() {
            return _super.call(this, TEST_RUN_ERRORS.childWindowNotFoundError) || this;
        }
        return ChildWindowNotFoundError;
    }(TestRunErrorBase));
    var ChildWindowIsNotLoadedError = /** @class */ (function (_super) {
        __extends(ChildWindowIsNotLoadedError, _super);
        function ChildWindowIsNotLoadedError() {
            return _super.call(this, TEST_RUN_ERRORS.childWindowIsNotLoadedError) || this;
        }
        return ChildWindowIsNotLoadedError;
    }(TestRunErrorBase));
    var CannotSwitchToWindowError = /** @class */ (function (_super) {
        __extends(CannotSwitchToWindowError, _super);
        function CannotSwitchToWindowError() {
            return _super.call(this, TEST_RUN_ERRORS.cannotSwitchToWindowError) || this;
        }
        return CannotSwitchToWindowError;
    }(TestRunErrorBase));
    var CloseChildWindowError = /** @class */ (function (_super) {
        __extends(CloseChildWindowError, _super);
        function CloseChildWindowError() {
            return _super.call(this, TEST_RUN_ERRORS.closeChildWindowError) || this;
        }
        return CloseChildWindowError;
    }(TestRunErrorBase));
    var CannotCloseWindowWithChildrenError = /** @class */ (function (_super) {
        __extends(CannotCloseWindowWithChildrenError, _super);
        function CannotCloseWindowWithChildrenError() {
            return _super.call(this, TEST_RUN_ERRORS.cannotCloseWindowWithChildrenError) || this;
        }
        return CannotCloseWindowWithChildrenError;
    }(TestRunErrorBase));
    var CannotCloseWindowWithoutParentError = /** @class */ (function (_super) {
        __extends(CannotCloseWindowWithoutParentError, _super);
        function CannotCloseWindowWithoutParentError() {
            return _super.call(this, TEST_RUN_ERRORS.cannotCloseWindowWithoutParent) || this;
        }
        return CannotCloseWindowWithoutParentError;
    }(TestRunErrorBase));
    var SwitchToWindowPredicateError = /** @class */ (function (_super) {
        __extends(SwitchToWindowPredicateError, _super);
        function SwitchToWindowPredicateError(errMsg) {
            var _this = _super.call(this, TEST_RUN_ERRORS.switchToWindowPredicateError) || this;
            _this.errMsg = errMsg;
            return _this;
        }
        return SwitchToWindowPredicateError;
    }(TestRunErrorBase));
    var WindowNotFoundError = /** @class */ (function (_super) {
        __extends(WindowNotFoundError, _super);
        function WindowNotFoundError() {
            return _super.call(this, TEST_RUN_ERRORS.targetWindowNotFoundError) || this;
        }
        return WindowNotFoundError;
    }(TestRunErrorBase));
    var ParentWindowNotFoundError = /** @class */ (function (_super) {
        __extends(ParentWindowNotFoundError, _super);
        function ParentWindowNotFoundError() {
            return _super.call(this, TEST_RUN_ERRORS.parentWindowNotFoundError) || this;
        }
        return ParentWindowNotFoundError;
    }(TestRunErrorBase));
    var PreviousWindowNotFoundError = /** @class */ (function (_super) {
        __extends(PreviousWindowNotFoundError, _super);
        function PreviousWindowNotFoundError() {
            return _super.call(this, TEST_RUN_ERRORS.previousWindowNotFoundError) || this;
        }
        return PreviousWindowNotFoundError;
    }(TestRunErrorBase));
    var ChildWindowClosedBeforeSwitchingError = /** @class */ (function (_super) {
        __extends(ChildWindowClosedBeforeSwitchingError, _super);
        function ChildWindowClosedBeforeSwitchingError() {
            return _super.call(this, TEST_RUN_ERRORS.childWindowClosedBeforeSwitchingError) || this;
        }
        return ChildWindowClosedBeforeSwitchingError;
    }(TestRunErrorBase));
    var CannotRestoreChildWindowError = /** @class */ (function (_super) {
        __extends(CannotRestoreChildWindowError, _super);
        function CannotRestoreChildWindowError() {
            return _super.call(this, TEST_RUN_ERRORS.cannotRestoreChildWindowError) || this;
        }
        return CannotRestoreChildWindowError;
    }(TestRunErrorBase));
    var CurrentIframeNotFoundError = /** @class */ (function (_super) {
        __extends(CurrentIframeNotFoundError, _super);
        function CurrentIframeNotFoundError() {
            return _super.call(this, TEST_RUN_ERRORS.currentIframeNotFoundError) || this;
        }
        return CurrentIframeNotFoundError;
    }(TestRunErrorBase));
    var CurrentIframeIsInvisibleError = /** @class */ (function (_super) {
        __extends(CurrentIframeIsInvisibleError, _super);
        function CurrentIframeIsInvisibleError() {
            return _super.call(this, TEST_RUN_ERRORS.currentIframeIsInvisibleError) || this;
        }
        return CurrentIframeIsInvisibleError;
    }(TestRunErrorBase));
    // Native dialog errors
    //--------------------------------------------------------------------
    var NativeDialogNotHandledError = /** @class */ (function (_super) {
        __extends(NativeDialogNotHandledError, _super);
        function NativeDialogNotHandledError(dialogType, url) {
            var _this = _super.call(this, TEST_RUN_ERRORS.nativeDialogNotHandledError) || this;
            _this.dialogType = dialogType;
            _this.pageUrl = url;
            return _this;
        }
        return NativeDialogNotHandledError;
    }(TestRunErrorBase));
    var UncaughtErrorInNativeDialogHandler = /** @class */ (function (_super) {
        __extends(UncaughtErrorInNativeDialogHandler, _super);
        function UncaughtErrorInNativeDialogHandler(dialogType, errMsg, url) {
            var _this = _super.call(this, TEST_RUN_ERRORS.uncaughtErrorInNativeDialogHandler) || this;
            _this.dialogType = dialogType;
            _this.errMsg = errMsg;
            _this.pageUrl = url;
            return _this;
        }
        return UncaughtErrorInNativeDialogHandler;
    }(TestRunErrorBase));

    // -------------------------------------------------------------
    // WARNING: this file is used by both the client and the server.
    // Do not use any browser or node-specific API!
    // -------------------------------------------------------------
    var NATIVE_METHODS_PROPERTY_NAME = '_nativeMethods';
    var BrowserConsoleMessages = /** @class */ (function () {
        function BrowserConsoleMessages(data, nativeMethods) {
            var resultNativeMethods = this._ensureNativeMethods(nativeMethods);
            resultNativeMethods.objectDefineProperty(this, NATIVE_METHODS_PROPERTY_NAME, { value: resultNativeMethods });
            this.concat(data);
        }
        BrowserConsoleMessages.prototype._ensureNativeMethods = function (nativeMethods) {
            return nativeMethods || {
                objectKeys: Object.keys,
                arrayForEach: Array.prototype.forEach,
                arrayConcat: Array.prototype.concat,
                arraySlice: Array.prototype.slice,
                objectDefineProperty: Object.defineProperty,
            };
        };
        BrowserConsoleMessages.prototype._getWindowIds = function (consoleMessages) {
            return this[NATIVE_METHODS_PROPERTY_NAME].objectKeys(consoleMessages);
        };
        BrowserConsoleMessages.prototype._copyArray = function (array) {
            return this[NATIVE_METHODS_PROPERTY_NAME].arraySlice.call(array);
        };
        BrowserConsoleMessages.prototype._concatArrays = function (array, anotherArray) {
            return this[NATIVE_METHODS_PROPERTY_NAME].arrayConcat.call(array, anotherArray);
        };
        BrowserConsoleMessages.prototype.ensureMessageContainer = function (windowId) {
            if (this[windowId])
                return;
            this[windowId] = {
                log: [],
                info: [],
                warn: [],
                error: [],
            };
        };
        BrowserConsoleMessages.prototype.concat = function (consoleMessages) {
            var _this = this;
            if (!consoleMessages)
                return this;
            var windowIds = this._getWindowIds(consoleMessages);
            this[NATIVE_METHODS_PROPERTY_NAME].arrayForEach.call(windowIds, function (windowId) {
                _this.ensureMessageContainer(windowId);
                _this[windowId].log = _this._concatArrays(_this[windowId].log, consoleMessages[windowId].log);
                _this[windowId].info = _this._concatArrays(_this[windowId].info, consoleMessages[windowId].info);
                _this[windowId].warn = _this._concatArrays(_this[windowId].warn, consoleMessages[windowId].warn);
                _this[windowId].error = _this._concatArrays(_this[windowId].error, consoleMessages[windowId].error);
            });
            return this;
        };
        BrowserConsoleMessages.prototype.addMessage = function (type, msg, windowId) {
            this.ensureMessageContainer(windowId);
            this[windowId][type].push(msg);
        };
        BrowserConsoleMessages.prototype.getCopy = function () {
            var _this = this;
            var copy = {};
            var windowIds = this._getWindowIds(this);
            this[NATIVE_METHODS_PROPERTY_NAME].arrayForEach.call(windowIds, function (windowId) {
                copy[windowId] = {
                    log: _this._copyArray(_this[windowId].log),
                    info: _this._copyArray(_this[windowId].info),
                    warn: _this._copyArray(_this[windowId].warn),
                    error: _this._copyArray(_this[windowId].error),
                };
            });
            return copy;
        };
        return BrowserConsoleMessages;
    }());

    var ClientBrowserConsoleMessages = /** @class */ (function (_super) {
        __extends(ClientBrowserConsoleMessages, _super);
        function ClientBrowserConsoleMessages(data) {
            return _super.call(this, data, hammerhead.nativeMethods) || this;
        }
        return ClientBrowserConsoleMessages;
    }(BrowserConsoleMessages));

    function createCommonjsModule(fn, module) {
    	return module = { exports: {} }, fn(module, module.exports), module.exports;
    }

    var replicator = createCommonjsModule(function (module) {
    // Const
    var TRANSFORMED_TYPE_KEY    = '@t';
    var CIRCULAR_REF_KEY        = '@r';
    var KEY_REQUIRE_ESCAPING_RE = /^#*@(t|r)$/;

    var GLOBAL = (function getGlobal () {
        // NOTE: see http://www.ecma-international.org/ecma-262/6.0/index.html#sec-performeval step 10
        var savedEval = eval;

        return savedEval('this');
    })();

    var TYPED_ARRAY_CTORS = {
        'Int8Array':         typeof Int8Array === 'function' ? Int8Array : void 0,
        'Uint8Array':        typeof Uint8Array === 'function' ? Uint8Array : void 0,
        'Uint8ClampedArray': typeof Uint8ClampedArray === 'function' ? Uint8ClampedArray : void 0,
        'Int16Array':        typeof Int16Array === 'function' ? Int16Array : void 0,
        'Uint16Array':       typeof Uint16Array === 'function' ? Uint16Array : void 0,
        'Int32Array':        typeof Int32Array === 'function' ? Int32Array : void 0,
        'Uint32Array':       typeof Uint32Array === 'function' ? Uint32Array : void 0,
        'Float32Array':      typeof Float32Array === 'function' ? Float32Array : void 0,
        'Float64Array':      typeof Float64Array === 'function' ? Float64Array : void 0
    };

    var ARRAY_BUFFER_SUPPORTED = typeof ArrayBuffer === 'function';
    var MAP_SUPPORTED          = typeof Map === 'function';
    var SET_SUPPORTED          = typeof Set === 'function';
    var BUFFER_FROM_SUPPORTED  = typeof Buffer === 'function';

    var TYPED_ARRAY_SUPPORTED  = function (typeName) {
        return !!TYPED_ARRAY_CTORS[typeName];
    };

    // Saved proto functions
    var arrSlice = Array.prototype.slice;


    // Default serializer
    var JSONSerializer = {
        serialize: function (val) {
            return JSON.stringify(val);
        },

        deserialize: function (val) {
            return JSON.parse(val);
        }
    };


    // EncodingTransformer
    var EncodingTransformer = function (val, transforms) {
        this.references               = val;
        this.transforms               = transforms;
        this.circularCandidates       = [];
        this.circularCandidatesDescrs = [];
        this.circularRefCount         = 0;
    };

    EncodingTransformer._createRefMark = function (idx) {
        var obj = Object.create(null);

        obj[CIRCULAR_REF_KEY] = idx;

        return obj;
    };

    EncodingTransformer.prototype._createCircularCandidate = function (val, parent, key) {
        this.circularCandidates.push(val);
        this.circularCandidatesDescrs.push({ parent: parent, key: key, refIdx: -1 });
    };

    EncodingTransformer.prototype._applyTransform = function (val, parent, key, transform) {
        var result          = Object.create(null);
        var serializableVal = transform.toSerializable(val);

        if (typeof serializableVal === 'object')
            this._createCircularCandidate(val, parent, key);

        result[TRANSFORMED_TYPE_KEY] = transform.type;
        result.data                  = this._handleValue(serializableVal, parent, key);

        return result;
    };

    EncodingTransformer.prototype._handleArray = function (arr) {
        var result = [];

        for (var i = 0; i < arr.length; i++)
            result[i] = this._handleValue(arr[i], result, i);

        return result;
    };

    EncodingTransformer.prototype._handlePlainObject = function (obj) {
        var replicator       = this;
        var result           = Object.create(null);
        var ownPropertyNames = Object.getOwnPropertyNames(obj);

        ownPropertyNames.forEach(function (key) {
            var resultKey = KEY_REQUIRE_ESCAPING_RE.test(key) ? '#' + key : key;

            result[resultKey] = replicator._handleValue(obj[key], result, resultKey);
        });

        return result;
    };

    EncodingTransformer.prototype._handleObject = function (obj, parent, key) {
        this._createCircularCandidate(obj, parent, key);

        return Array.isArray(obj) ? this._handleArray(obj) : this._handlePlainObject(obj);
    };

    EncodingTransformer.prototype._ensureCircularReference = function (obj) {
        var circularCandidateIdx = this.circularCandidates.indexOf(obj);

        if (circularCandidateIdx > -1) {
            var descr = this.circularCandidatesDescrs[circularCandidateIdx];

            if (descr.refIdx === -1)
                descr.refIdx = descr.parent ? ++this.circularRefCount : 0;

            return EncodingTransformer._createRefMark(descr.refIdx);
        }

        return null;
    };

    EncodingTransformer.prototype._handleValue = function (val, parent, key) {
        var type     = typeof val;
        var isObject = type === 'object' && val !== null;

        if (isObject) {
            var refMark = this._ensureCircularReference(val);

            if (refMark)
                return refMark;
        }

        for (var i = 0; i < this.transforms.length; i++) {
            var transform = this.transforms[i];

            if (transform.shouldTransform(type, val))
                return this._applyTransform(val, parent, key, transform);
        }

        if (isObject)
            return this._handleObject(val, parent, key);

        return val;
    };

    EncodingTransformer.prototype.transform = function () {
        var references = [this._handleValue(this.references, null, null)];

        for (var i = 0; i < this.circularCandidatesDescrs.length; i++) {
            var descr = this.circularCandidatesDescrs[i];

            if (descr.refIdx > 0) {
                references[descr.refIdx] = descr.parent[descr.key];
                descr.parent[descr.key]  = EncodingTransformer._createRefMark(descr.refIdx);
            }
        }

        return references;
    };

    // DecodingTransform
    var DecodingTransformer = function (references, transformsMap) {
        this.references            = references;
        this.transformMap          = transformsMap;
        this.activeTransformsStack = [];
        this.visitedRefs           = Object.create(null);
    };

    DecodingTransformer.prototype._handlePlainObject = function (obj) {
        var replicator       = this;
        var unescaped        = Object.create(null);
        var ownPropertyNames = Object.getOwnPropertyNames(obj);

        ownPropertyNames.forEach(function (key) {
            replicator._handleValue(obj[key], obj, key);

            if (KEY_REQUIRE_ESCAPING_RE.test(key)) {
                // NOTE: use intermediate object to avoid unescaped and escaped keys interference
                // E.g. unescaped "##@t" will be "#@t" which can overwrite escaped "#@t".
                unescaped[key.substring(1)] = obj[key];
                delete obj[key];
            }
        });

        for (var unsecapedKey in unescaped)
            obj[unsecapedKey] = unescaped[unsecapedKey];
    };

    DecodingTransformer.prototype._handleTransformedObject = function (obj, parent, key) {
        var transformType = obj[TRANSFORMED_TYPE_KEY];
        var transform     = this.transformMap[transformType];

        if (!transform)
            throw new Error('Can\'t find transform for "' + transformType + '" type.');

        this.activeTransformsStack.push(obj);
        this._handleValue(obj.data, obj, 'data');
        this.activeTransformsStack.pop();

        parent[key] = transform.fromSerializable(obj.data);
    };

    DecodingTransformer.prototype._handleCircularSelfRefDuringTransform = function (refIdx, parent, key) {
        // NOTE: we've hit a hard case: object reference itself during transformation.
        // We can't dereference it since we don't have resulting object yet. And we'll
        // not be able to restore reference lately because we will need to traverse
        // transformed object again and reference might be unreachable or new object contain
        // new circular references. As a workaround we create getter, so once transformation
        // complete, dereferenced property will point to correct transformed object.
        var references = this.references;
        var val = void 0;

        Object.defineProperty(parent, key, {
            configurable: true,
            enumerable:   true,

            get: function () {
                if (val === void 0)
                    val = references[refIdx];

                return val;
            },

            set: function (value) {
                val = value;
                return val;
            }
        });
    };

    DecodingTransformer.prototype._handleCircularRef = function (refIdx, parent, key) {
        if (this.activeTransformsStack.indexOf(this.references[refIdx]) > -1)
            this._handleCircularSelfRefDuringTransform(refIdx, parent, key);

        else {
            if (!this.visitedRefs[refIdx]) {
                this.visitedRefs[refIdx] = true;
                this._handleValue(this.references[refIdx], this.references, refIdx);
            }

            parent[key] = this.references[refIdx];
        }
    };

    DecodingTransformer.prototype._handleValue = function (val, parent, key) {
        if (typeof val !== 'object' || val === null)
            return;

        var refIdx = val[CIRCULAR_REF_KEY];

        if (refIdx !== void 0)
            this._handleCircularRef(refIdx, parent, key);

        else if (val[TRANSFORMED_TYPE_KEY])
            this._handleTransformedObject(val, parent, key);

        else if (Array.isArray(val)) {
            for (var i = 0; i < val.length; i++)
                this._handleValue(val[i], val, i);
        }

        else
            this._handlePlainObject(val);
    };

    DecodingTransformer.prototype.transform = function () {
        this.visitedRefs[0] = true;
        this._handleValue(this.references[0], this.references, 0);

        return this.references[0];
    };


    // Transforms
    var builtInTransforms = [
        {
            type: '[[NaN]]',

            shouldTransform: function (type, val) {
                return type === 'number' && isNaN(val);
            },

            toSerializable: function () {
                return '';
            },

            fromSerializable: function () {
                return NaN;
            }
        },

        {
            type: '[[undefined]]',

            shouldTransform: function (type) {
                return type === 'undefined';
            },

            toSerializable: function () {
                return '';
            },

            fromSerializable: function () {
                return void 0;
            }
        },
        {
            type: '[[Date]]',

            shouldTransform: function (type, val) {
                return val instanceof Date;
            },

            toSerializable: function (date) {
                return date.getTime();
            },

            fromSerializable: function (val) {
                var date = new Date();

                date.setTime(val);
                return date;
            }
        },
        {
            type: '[[RegExp]]',

            shouldTransform: function (type, val) {
                return val instanceof RegExp;
            },

            toSerializable: function (re) {
                var result = {
                    src:   re.source,
                    flags: ''
                };

                if (re.global)
                    result.flags += 'g';

                if (re.ignoreCase)
                    result.flags += 'i';

                if (re.multiline)
                    result.flags += 'm';

                return result;
            },

            fromSerializable: function (val) {
                return new RegExp(val.src, val.flags);
            }
        },

        {
            type: '[[Error]]',

            shouldTransform: function (type, val) {
                return val instanceof Error;
            },

            toSerializable: function (err) {
                return {
                    name:    err.name,
                    message: err.message,
                    stack:   err.stack
                };
            },

            fromSerializable: function (val) {
                var Ctor = GLOBAL[val.name] || Error;
                var err  = new Ctor(val.message);

                err.stack = val.stack;
                return err;
            }
        },

        {
            type: '[[ArrayBuffer]]',

            shouldTransform: function (type, val) {
                return ARRAY_BUFFER_SUPPORTED && val instanceof ArrayBuffer;
            },

            toSerializable: function (buffer) {
                var view = new Int8Array(buffer);

                return arrSlice.call(view);
            },

            fromSerializable: function (val) {
                if (ARRAY_BUFFER_SUPPORTED) {
                    var buffer = new ArrayBuffer(val.length);
                    var view   = new Int8Array(buffer);

                    view.set(val);

                    return buffer;
                }

                return val;
            }
        },

        {
            type: '[[Buffer]]',

            shouldTransform: function (type, val) {
                return BUFFER_FROM_SUPPORTED && val instanceof Buffer;
            },

            toSerializable: function (buffer) {
                return arrSlice.call(buffer);
            },

            fromSerializable: function (val) {
                if (BUFFER_FROM_SUPPORTED)
                    return Buffer.from(val);

                return val;
            }
        },

        {
            type: '[[TypedArray]]',

            shouldTransform: function (type, val) {
                return Object.keys(TYPED_ARRAY_CTORS).some(function (ctorName) {
                    return TYPED_ARRAY_SUPPORTED(ctorName) && val instanceof TYPED_ARRAY_CTORS[ctorName];
                });
            },

            toSerializable: function (arr) {
                return {
                    ctorName: arr.constructor.name,
                    arr:      arrSlice.call(arr)
                };
            },

            fromSerializable: function (val) {
                return TYPED_ARRAY_SUPPORTED(val.ctorName) ? new TYPED_ARRAY_CTORS[val.ctorName](val.arr) : val.arr;
            }
        },

        {
            type: '[[Map]]',

            shouldTransform: function (type, val) {
                return MAP_SUPPORTED && val instanceof Map;
            },

            toSerializable: function (map) {
                var flattenedKVArr = [];

                map.forEach(function (val, key) {
                    flattenedKVArr.push(key);
                    flattenedKVArr.push(val);
                });

                return flattenedKVArr;
            },

            fromSerializable: function (val) {
                if (MAP_SUPPORTED) {
                    // NOTE: new Map(iterable) is not supported by all browsers
                    var map = new Map();

                    for (var i = 0; i < val.length; i += 2)
                        map.set(val[i], val[i + 1]);

                    return map;
                }

                var kvArr = [];

                for (var j = 0; j < val.length; j += 2)
                    kvArr.push([val[i], val[i + 1]]);

                return kvArr;
            }
        },

        {
            type: '[[Set]]',

            shouldTransform: function (type, val) {
                return SET_SUPPORTED && val instanceof Set;
            },

            toSerializable: function (set) {
                var arr = [];

                set.forEach(function (val) {
                    arr.push(val);
                });

                return arr;
            },

            fromSerializable: function (val) {
                if (SET_SUPPORTED) {
                    // NOTE: new Set(iterable) is not supported by all browsers
                    var set = new Set();

                    for (var i = 0; i < val.length; i++)
                        set.add(val[i]);

                    return set;
                }

                return val;
            }
        }
    ];

    // Replicator
    var Replicator = module.exports = function (serializer) {
        this.transforms    = [];
        this.transformsMap = Object.create(null);
        this.serializer    = serializer || JSONSerializer;

        this.addTransforms(builtInTransforms);
    };

    // Manage transforms
    Replicator.prototype.addTransforms = function (transforms) {
        transforms = Array.isArray(transforms) ? transforms : [transforms];

        for (var i = 0; i < transforms.length; i++) {
            var transform = transforms[i];

            if (this.transformsMap[transform.type])
                throw new Error('Transform with type "' + transform.type + '" was already added.');

            this.transforms.push(transform);
            this.transformsMap[transform.type] = transform;
        }

        return this;
    };

    Replicator.prototype.removeTransforms = function (transforms) {
        transforms = Array.isArray(transforms) ? transforms : [transforms];

        for (var i = 0; i < transforms.length; i++) {
            var transform = transforms[i];
            var idx       = this.transforms.indexOf(transform);

            if (idx > -1)
                this.transforms.splice(idx, 1);

            delete this.transformsMap[transform.type];
        }

        return this;
    };

    Replicator.prototype.encode = function (val) {
        var transformer = new EncodingTransformer(val, this.transforms);
        var references  = transformer.transform();

        return this.serializer.serialize(references);
    };

    Replicator.prototype.decode = function (val) {
        var references  = this.serializer.deserialize(val);
        var transformer = new DecodingTransformer(references, this.transformsMap);

        return transformer.transform();
    };
    });

    var identity = function (val) { return val; };
    function createReplicator(transforms) {
        // NOTE: we will serialize replicator results
        // to JSON with a command or command result.
        // Therefore there is no need to do additional job here,
        // so we use identity functions for serialization.
        var replicator$1 = new replicator({
            serialize: identity,
            deserialize: identity,
        });
        return replicator$1.addTransforms(transforms);
    }

    // @ts-ignore
    var adapter = {};
    function initializeAdapter(initializer) {
        if (initializer.nativeMethods.objectAssign) {
            initializer.nativeMethods.objectAssign(adapter, initializer);
            return;
        }
        var keys = initializer.nativeMethods.objectKeys(initializer);
        for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
            var key = keys_1[_i];
            // @ts-ignore
            adapter[key] = initializer[key];
        }
    }

    function visible(el) {
        if (!adapter.isDomElement(el) && !adapter.isTextNode(el))
            return false;
        if (adapter.isOptionElement(el) || adapter.getTagName(el) === 'optgroup')
            return adapter.isOptionElementVisible(el);
        return adapter.isElementVisible(el);
    }
    function isNodeCollection(obj) {
        return obj instanceof adapter.nativeMethods.HTMLCollection || obj instanceof adapter.nativeMethods.NodeList;
    }
    function castToArray(list) {
        var length = list.length;
        var result = [];
        for (var i = 0; i < length; i++)
            result.push(list[i]);
        return result;
    }
    function isArrayOfNodes(obj) {
        if (!adapter.nativeMethods.isArray(obj))
            return false;
        for (var i = 0; i < obj.length; i++) {
            if (!(obj[i] instanceof adapter.nativeMethods.Node))
                return false;
        }
        return true;
    }

    var _a;
    var SELECTOR_FILTER_ERROR = {
        filterVisible: 1,
        filterHidden: 2,
        nth: 3,
    };
    var FILTER_ERROR_TO_API_RE = (_a = {},
        _a[SELECTOR_FILTER_ERROR.filterVisible] = /^\.filterVisible\(\)$/,
        _a[SELECTOR_FILTER_ERROR.filterHidden] = /^\.filterHidden\(\)$/,
        _a[SELECTOR_FILTER_ERROR.nth] = /^\.nth\(\d+\)$/,
        _a);
    var SelectorFilter = /** @class */ (function () {
        function SelectorFilter() {
            this._err = null;
        }
        Object.defineProperty(SelectorFilter.prototype, "error", {
            get: function () {
                return this._err;
            },
            set: function (message) {
                if (this._err === null)
                    this._err = message;
            },
            enumerable: false,
            configurable: true
        });
        SelectorFilter.prototype.filter = function (nodes, options, apiInfo) {
            if (options.filterVisible) {
                nodes = nodes.filter(visible);
                this._assertFilterError(nodes, apiInfo, SELECTOR_FILTER_ERROR.filterVisible);
            }
            if (options.filterHidden) {
                nodes = nodes.filter(function (n) { return !visible(n); });
                this._assertFilterError(nodes, apiInfo, SELECTOR_FILTER_ERROR.filterHidden);
            }
            if (options.counterMode) {
                if (options.index === null)
                    return nodes.length;
                return SelectorFilter._getNodeByIndex(nodes, options.index) ? 1 : 0;
            }
            if (options.collectionMode) {
                if (options.index !== null) {
                    var nodeOnIndex_1 = SelectorFilter._getNodeByIndex(nodes, options.index);
                    nodes = nodeOnIndex_1 ? [nodeOnIndex_1] : [];
                    this._assertFilterError(nodes, apiInfo, SELECTOR_FILTER_ERROR.nth);
                }
                return nodes;
            }
            var nodeOnIndex = SelectorFilter._getNodeByIndex(nodes, options.index || 0);
            if (!nodeOnIndex)
                this.error = SelectorFilter._getErrorItem(apiInfo, SELECTOR_FILTER_ERROR.nth);
            return nodeOnIndex;
        };
        SelectorFilter.prototype.cast = function (searchResult) {
            if (searchResult === null || searchResult === void 0)
                return [];
            else if (searchResult instanceof adapter.nativeMethods.Node)
                return [searchResult];
            else if (isArrayOfNodes(searchResult))
                return searchResult;
            else if (isNodeCollection(searchResult))
                return castToArray(searchResult);
            throw new InvalidSelectorResultError();
        };
        SelectorFilter.prototype._assertFilterError = function (filtered, apiInfo, filterError) {
            if (filtered.length === 0)
                this.error = SelectorFilter._getErrorItem(apiInfo, filterError);
        };
        SelectorFilter._getErrorItem = function (_a, err) {
            var apiFnChain = _a.apiFnChain, apiFnID = _a.apiFnID;
            if (err) {
                for (var i = apiFnID; i < apiFnChain.length; i++) {
                    if (FILTER_ERROR_TO_API_RE[err].test(apiFnChain[i]))
                        return i;
                }
            }
            return null;
        };
        SelectorFilter._getNodeByIndex = function (nodes, index) {
            return index < 0 ? nodes[nodes.length + index] : nodes[index];
        };
        return SelectorFilter;
    }());
    var selectorFilter = new SelectorFilter();

    // NOTE: evalFunction is isolated into a separate module to
    // restrict access to TestCafe intrinsics for the evaluated code.
    // It also accepts `__dependencies$` argument which may be used by evaluated code.
    function evalFunction(fnCode, __dependencies$) {
        var FunctionCtor = adapter.nativeMethods.Function;
        if (adapter.isProxyless) {
            var evaluator_1 = new FunctionCtor('fnCode', '__dependencies$', '"use strict"; return eval(fnCode)');
            return evaluator_1(fnCode, __dependencies$);
        }
        var evaluator = new FunctionCtor('fnCode', '__dependencies$', 'Promise', 
        // NOTE: we should pass the original `RegExp`
        // to make the `instanceof RegExp` check successful in different contexts
        'RegExp', 
        // NOTE: `eval` in strict mode will not override context variables
        '"use strict"; return eval(fnCode)');
        return evaluator(fnCode, __dependencies$, adapter.PromiseCtor, RegExp);
    }

    var FunctionTransform = /** @class */ (function () {
        function FunctionTransform() {
            this.type = 'Function';
        }
        FunctionTransform.prototype.shouldTransform = function (type) {
            return type === 'function';
        };
        FunctionTransform.prototype.toSerializable = function () {
            return '';
        };
        // HACK: UglifyJS + TypeScript + argument destructuring can generate incorrect code.
        // So we have to use plain assignments here.
        FunctionTransform.prototype.fromSerializable = function (opts) {
            var fnCode = opts.fnCode;
            var dependencies = opts.dependencies;
            if ('filterOptions' in dependencies)
                dependencies.selectorFilter = selectorFilter;
            return evalFunction(fnCode, dependencies);
        };
        return FunctionTransform;
    }());

    var ClientFunctionNodeTransform = /** @class */ (function () {
        function ClientFunctionNodeTransform(instantiationCallsiteName) {
            this.type = 'Node';
            this._instantiationCallsiteName = instantiationCallsiteName;
        }
        ClientFunctionNodeTransform.prototype.shouldTransform = function (type, val) {
            if (val instanceof adapter.nativeMethods.Node)
                throw new DomNodeClientFunctionResultError(this._instantiationCallsiteName);
            return false;
        };
        ClientFunctionNodeTransform.prototype.toSerializable = function () {
        };
        ClientFunctionNodeTransform.prototype.fromSerializable = function () {
        };
        return ClientFunctionNodeTransform;
    }());

    var ClientFunctionExecutor = /** @class */ (function () {
        function ClientFunctionExecutor(command) {
            this.command = command;
            this.replicator = this._createReplicator();
            this.dependencies = this.replicator.decode(command.dependencies);
            this.fn = evalFunction(command.fnCode, this.dependencies);
        }
        ClientFunctionExecutor.prototype.getResult = function () {
            var _this = this;
            return adapter.PromiseCtor.resolve()
                .then(function () {
                var args = _this.replicator.decode(_this.command.args);
                return _this._executeFn(args);
            })
                .catch(function (err) {
                if (!err.isTestCafeError && !adapter.isProxyless)
                    err = new UncaughtErrorInClientFunctionCode(_this.command.instantiationCallsiteName, err);
                throw err;
            });
        };
        ClientFunctionExecutor.prototype.encodeResult = function (result) {
            return this.replicator.encode(result);
        };
        ClientFunctionExecutor.prototype._createReplicator = function () {
            return createReplicator([
                new ClientFunctionNodeTransform(this.command.instantiationCallsiteName),
                new FunctionTransform(),
            ]);
        };
        ClientFunctionExecutor.prototype._executeFn = function (args) {
            return this.fn.apply(window, args);
        };
        return ClientFunctionExecutor;
    }());

    var MESSAGE_TYPE = {
        appearedDialog: 'appeared-dialog',
        unexpectedDialog: 'unexpected-dialog',
        handlerError: 'handler-error',
    };

    var messageSandbox = hammerhead__default.eventSandbox.message;
    var processScript = hammerhead__default.processScript;
    var nativeMethods = hammerhead__default.nativeMethods;
    var APPEARED_DIALOGS = 'testcafe|native-dialog-tracker|appeared-dialogs';
    var UNEXPECTED_DIALOG = 'testcafe|native-dialog-tracker|unexpected-dialog';
    var ERROR_IN_HANDLER = 'testcafe|native-dialog-tracker|error-in-handler';
    var GETTING_PAGE_URL_PROCESSED_SCRIPT = processScript('window.location.href');
    var NativeDialogTracker = /** @class */ (function () {
        function NativeDialogTracker(contextStorage, dialogHandler) {
            this.contextStorage = contextStorage;
            this.dialogHandler = dialogHandler;
            this._init();
            this._initListening();
            if (this.dialogHandler)
                this.setHandler(dialogHandler);
        }
        Object.defineProperty(NativeDialogTracker.prototype, "appearedDialogs", {
            get: function () {
                var dialogs = this.contextStorage.getItem(APPEARED_DIALOGS);
                if (!dialogs) {
                    dialogs = [];
                    this.appearedDialogs = dialogs;
                }
                return dialogs;
            },
            set: function (dialog) {
                this.contextStorage.setItem(APPEARED_DIALOGS, dialog);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NativeDialogTracker.prototype, "unexpectedDialog", {
            get: function () {
                return this.contextStorage.getItem(UNEXPECTED_DIALOG);
            },
            set: function (dialog) {
                this.contextStorage.setItem(UNEXPECTED_DIALOG, dialog);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NativeDialogTracker.prototype, "handlerError", {
            get: function () {
                return this.contextStorage.getItem(ERROR_IN_HANDLER);
            },
            set: function (dialog) {
                this.contextStorage.setItem(ERROR_IN_HANDLER, dialog);
            },
            enumerable: false,
            configurable: true
        });
        NativeDialogTracker._getPageUrl = function () {
            return nativeMethods.eval(GETTING_PAGE_URL_PROCESSED_SCRIPT);
        };
        NativeDialogTracker.prototype._initListening = function () {
            var _this = this;
            messageSandbox.on(messageSandbox.SERVICE_MSG_RECEIVED_EVENT, function (e) {
                var msg = e.message;
                if (msg.type === MESSAGE_TYPE.appearedDialog)
                    // eslint-disable-next-line no-restricted-properties
                    _this._addAppearedDialogs(msg.dialogType, msg.text, msg.url);
                else if (msg.type === MESSAGE_TYPE.unexpectedDialog && !_this.unexpectedDialog)
                    _this.unexpectedDialog = { type: msg.dialogType, url: msg.url };
                else if (msg.type === MESSAGE_TYPE.handlerError && !_this.handlerError)
                    _this._onHandlerError(msg.dialogType, msg.message, msg.url);
            });
        };
        NativeDialogTracker.prototype._init = function () {
            var _this = this;
            hammerhead__default.on(hammerhead__default.EVENTS.beforeUnload, function (e) {
                if (e.prevented && !e.isFakeIEEvent) {
                    if (_this.dialogHandler) {
                        var handler = _this._createDialogHandler('beforeunload');
                        handler(e.returnValue || '');
                    }
                    else
                        _this._defaultDialogHandler('beforeunload');
                }
                // NOTE: we should save changes that could be made via 'shift' and 'push' methods.
                if (_this.contextStorage)
                    _this.contextStorage.save();
            });
            window.alert = function () { return _this._defaultDialogHandler('alert'); };
            window.confirm = function () { return _this._defaultDialogHandler('confirm'); };
            window.prompt = function () { return _this._defaultDialogHandler('prompt'); };
        };
        NativeDialogTracker.prototype._createDialogHandler = function (type) {
            var _this = this;
            return function (text) {
                var url = NativeDialogTracker._getPageUrl();
                _this._addAppearedDialogs(type, text, url);
                var executor = new ClientFunctionExecutor(_this.dialogHandler);
                var result = null;
                try {
                    result = executor.fn.apply(window, [type, text, url]);
                }
                catch (err) {
                    _this._onHandlerError(type, err.message || String(err), url);
                }
                return result;
            };
        };
        // Overridable methods
        NativeDialogTracker.prototype._defaultDialogHandler = function (type) {
            var url = NativeDialogTracker._getPageUrl();
            this.unexpectedDialog = this.unexpectedDialog || { type: type, url: url };
        };
        NativeDialogTracker.prototype._addAppearedDialogs = function (type, text, url) {
            this.appearedDialogs.splice(0, 0, { type: type, text: text, url: url });
        };
        NativeDialogTracker.prototype._onHandlerError = function (type, message, url) {
            this.handlerError = this.handlerError || { type: type, message: message, url: url };
        };
        // API
        NativeDialogTracker.prototype.setHandler = function (dialogHandler) {
            var _this = this;
            this.dialogHandler = dialogHandler;
            ['alert', 'confirm', 'prompt'].forEach(function (dialogType) {
                window[dialogType] = _this.dialogHandler ?
                    _this._createDialogHandler(dialogType) :
                    function () { return _this._defaultDialogHandler(dialogType); };
            });
        };
        NativeDialogTracker.prototype.getUnexpectedDialogError = function () {
            var unexpectedDialog = this.unexpectedDialog;
            var handlerError = this.handlerError;
            this.unexpectedDialog = null;
            this.handlerError = null;
            if (unexpectedDialog)
                return new NativeDialogNotHandledError(unexpectedDialog.type, unexpectedDialog.url);
            if (handlerError)
                return new UncaughtErrorInNativeDialogHandler(handlerError.type, handlerError.message, handlerError.url);
            return null;
        };
        return NativeDialogTracker;
    }());

    function generateId () {
        return hammerhead.nativeMethods.performanceNow().toString();
    }

    var TYPE = {
        establishConnection: 'driver|establish-connection',
        switchToWindow: 'driver|switch-to-window',
        closeWindow: 'driver|close-window',
        closeWindowValidation: 'driver|close-window-validation',
        switchToWindowValidation: 'driver|switch-to-window-validation',
        getWindows: 'driver|get-windows',
        commandExecuted: 'driver|command-executed',
        executeCommand: 'driver|execute-command',
        confirmation: 'driver|confirmation',
        setNativeDialogHandler: 'driver|set-native-dialog-handler',
        setAsMaster: 'driver|set-as-master',
        closeAllChildWindows: 'driver|close-all-child-windows',
        startToRestoreChildLink: 'driver|start-to-restore-child-link',
        restoreChildLink: 'driver|restore-child-link',
        childWindowIsLoadedInIFrame: 'driver|child-window-is-loaded-in-iframe',
        childWindowIsOpenedInIFrame: 'driver|child-window-is-opened-in-iframe',
        hasPendingActionFlags: 'driver|has-pending-action-flags',
    };
    var InterDriverMessage = /** @class */ (function () {
        function InterDriverMessage(type) {
            this.type = type;
            this.id = generateId();
        }
        return InterDriverMessage;
    }());
    var EstablishConnectionMessage = /** @class */ (function (_super) {
        __extends(EstablishConnectionMessage, _super);
        function EstablishConnectionMessage() {
            return _super.call(this, TYPE.establishConnection) || this;
        }
        return EstablishConnectionMessage;
    }(InterDriverMessage));
    var CloseWindowValidationMessage = /** @class */ (function (_super) {
        __extends(CloseWindowValidationMessage, _super);
        function CloseWindowValidationMessage(_a) {
            var windowId = _a.windowId;
            var _this = _super.call(this, TYPE.closeWindowValidation) || this;
            _this.windowId = windowId;
            return _this;
        }
        return CloseWindowValidationMessage;
    }(InterDriverMessage));
    var SwitchToWindowValidationMessage = /** @class */ (function (_super) {
        __extends(SwitchToWindowValidationMessage, _super);
        function SwitchToWindowValidationMessage(_a) {
            var windowId = _a.windowId, fn = _a.fn;
            var _this = _super.call(this, TYPE.switchToWindowValidation) || this;
            _this.windowId = windowId;
            _this.fn = fn;
            return _this;
        }
        return SwitchToWindowValidationMessage;
    }(InterDriverMessage));
    var GetWindowsMessage = /** @class */ (function (_super) {
        __extends(GetWindowsMessage, _super);
        function GetWindowsMessage() {
            return _super.call(this, TYPE.getWindows) || this;
        }
        return GetWindowsMessage;
    }(InterDriverMessage));
    var CloseWindowCommandMessage = /** @class */ (function (_super) {
        __extends(CloseWindowCommandMessage, _super);
        function CloseWindowCommandMessage(_a) {
            var windowId = _a.windowId, isCurrentWindow = _a.isCurrentWindow;
            var _this = _super.call(this, TYPE.closeWindow) || this;
            _this.windowId = windowId;
            _this.isCurrentWindow = isCurrentWindow;
            return _this;
        }
        return CloseWindowCommandMessage;
    }(InterDriverMessage));
    var SwitchToWindowCommandMessage = /** @class */ (function (_super) {
        __extends(SwitchToWindowCommandMessage, _super);
        function SwitchToWindowCommandMessage(_a) {
            var windowId = _a.windowId, fn = _a.fn;
            var _this = _super.call(this, TYPE.switchToWindow) || this;
            _this.windowId = windowId;
            _this.fn = fn;
            return _this;
        }
        return SwitchToWindowCommandMessage;
    }(InterDriverMessage));
    var CommandExecutedMessage = /** @class */ (function (_super) {
        __extends(CommandExecutedMessage, _super);
        function CommandExecutedMessage(driverStatus) {
            var _this = _super.call(this, TYPE.commandExecuted) || this;
            _this.driverStatus = driverStatus;
            return _this;
        }
        return CommandExecutedMessage;
    }(InterDriverMessage));
    var ExecuteCommandMessage = /** @class */ (function (_super) {
        __extends(ExecuteCommandMessage, _super);
        function ExecuteCommandMessage(command, testSpeed) {
            var _this = _super.call(this, TYPE.executeCommand) || this;
            _this.command = command;
            _this.testSpeed = testSpeed;
            return _this;
        }
        return ExecuteCommandMessage;
    }(InterDriverMessage));
    var ConfirmationMessage = /** @class */ (function (_super) {
        __extends(ConfirmationMessage, _super);
        function ConfirmationMessage(requestMessageId, result) {
            var _this = _super.call(this, TYPE.confirmation) || this;
            _this.requestMessageId = requestMessageId;
            _this.result = result;
            return _this;
        }
        return ConfirmationMessage;
    }(InterDriverMessage));
    var SetNativeDialogHandlerMessage = /** @class */ (function (_super) {
        __extends(SetNativeDialogHandlerMessage, _super);
        function SetNativeDialogHandlerMessage(dialogHandler) {
            var _this = _super.call(this, TYPE.setNativeDialogHandler) || this;
            _this.dialogHandler = dialogHandler;
            return _this;
        }
        return SetNativeDialogHandlerMessage;
    }(InterDriverMessage));
    var SetAsMasterMessage = /** @class */ (function (_super) {
        __extends(SetAsMasterMessage, _super);
        function SetAsMasterMessage(finalizePendingCommand) {
            var _this = _super.call(this, TYPE.setAsMaster) || this;
            _this.finalizePendingCommand = finalizePendingCommand;
            return _this;
        }
        return SetAsMasterMessage;
    }(InterDriverMessage));
    var CloseAllChildWindowsMessage = /** @class */ (function (_super) {
        __extends(CloseAllChildWindowsMessage, _super);
        function CloseAllChildWindowsMessage() {
            return _super.call(this, TYPE.closeAllChildWindows) || this;
        }
        return CloseAllChildWindowsMessage;
    }(InterDriverMessage));
    var StartToRestoreChildLinkMessage = /** @class */ (function (_super) {
        __extends(StartToRestoreChildLinkMessage, _super);
        function StartToRestoreChildLinkMessage() {
            return _super.call(this, TYPE.startToRestoreChildLink) || this;
        }
        return StartToRestoreChildLinkMessage;
    }(InterDriverMessage));
    var RestoreChildLinkMessage = /** @class */ (function (_super) {
        __extends(RestoreChildLinkMessage, _super);
        function RestoreChildLinkMessage(windowId) {
            var _this = _super.call(this, TYPE.restoreChildLink) || this;
            _this.windowId = windowId;
            return _this;
        }
        return RestoreChildLinkMessage;
    }(InterDriverMessage));
    var ChildWindowIsLoadedInFrameMessage = /** @class */ (function (_super) {
        __extends(ChildWindowIsLoadedInFrameMessage, _super);
        function ChildWindowIsLoadedInFrameMessage(windowId) {
            var _this = _super.call(this, TYPE.childWindowIsLoadedInIFrame) || this;
            _this.windowId = windowId;
            return _this;
        }
        return ChildWindowIsLoadedInFrameMessage;
    }(InterDriverMessage));
    var ChildWindowIsOpenedInFrameMessage = /** @class */ (function (_super) {
        __extends(ChildWindowIsOpenedInFrameMessage, _super);
        function ChildWindowIsOpenedInFrameMessage() {
            return _super.call(this, TYPE.childWindowIsOpenedInIFrame) || this;
        }
        return ChildWindowIsOpenedInFrameMessage;
    }(InterDriverMessage));
    var HasPendingActionFlagsMessage = /** @class */ (function (_super) {
        __extends(HasPendingActionFlagsMessage, _super);
        function HasPendingActionFlagsMessage() {
            return _super.call(this, TYPE.hasPendingActionFlags) || this;
        }
        return HasPendingActionFlagsMessage;
    }(InterDriverMessage));

    var JSON$1 = hammerhead__default.json;
    var nativeMethods$1 = hammerhead__default.nativeMethods;
    var STORAGE_KEY_PREFIX = 'testcafe|driver|';
    var Storage = /** @class */ (function () {
        function Storage(window, testRunId, windowId) {
            this.storage = nativeMethods$1.winSessionStorageGetter.call(window);
            this.storageKey = this._createStorageKey(testRunId, windowId);
            this.data = {};
            this._loadFromStorage();
        }
        Storage.prototype._createStorageKey = function (testRunId, windowId) {
            var storageKey = STORAGE_KEY_PREFIX + testRunId;
            if (windowId)
                return storageKey + '|' + windowId;
            return storageKey;
        };
        Storage.prototype._loadFromStorage = function () {
            var savedData = nativeMethods$1.storageGetItem.call(this.storage, this.storageKey);
            if (savedData) {
                this.data = JSON$1.parse(savedData);
                nativeMethods$1.storageRemoveItem.call(this.storage, this.storageKey);
            }
        };
        Storage.prototype.save = function () {
            nativeMethods$1.storageSetItem.call(this.storage, this.storageKey, JSON$1.stringify(this.data));
        };
        Storage.prototype.setItem = function (prop, value) {
            this.data[prop] = value;
            this.save();
        };
        Storage.prototype.getItem = function (prop) {
            return this.data[prop];
        };
        Storage.prototype.dispose = function () {
            nativeMethods$1.storageRemoveItem.call(this.storage, this.storageKey);
        };
        return Storage;
    }());

    // -------------------------------------------------------------
    // WARNING: this file is used by both the client and the server.
    // Do not use any browser or node-specific API!
    // -------------------------------------------------------------
    var Assignable = /** @class */ (function () {
        function Assignable() {
        }
        Assignable.prototype._getAssignableProperties = function () {
            throw new Error('Not implemented');
        };
        Assignable.prototype._assignFrom = function (obj, validate, initOptions) {
            if (initOptions === void 0) { initOptions = {}; }
            if (!obj)
                return;
            var props = this._getAssignableProperties();
            for (var i = 0; i < props.length; i++) {
                var _a = props[i], name_1 = _a.name, type = _a.type, required = _a.required, init = _a.init, defaultValue = _a.defaultValue;
                var path = name_1.split('.');
                var lastIdx = path.length - 1;
                var last = path[lastIdx];
                var srcObj = obj;
                var destObj = this;
                for (var j = 0; j < lastIdx && srcObj && destObj; j++) {
                    srcObj = srcObj[path[j]];
                    destObj = destObj[path[j]];
                }
                if (destObj && 'defaultValue' in props[i])
                    destObj[name_1] = defaultValue;
                if (srcObj && destObj) {
                    var srcVal = srcObj[last];
                    if (srcVal !== void 0 || required) {
                        if (validate && type)
                            type(name_1, srcVal);
                        destObj[last] = init ? init(name_1, srcVal, initOptions, validate) : srcVal;
                    }
                }
            }
        };
        return Assignable;
    }());

    var DriverStatus = /** @class */ (function (_super) {
        __extends(DriverStatus, _super);
        function DriverStatus(obj) {
            var _this = _super.call(this, obj) || this;
            _this.id = generateId();
            _this.isCommandResult = false;
            _this.executionError = null;
            _this.pageError = null;
            _this.resent = false;
            _this.result = null;
            _this.consoleMessages = null;
            _this.isPendingWindowSwitching = false;
            _this.isFirstRequestAfterWindowSwitching = false;
            _this.debug = '';
            _this._assignFrom(obj, true);
            return _this;
        }
        DriverStatus.prototype._getAssignableProperties = function () {
            return [
                { name: 'isCommandResult' },
                { name: 'executionError' },
                { name: 'pageError' },
                { name: 'result' },
                { name: 'consoleMessages' },
                { name: 'isPendingWindowSwitching' },
                { name: 'isFirstRequestAfterWindowSwitching' },
            ];
        };
        return DriverStatus;
    }(Assignable));

    var MIN_RESPONSE_WAITING_TIMEOUT = 2500;
    var RESEND_MESSAGE_INTERVAL = 1000;
    function sendMessageToDriver(msg, driverWindow, timeout, NotLoadedErrorCtor) {
        var sendMsgInterval = null;
        var sendMsgTimeout = null;
        var onResponse = null;
        timeout = Math.max(timeout || 0, MIN_RESPONSE_WAITING_TIMEOUT);
        var sendAndWaitForResponse = function () {
            return new hammerhead.Promise(function (resolve) {
                onResponse = function (e) {
                    if (e.message.type === TYPE.confirmation && e.message.requestMessageId === msg.id)
                        resolve(e.message);
                };
                hammerhead.eventSandbox.message.on(hammerhead.eventSandbox.message.SERVICE_MSG_RECEIVED_EVENT, onResponse);
                sendMsgInterval = hammerhead.nativeMethods.setInterval.call(window, function () { return hammerhead.eventSandbox.message.sendServiceMsg(msg, driverWindow); }, RESEND_MESSAGE_INTERVAL);
                hammerhead.eventSandbox.message.sendServiceMsg(msg, driverWindow);
            });
        };
        return hammerhead.Promise.race([testCafeCore.delay(timeout), sendAndWaitForResponse()])
            .then(function (response) {
            hammerhead.nativeMethods.clearInterval.call(window, sendMsgInterval);
            hammerhead.nativeMethods.clearTimeout.call(window, sendMsgTimeout);
            hammerhead.eventSandbox.message.off(hammerhead.eventSandbox.message.SERVICE_MSG_RECEIVED_EVENT, onResponse);
            if (!response)
                throw new NotLoadedErrorCtor();
            return response;
        });
    }

    var WAIT_FOR_WINDOW_DRIVER_RESPONSE_TIMEOUT = 20000;
    var WAIT_FOR_IFRAME_DRIVER_RESPONSE_TIMEOUT = 5000;
    var CHECK_IFRAME_EXISTENCE_INTERVAL = 1000;
    var CHECK_IFRAME_VISIBLE_INTERVAL = 200;
    var WAIT_IFRAME_RESPONSE_DELAY = 500;
    var CHECK_CHILD_WINDOW_CLOSED_INTERVAL = 200;

    function sendConfirmationMessage (_a) {
        var requestMsgId = _a.requestMsgId, result = _a.result, window = _a.window;
        var msg = new ConfirmationMessage(requestMsgId, result);
        hammerhead.eventSandbox.message.sendServiceMsg(msg, window);
    }

    var ChildIframeDriverLink = /** @class */ (function () {
        function ChildIframeDriverLink(driverWindow, driverId) {
            this.driverWindow = driverWindow;
            this.driverIframe = testCafeCore.domUtils.findIframeByWindow(driverWindow);
            this.driverId = driverId;
            this.iframeAvailabilityTimeout = 0;
        }
        Object.defineProperty(ChildIframeDriverLink.prototype, "availabilityTimeout", {
            set: function (val) {
                this.iframeAvailabilityTimeout = val;
            },
            enumerable: false,
            configurable: true
        });
        ChildIframeDriverLink.prototype._ensureIframe = function () {
            var _this = this;
            if (!testCafeCore.domUtils.isElementInDocument(this.driverIframe))
                return hammerhead.Promise.reject(new CurrentIframeNotFoundError());
            return testCafeCore.waitFor(function () { return testCafeCore.positionUtils.isElementVisible(_this.driverIframe) ? _this.driverIframe : null; }, CHECK_IFRAME_VISIBLE_INTERVAL, this.iframeAvailabilityTimeout)
                .catch(function () {
                throw new CurrentIframeIsInvisibleError();
            });
        };
        ChildIframeDriverLink.prototype._waitForIframeRemovedOrHidden = function () {
            var _this = this;
            // NOTE: If an iframe was removed or became hidden while a
            // command was being executed, we consider this command finished.
            return new hammerhead.Promise(function (resolve) {
                _this.checkIframeInterval = hammerhead.nativeMethods.setInterval.call(window, function () {
                    _this._ensureIframe()
                        .catch(function () {
                        // NOTE: wait for possible delayed iframe message
                        return testCafeCore.delay(WAIT_IFRAME_RESPONSE_DELAY)
                            .then(function () { return resolve(new DriverStatus({ isCommandResult: true })); });
                    });
                }, CHECK_IFRAME_EXISTENCE_INTERVAL);
            });
        };
        ChildIframeDriverLink.prototype._waitForCommandResult = function () {
            var _this = this;
            var onMessage = null;
            var waitForResultMessage = function () { return new hammerhead.Promise(function (resolve) {
                onMessage = function (e) {
                    if (e.message.type === TYPE.commandExecuted)
                        resolve(e.message.driverStatus);
                };
                hammerhead.eventSandbox.message.on(hammerhead.eventSandbox.message.SERVICE_MSG_RECEIVED_EVENT, onMessage);
            }); };
            return hammerhead.Promise.race([this._waitForIframeRemovedOrHidden(), waitForResultMessage()])
                .then(function (status) {
                hammerhead.eventSandbox.message.off(hammerhead.eventSandbox.message.SERVICE_MSG_RECEIVED_EVENT, onMessage);
                hammerhead.nativeMethods.clearInterval.call(window, _this.checkIframeInterval);
                return status;
            });
        };
        ChildIframeDriverLink.prototype.sendConfirmationMessage = function (requestMsgId) {
            sendConfirmationMessage({
                requestMsgId: requestMsgId,
                result: { id: this.driverId },
                window: this.driverWindow,
            });
        };
        ChildIframeDriverLink.prototype.executeCommand = function (command, testSpeed) {
            var _this = this;
            // NOTE:  We should check if the iframe is visible and exists before executing the next
            // command, because the iframe might be hidden or removed since the previous command.
            return this
                ._ensureIframe()
                .then(function () {
                var msg = new ExecuteCommandMessage(command, testSpeed);
                return hammerhead.Promise.all([
                    sendMessageToDriver(msg, _this.driverWindow, _this.iframeAvailabilityTimeout, CurrentIframeIsNotLoadedError),
                    _this._waitForCommandResult(),
                ]);
            })
                .then(function (result) { return result[1]; });
        };
        return ChildIframeDriverLink;
    }());

    // -------------------------------------------------------------
    // WARNING: this file is used by both the client and the server.
    // Do not use any browser or node-specific API!
    // -------------------------------------------------------------
    var NODE_SNAPSHOT_PROPERTIES = [
        'nodeType',
        'textContent',
        'childNodeCount',
        'hasChildNodes',
        'childElementCount',
        'hasChildElements',
    ];
    var ELEMENT_ACTION_SNAPSHOT_PROPERTIES = [
        'tagName',
        'attributes',
    ];
    var ELEMENT_SNAPSHOT_PROPERTIES = [
        'tagName',
        'visible',
        'focused',
        'attributes',
        'boundingClientRect',
        'classNames',
        'style',
        'innerText',
        'namespaceURI',
        'id',
        'value',
        'checked',
        'selected',
        'selectedIndex',
        'scrollWidth',
        'scrollHeight',
        'scrollLeft',
        'scrollTop',
        'offsetWidth',
        'offsetHeight',
        'offsetLeft',
        'offsetTop',
        'clientWidth',
        'clientHeight',
        'clientLeft',
        'clientTop',
    ];

    var nodeSnapshotPropertyInitializers = {
        // eslint-disable-next-line no-restricted-properties
        childNodeCount: function (node) { return node.childNodes.length; },
        hasChildNodes: function (node) { return !!nodeSnapshotPropertyInitializers.childNodeCount(node); },
        childElementCount: function (node) {
            var children = node.children;
            if (children)
                // eslint-disable-next-line no-restricted-properties
                return children.length;
            // NOTE: IE doesn't have `children` for non-element nodes =/
            var childElementCount = 0;
            // eslint-disable-next-line no-restricted-properties
            var childNodeCount = node.childNodes.length;
            for (var i = 0; i < childNodeCount; i++) {
                // eslint-disable-next-line no-restricted-properties
                if (node.childNodes[i].nodeType === 1)
                    childElementCount++;
            }
            return childElementCount;
        },
        // eslint-disable-next-line no-restricted-properties
        hasChildElements: function (node) { return !!nodeSnapshotPropertyInitializers.childElementCount(node); },
    };
    var BaseSnapshot = /** @class */ (function () {
        function BaseSnapshot() {
        }
        BaseSnapshot.prototype._initializeProperties = function (node, properties, initializers) {
            for (var _i = 0, properties_1 = properties; _i < properties_1.length; _i++) {
                var property = properties_1[_i];
                var initializer = initializers[property];
                this[property] = initializer ? initializer(node) : node[property];
            }
        };
        return BaseSnapshot;
    }());
    var NodeSnapshot = /** @class */ (function (_super) {
        __extends(NodeSnapshot, _super);
        function NodeSnapshot(node) {
            var _this = _super.call(this) || this;
            _this._initializeProperties(node, NODE_SNAPSHOT_PROPERTIES, nodeSnapshotPropertyInitializers);
            return _this;
        }
        return NodeSnapshot;
    }(BaseSnapshot));
    // Element
    var elementSnapshotPropertyInitializers = {
        tagName: function (element) { return element.tagName.toLowerCase(); },
        visible: function (element) { return adapter.isElementVisible(element); },
        focused: function (element) { return adapter.getActiveElement() === element; },
        attributes: function (element) {
            // eslint-disable-next-line no-restricted-properties
            var attrs = element.attributes;
            var result = {};
            for (var i = attrs.length - 1; i >= 0; i--)
                // eslint-disable-next-line no-restricted-properties
                result[attrs[i].name] = attrs[i].value;
            return result;
        },
        boundingClientRect: function (element) {
            var rect = element.getBoundingClientRect();
            return {
                left: rect.left,
                right: rect.right,
                top: rect.top,
                bottom: rect.bottom,
                width: rect.width,
                height: rect.height,
            };
        },
        classNames: function (element) {
            var className = element.className;
            if (typeof className.animVal === 'string')
                className = className.animVal;
            return className
                .replace(/^\s+|\s+$/g, '')
                .split(/\s+/g);
        },
        style: function (element) {
            var result = {};
            var computed = window.getComputedStyle(element);
            for (var i = 0; i < computed.length; i++) {
                var prop = computed[i];
                result[prop] = computed[prop];
            }
            return result;
        },
        // eslint-disable-next-line no-restricted-properties
        innerText: function (element) { return element.innerText; },
    };
    var ElementActionSnapshot = /** @class */ (function (_super) {
        __extends(ElementActionSnapshot, _super);
        function ElementActionSnapshot(element) {
            var _this = _super.call(this) || this;
            _this._initializeProperties(element, ELEMENT_ACTION_SNAPSHOT_PROPERTIES, elementSnapshotPropertyInitializers);
            return _this;
        }
        return ElementActionSnapshot;
    }(BaseSnapshot));
    var ElementSnapshot = /** @class */ (function (_super) {
        __extends(ElementSnapshot, _super);
        function ElementSnapshot(element) {
            var _this = _super.call(this, element) || this;
            _this._initializeProperties(element, ELEMENT_SNAPSHOT_PROPERTIES, elementSnapshotPropertyInitializers);
            return _this;
        }
        return ElementSnapshot;
    }(NodeSnapshot));

    var SelectorNodeTransform = /** @class */ (function () {
        function SelectorNodeTransform(customDOMProperties, instantiationCallsiteName) {
            if (customDOMProperties === void 0) { customDOMProperties = {}; }
            this.type = 'Node';
            this._customDOMProperties = customDOMProperties;
            this._instantiationCallsiteName = instantiationCallsiteName;
        }
        SelectorNodeTransform.prototype._extend = function (snapshot, node) {
            var props = adapter.nativeMethods.objectKeys(this._customDOMProperties);
            for (var _i = 0, props_1 = props; _i < props_1.length; _i++) {
                var prop = props_1[_i];
                try {
                    snapshot[prop] = this._customDOMProperties[prop](node);
                }
                catch (err) {
                    throw new UncaughtErrorInCustomDOMPropertyCode(this._instantiationCallsiteName, err, prop);
                }
            }
        };
        SelectorNodeTransform.prototype.shouldTransform = function (type, val) {
            return val instanceof adapter.nativeMethods.Node;
        };
        SelectorNodeTransform.prototype.toSerializable = function (node) {
            var snapshot = node.nodeType === 1 ? new ElementSnapshot(node) : new NodeSnapshot(node);
            this._extend(snapshot, node);
            return snapshot;
        };
        SelectorNodeTransform.prototype.fromSerializable = function () {
        };
        return SelectorNodeTransform;
    }());

    var SelectorElementActionTransform = /** @class */ (function () {
        function SelectorElementActionTransform() {
            this.type = 'Node';
        }
        SelectorElementActionTransform.prototype.shouldTransform = function (type, val) {
            return val instanceof adapter.nativeMethods.Node;
        };
        SelectorElementActionTransform.prototype.toSerializable = function (node) {
            return new ElementActionSnapshot(node);
        };
        SelectorElementActionTransform.prototype.fromSerializable = function () {
        };
        return SelectorElementActionTransform;
    }());

    var Promise = hammerhead__default.Promise;
    var nativeMethods$2 = hammerhead__default.nativeMethods;
    var WAIT_FOR_NEW_SCRIPTS_DELAY = 25;
    var ScriptExecutionBarrier = /** @class */ (function () {
        function ScriptExecutionBarrier() {
            var _this = this;
            this.watchdog = null;
            this.SCRIPT_LOADING_TIMEOUT = 2000;
            this.BARRIER_TIMEOUT = 3000;
            this.scriptsCount = 0;
            this.resolveWaitingPromise = null;
            this.scriptElementAddedHandler = function (e) { return _this._onScriptElementAdded(e.el); };
            hammerhead__default.on(hammerhead__default.EVENTS.scriptElementAdded, this.scriptElementAddedHandler);
        }
        ScriptExecutionBarrier.prototype._onScriptElementAdded = function (el) {
            var _this = this;
            var scriptSrc = nativeMethods$2.scriptSrcGetter.call(el);
            if (scriptSrc === void 0 || scriptSrc === '')
                return;
            this.scriptsCount++;
            var loadingTimeout = null;
            var done = function () {
                nativeMethods$2.removeEventListener.call(el, 'load', done);
                nativeMethods$2.removeEventListener.call(el, 'error', done);
                nativeMethods$2.clearTimeout.call(window, loadingTimeout);
                _this._onScriptLoadedOrFailed();
            };
            nativeMethods$2.addEventListener.call(el, 'load', done);
            nativeMethods$2.addEventListener.call(el, 'error', done);
            loadingTimeout = nativeMethods$2.setTimeout.call(window, done, this.SCRIPT_LOADING_TIMEOUT);
        };
        ScriptExecutionBarrier.prototype._onScriptLoadedOrFailed = function () {
            var _this = this;
            this.scriptsCount--;
            if (this.scriptsCount)
                return;
            testCafeCore.delay(WAIT_FOR_NEW_SCRIPTS_DELAY)
                .then(function () {
                if (!_this.resolveWaitingPromise)
                    return;
                if (!_this.scriptsCount)
                    _this.resolveWaitingPromise();
            });
        };
        ScriptExecutionBarrier.prototype.wait = function () {
            var _this = this;
            return new Promise(function (resolve) {
                var done = function () {
                    nativeMethods$2.clearTimeout.call(window, _this.watchdog);
                    hammerhead__default.off(hammerhead__default.EVENTS.scriptElementAdded, _this.scriptElementAddedHandler);
                    _this.watchdog = null;
                    _this.resolveWaitingPromise = null;
                    resolve();
                };
                if (!_this.scriptsCount)
                    done();
                else {
                    _this.watchdog = nativeMethods$2.setTimeout.call(window, function () { return done(); }, _this.BARRIER_TIMEOUT);
                    _this.resolveWaitingPromise = function () { return done(); };
                }
            });
        };
        return ScriptExecutionBarrier;
    }());

    function runWithBarriers (action) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var requestBarrier = new testCafeCore.RequestBarrier();
        var scriptExecutionBarrier = new ScriptExecutionBarrier();
        testCafeCore.pageUnloadBarrier.watchForPageNavigationTriggers();
        var actionResult = null;
        var actionPromise = action.apply(void 0, args);
        var barriersPromise = actionPromise
            .then(function (result) {
            actionResult = result;
            return hammerhead.Promise.all([
                // NOTE: script can be added by xhr-request, so we should run
                // script execution barrier waiting after request barrier resolved
                requestBarrier
                    .wait()
                    .then(function () { return scriptExecutionBarrier.wait(); }),
                testCafeCore.pageUnloadBarrier.wait(),
            ]);
        })
            .then(function () { return actionResult; });
        return { actionPromise: actionPromise, barriersPromise: barriersPromise };
    }

    var CHECK_ELEMENT_DELAY = 200;
    var SelectorExecutor = /** @class */ (function (_super) {
        __extends(SelectorExecutor, _super);
        function SelectorExecutor(command, globalTimeout, startTime, createNotFoundError, createIsInvisibleError) {
            var _this = _super.call(this, command) || this;
            _this.createNotFoundError = createNotFoundError;
            _this.createIsInvisibleError = createIsInvisibleError;
            _this.timeout = typeof command.timeout === 'number' ? command.timeout : globalTimeout;
            _this.counterMode = _this.dependencies.filterOptions.counterMode;
            _this.getVisibleValueMode = _this.dependencies.filterOptions.getVisibleValueMode;
            _this.dependencies.selectorFilter = selectorFilter;
            if (startTime) {
                var elapsed = adapter.nativeMethods.dateNow() - startTime;
                _this.timeout = Math.max(_this.timeout - elapsed, 0);
            }
            var customDOMProperties = _this.dependencies.customDOMProperties;
            _this.replicator.addTransforms([
                new SelectorNodeTransform(customDOMProperties, command.instantiationCallsiteName),
            ]);
            return _this;
        }
        SelectorExecutor.prototype._createReplicator = function () {
            return createReplicator([
                new FunctionTransform(),
            ]);
        };
        SelectorExecutor.prototype._getTimeoutErrorParams = function () {
            var apiFnIndex = selectorFilter.error;
            var apiFnChain = this.command.apiFnChain;
            return { apiFnIndex: apiFnIndex, apiFnChain: apiFnChain };
        };
        SelectorExecutor.prototype._getTimeoutError = function (elementExists) {
            return elementExists ? this.createIsInvisibleError : this.createNotFoundError;
        };
        SelectorExecutor.prototype._validateElement = function (args, startTime) {
            var _this = this;
            return adapter.PromiseCtor.resolve()
                .then(function () { return _super.prototype._executeFn.call(_this, args); })
                .then(function (el) {
                var element = el;
                var isElementExists = !!element;
                var isElementVisible = !_this.command.visibilityCheck || element && visible(element);
                var isTimeout = adapter.nativeMethods.dateNow() - startTime >= _this.timeout;
                if (isElementExists && (isElementVisible || adapter.isShadowRoot(element)))
                    return element;
                if (!isTimeout)
                    return adapter.delay(CHECK_ELEMENT_DELAY).then(function () { return _this._validateElement(args, startTime); });
                var createTimeoutError = _this.getVisibleValueMode ? null : _this._getTimeoutError(isElementExists);
                if (createTimeoutError)
                    throw createTimeoutError(_this._getTimeoutErrorParams());
                return null;
            });
        };
        SelectorExecutor.prototype._executeFn = function (args) {
            if (this.counterMode)
                return _super.prototype._executeFn.call(this, args);
            return this._validateElement(args, adapter.nativeMethods.dateNow());
        };
        return SelectorExecutor;
    }(ClientFunctionExecutor));

    var DateCtor = hammerhead.nativeMethods.date;
    var ElementsRetriever = /** @class */ (function () {
        function ElementsRetriever(elementDescriptors, globalSelectorTimeout) {
            var _this = this;
            this.elements = [];
            this.globalSelectorTimeout = globalSelectorTimeout;
            this.ensureElementsPromise = hammerhead.Promise.resolve();
            this.ensureElementsStartTime = new DateCtor();
            elementDescriptors.forEach(function (descriptor) { return _this._ensureElement(descriptor); });
        }
        ElementsRetriever.prototype._ensureElement = function (_a) {
            var _this = this;
            var selector = _a.selector, createNotFoundError = _a.createNotFoundError, createIsInvisibleError = _a.createIsInvisibleError, createHasWrongNodeTypeError = _a.createHasWrongNodeTypeError;
            this.ensureElementsPromise = this.ensureElementsPromise
                .then(function () {
                var selectorExecutor = new SelectorExecutor(selector, _this.globalSelectorTimeout, _this.ensureElementsStartTime, createNotFoundError, createIsInvisibleError);
                return selectorExecutor.getResult();
            })
                .then(function (el) {
                if (!testCafeCore.domUtils.isDomElement(el))
                    throw createHasWrongNodeTypeError(testCafeCore.NODE_TYPE_DESCRIPTIONS[el.nodeType]);
                _this.elements.push(el);
            });
        };
        ElementsRetriever.prototype.getElements = function () {
            var _this = this;
            return this.ensureElementsPromise
                .then(function () { return _this.elements; });
        };
        return ElementsRetriever;
    }());
    function ensureElements(elementDescriptors, globalSelectorTimeout) {
        var elementsRetriever = new ElementsRetriever(elementDescriptors, globalSelectorTimeout);
        return elementsRetriever.getElements();
    }
    function createElementDescriptor(selector) {
        return {
            selector: selector,
            createNotFoundError: function (fn) { return new ActionElementNotFoundError(fn); },
            createIsInvisibleError: function () { return new ActionElementIsInvisibleError(); },
            createHasWrongNodeTypeError: function (nodeDescription) { return new ActionSelectorMatchesWrongNodeTypeError(nodeDescription); },
        };
    }
    function createAdditionalElementDescriptor(selector, elementName) {
        return {
            selector: selector,
            createNotFoundError: function (fn) { return new ActionAdditionalElementNotFoundError(elementName, fn); },
            createIsInvisibleError: function () { return new ActionAdditionalElementIsInvisibleError(elementName); },
            createHasWrongNodeTypeError: function (nodeDescription) { return new ActionAdditionalSelectorMatchesWrongNodeTypeError(elementName, nodeDescription); },
        };
    }

    var browserUtils = hammerhead__default.utils.browser;
    function getAutomationPoint(element, offsetX, offsetY) {
        var roundFn = browserUtils.isFirefox ? Math.ceil : Math.round;
        var elementOffset = testCafeCore.positionUtils.getOffsetPosition(element, roundFn);
        var left = element === document.documentElement ? 0 : elementOffset.left;
        var top = element === document.documentElement ? 0 : elementOffset.top;
        return {
            x: left + offsetX,
            y: top + offsetY,
        };
    }

    function convertToClient(element, point) {
        var elementScroll = testCafeCore.styleUtils.getElementScroll(element);
        if (!/html/i.test(element.tagName) && testCafeCore.styleUtils.hasScroll(element)) {
            point.x -= elementScroll.left;
            point.y -= elementScroll.top;
        }
        return testCafeCore.positionUtils.offsetToClientCoords(point);
    }

    function getDevicePoint(clientPoint) {
        if (!clientPoint)
            return null;
        var screenLeft = window.screenLeft || window.screenX;
        var screenTop = window.screenTop || window.screenY;
        var x = screenLeft + clientPoint.x;
        var y = screenTop + clientPoint.y;
        return { x: x, y: y };
    }

    function calcOffset(size) {
        var offset = size / 2;
        return offset < 1 ? 0 : Math.round(offset);
    }
    function getDefaultAutomationOffsets(element) {
        var rect = testCafeCore.positionUtils.getElementRectangle(element);
        var offsetX = calcOffset(rect.width);
        var offsetY = calcOffset(rect.height);
        return { offsetX: offsetX, offsetY: offsetY };
    }
    function getOffsetOptions(element, offsetX, offsetY) {
        var defaultOffsets = getDefaultAutomationOffsets(element);
        offsetX = typeof offsetX === 'number' ? Math.round(offsetX) : defaultOffsets.offsetX;
        offsetY = typeof offsetY === 'number' ? Math.round(offsetY) : defaultOffsets.offsetY;
        if (offsetX > 0 && offsetY > 0)
            return { offsetX: offsetX, offsetY: offsetY };
        var dimensions = testCafeCore.positionUtils.getClientDimensions(element);
        var width = Math.round(Math.max(element.scrollWidth, dimensions.width));
        var height = Math.round(Math.max(element.scrollHeight, dimensions.height));
        var maxX = dimensions.scrollbar.right + dimensions.border.left + dimensions.border.right + width;
        var maxY = dimensions.scrollbar.bottom + dimensions.border.top + dimensions.border.bottom + height;
        return {
            offsetX: offsetX < 0 ? maxX + offsetX : offsetX,
            offsetY: offsetY < 0 ? maxY + offsetY : offsetY,
        };
    }

    function isIframeWindow(window) {
        return window.top !== window;
    }

    var domUtils = testCafeCore__default.domUtils;
    var cursorUI = !isIframeWindow(window) ? testCafeUI__default.cursorUI : testCafeUI__default.iframeCursorUI;
    // NOTE: the default position should be outside of the page (GH-794)
    var cursor = {
        x: -1,
        y: -1,
        currentActiveWindow: window.top,
        _ensureActiveWindow: function () {
            if (this.currentActiveWindow === window || this.currentActiveWindow === window.parent)
                return;
            var activeFrame = domUtils.findIframeByWindow(this.currentActiveWindow);
            if (!activeFrame || !domUtils.isElementInDocument(activeFrame))
                this.currentActiveWindow = window;
        },
        get active() {
            this._ensureActiveWindow();
            return this.currentActiveWindow === window;
        },
        set activeWindow(win) {
            this.currentActiveWindow = win;
        },
        get activeWindow() {
            this._ensureActiveWindow();
            return this.currentActiveWindow;
        },
        get position() {
            return { x: this.x, y: this.y };
        },
        get visible() {
            return !isIframeWindow(window) && cursorUI.isVisible();
        },
        move: function (newX, newY) {
            this.x = newX;
            this.y = newY;
            return cursorUI.move(this.x, this.y);
        },
        hide: function () {
            if (this.visible)
                cursorUI.hide();
        },
        show: function () {
            if (!isIframeWindow(window))
                cursorUI.show();
        },
        leftButtonDown: function () {
            return cursorUI.leftButtonDown();
        },
        rightButtonDown: function () {
            return cursorUI.rightButtonDown();
        },
        buttonUp: function () {
            return cursorUI.buttonUp();
        },
    };

    var browserUtils$1 = hammerhead__default.utils.browser;
    var Promise$1 = hammerhead__default.Promise;
    var nativeMethods$3 = hammerhead__default.nativeMethods;
    var positionUtils = testCafeCore__default.positionUtils;
    var domUtils$1 = testCafeCore__default.domUtils;
    function getElementFromPoint(x, y, underTopShadowUIElement) {
        var topElement = null;
        return testCafeUI__default.hide(underTopShadowUIElement)
            .then(function () {
            topElement = positionUtils.getElementFromPoint(x, y);
            return testCafeUI__default.show(underTopShadowUIElement);
        })
            .then(function () { return topElement; });
    }
    function ensureImageMap(imgElement, areaElement) {
        var mapElement = domUtils$1.closest(areaElement, 'map');
        return mapElement && mapElement.name === imgElement.useMap.substring(1) ? areaElement : imgElement;
    }
    function findElementOrNonEmptyChildFromPoint(x, y, element) {
        var topElement = positionUtils.getElementFromPoint(x, y);
        var isNonEmptyChild = domUtils$1.containsElement(element, topElement) &&
            nativeMethods$3.nodeTextContentGetter.call(topElement).length;
        if (topElement && topElement === element || isNonEmptyChild)
            return topElement;
        return null;
    }
    function correctTopElementByExpectedElement(topElement, expectedElement) {
        var expectedElementDefined = expectedElement && domUtils$1.isDomElement(expectedElement);
        if (!expectedElementDefined || !topElement || topElement === expectedElement)
            return topElement;
        var isTREFElement = domUtils$1.getTagName(expectedElement) === 'tref';
        // NOTE: 'document.elementFromPoint' can't find these types of elements
        if (isTREFElement)
            return expectedElement;
        // NOTE: T299665 - Incorrect click automation for images with an associated map element in Firefox
        // All browsers return the <area> element from document.getElementFromPoint, but
        // Firefox returns the <img> element. We should accomplish this for Firefox as well.
        var isImageMapArea = domUtils$1.getTagName(expectedElement) === 'area' && domUtils$1.isImgElement(topElement);
        if (browserUtils$1.isFirefox && isImageMapArea)
            return ensureImageMap(topElement, expectedElement);
        // NOTE: try to find a multi-line link by its rectangle (T163678)
        var isLinkOrChildExpected = domUtils$1.isAnchorElement(expectedElement) ||
            domUtils$1.getParents(expectedElement, 'a').length;
        var isTopElementChildOfLink = isLinkOrChildExpected &&
            domUtils$1.containsElement(expectedElement, topElement) &&
            nativeMethods$3.nodeTextContentGetter.call(topElement).length;
        var shouldSearchForMultilineLink = isLinkOrChildExpected && !isTopElementChildOfLink &&
            nativeMethods$3.nodeTextContentGetter.call(expectedElement).length;
        if (!shouldSearchForMultilineLink)
            return topElement;
        var linkRect = expectedElement.getBoundingClientRect();
        return findElementOrNonEmptyChildFromPoint(linkRect.right - 1, linkRect.top + 1, expectedElement) ||
            findElementOrNonEmptyChildFromPoint(linkRect.left + 1, linkRect.bottom - 1, expectedElement) ||
            topElement;
    }
    function fromPoint(x, y, expectedElement) {
        var foundElement = null;
        return getElementFromPoint(x, y)
            .then(function (topElement) {
            foundElement = topElement;
            // NOTE: when trying to get an element by elementFromPoint in iframe and the target
            // element is under any of shadow-ui elements, you will get null (only in IE).
            // In this case, you should hide a top window's shadow-ui root to obtain an element.
            var resChain = Promise$1.resolve(topElement);
            if (!foundElement && isIframeWindow(window) && x > 0 && y > 0) {
                resChain = resChain
                    .then(function () { return getElementFromPoint(x, y, true); })
                    .then(function (element) {
                    foundElement = element;
                    return element;
                });
            }
            return resChain
                .then(function (element) { return correctTopElementByExpectedElement(element, expectedElement); })
                .then(function (correctedElement) {
                return { element: correctedElement, corrected: correctedElement !== foundElement };
            });
        });
    }
    function underCursor() {
        var cursorPosition = cursor.position;
        return fromPoint(cursorPosition.x, cursorPosition.y).then(function (_a) {
            var element = _a.element;
            return element;
        });
    }

    var AUTOMATION_ERROR_TYPES = {
        elementIsInvisibleError: 'elementIsInvisibleError',
        foundElementIsNotTarget: 'foundElementIsNotTarget',
    };

    var ACTION_STEP_DELAY_DEFAULT = 10;
    var MAX_MOUSE_ACTION_STEP_DELAY = 400;
    var MAX_KEY_ACTION_STEP_DELAY = 200;
    // We use an exponential function to calculate the cursor
    // speed according to general test speed
    // cursorSpeed = (maxSpeed * k) ^ speed / k
    var MAX_CURSOR_SPEED = 100; // pixels/ms
    var MAX_DRAGGING_SPEED = 4; // pixels/ms
    var CURSOR_FACTOR = 4;
    var AutomationSettings = /** @class */ (function () {
        function AutomationSettings(speed) {
            this.speedFactor = speed || 1;
        }
        Object.defineProperty(AutomationSettings.prototype, "mouseActionStepDelay", {
            get: function () {
                return this.speedFactor === 1 ? ACTION_STEP_DELAY_DEFAULT : (1 - this.speedFactor) * MAX_MOUSE_ACTION_STEP_DELAY;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AutomationSettings.prototype, "keyActionStepDelay", {
            get: function () {
                return this.speedFactor === 1 ? ACTION_STEP_DELAY_DEFAULT : (1 - this.speedFactor) * MAX_KEY_ACTION_STEP_DELAY;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AutomationSettings.prototype, "cursorSpeed", {
            get: function () {
                return Math.pow(MAX_CURSOR_SPEED * CURSOR_FACTOR, this.speedFactor) / CURSOR_FACTOR;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AutomationSettings.prototype, "draggingSpeed", {
            get: function () {
                return Math.pow(MAX_DRAGGING_SPEED * CURSOR_FACTOR, this.speedFactor) / CURSOR_FACTOR;
            },
            enumerable: false,
            configurable: true
        });
        return AutomationSettings;
    }());

    var Promise$2 = hammerhead__default.Promise;
    var messageSandbox$1 = hammerhead__default.eventSandbox.message;
    var DEFAULT_MAX_SCROLL_MARGIN = 50;
    var SCROLL_MARGIN_INCREASE_STEP = 20;
    var SCROLL_REQUEST_CMD = 'automation|scroll|request';
    var SCROLL_RESPONSE_CMD = 'automation|scroll|response';
    // Setup cross-iframe interaction
    messageSandbox$1.on(messageSandbox$1.SERVICE_MSG_RECEIVED_EVENT, function (e) {
        if (e.message.cmd === SCROLL_REQUEST_CMD) {
            var _a = e.message, offsetX = _a.offsetX, offsetY = _a.offsetY, maxScrollMargin = _a.maxScrollMargin;
            var element = testCafeCore.domUtils.findIframeByWindow(e.source);
            var scroll_1 = new ScrollAutomation(element, { offsetX: offsetX, offsetY: offsetY });
            scroll_1.maxScrollMargin = maxScrollMargin;
            scroll_1
                .run()
                .then(function () { return messageSandbox$1.sendServiceMsg({ cmd: SCROLL_RESPONSE_CMD }, e.source); });
        }
    });
    var ScrollAutomation = /** @class */ (function () {
        function ScrollAutomation(element, scrollOptions) {
            this.element = element;
            this.offsetX = scrollOptions.offsetX;
            this.offsetY = scrollOptions.offsetY;
            this.scrollToCenter = scrollOptions.scrollToCenter;
            this.skipParentFrames = scrollOptions.skipParentFrames;
            this.raiseEvents = scrollOptions.raiseEvents;
            this.maxScrollMargin = { left: DEFAULT_MAX_SCROLL_MARGIN, top: DEFAULT_MAX_SCROLL_MARGIN };
            this.scrollWasPerformed = false;
        }
        ScrollAutomation.prototype._isScrollValuesChanged = function (scrollElement, originalScroll) {
            return testCafeCore.styleUtils.getScrollLeft(scrollElement) !== originalScroll.left
                || testCafeCore.styleUtils.getScrollTop(scrollElement) !== originalScroll.top;
        };
        ScrollAutomation.prototype._setScroll = function (element, _a) {
            var _this = this;
            var left = _a.left, top = _a.top;
            var scrollElement = testCafeCore.domUtils.isHtmlElement(element) ? testCafeCore.domUtils.findDocument(element) : element;
            var originalScroll = {
                left: testCafeCore.styleUtils.getScrollLeft(scrollElement),
                top: testCafeCore.styleUtils.getScrollTop(scrollElement),
            };
            left = Math.max(left, 0);
            top = Math.max(top, 0);
            var scrollPromise = testCafeCore.scrollController.waitForScroll(scrollElement);
            testCafeCore.styleUtils.setScrollLeft(scrollElement, left);
            testCafeCore.styleUtils.setScrollTop(scrollElement, top);
            if (!this._isScrollValuesChanged(scrollElement, originalScroll)) {
                scrollPromise.cancel();
                return Promise$2.resolve();
            }
            scrollPromise = scrollPromise.then(function () {
                _this.scrollWasPerformed = _this.scrollWasPerformed || _this._isScrollValuesChanged(scrollElement, originalScroll);
            });
            return scrollPromise;
        };
        ScrollAutomation.prototype._getScrollToPoint = function (elementDimensions, _a, maxScrollMargin) {
            var x = _a.x, y = _a.y;
            var horizontalCenter = Math.floor(elementDimensions.width / 2);
            var verticalCenter = Math.floor(Math.floor(elementDimensions.height / 2));
            var leftScrollMargin = this.scrollToCenter ? horizontalCenter : Math.min(maxScrollMargin.left, horizontalCenter);
            var topScrollMargin = this.scrollToCenter ? verticalCenter : Math.min(maxScrollMargin.top, verticalCenter);
            var needForwardScrollLeft = x >= elementDimensions.scroll.left + elementDimensions.width - leftScrollMargin;
            var needBackwardScrollLeft = x <= elementDimensions.scroll.left + leftScrollMargin;
            var needForwardScrollTop = y >= elementDimensions.scroll.top + elementDimensions.height - topScrollMargin;
            var needBackwardScrollTop = y <= elementDimensions.scroll.top + topScrollMargin;
            var left = elementDimensions.scroll.left;
            var top = elementDimensions.scroll.top;
            if (needForwardScrollLeft)
                left = x - elementDimensions.width + leftScrollMargin;
            else if (needBackwardScrollLeft)
                left = x - leftScrollMargin;
            if (needForwardScrollTop)
                top = y - elementDimensions.height + topScrollMargin;
            else if (needBackwardScrollTop)
                top = y - topScrollMargin;
            return { left: left, top: top };
        };
        ScrollAutomation.prototype._getScrollToFullChildView = function (parentDimensions, childDimensions, maxScrollMargin) {
            var fullViewScrollLeft = null;
            var fullViewScrollTop = null;
            var canShowFullElementWidth = parentDimensions.width >= childDimensions.width;
            var canShowFullElementHeight = parentDimensions.height >= childDimensions.height;
            var relativePosition = testCafeCore.positionUtils.calcRelativePosition(childDimensions, parentDimensions);
            if (canShowFullElementWidth) {
                var availableLeftScrollMargin = parentDimensions.width - childDimensions.width;
                var leftScrollMargin = Math.min(maxScrollMargin.left, availableLeftScrollMargin);
                if (this.scrollToCenter)
                    leftScrollMargin = availableLeftScrollMargin / 2;
                if (relativePosition.left < leftScrollMargin) {
                    fullViewScrollLeft = Math.round(parentDimensions.scroll.left + relativePosition.left -
                        leftScrollMargin);
                }
                else if (relativePosition.right < leftScrollMargin) {
                    fullViewScrollLeft = Math.round(parentDimensions.scroll.left +
                        Math.min(relativePosition.left, -relativePosition.right) +
                        leftScrollMargin);
                }
            }
            if (canShowFullElementHeight) {
                var availableTopScrollMargin = parentDimensions.height - childDimensions.height;
                var topScrollMargin = Math.min(maxScrollMargin.top, availableTopScrollMargin);
                if (this.scrollToCenter)
                    topScrollMargin = availableTopScrollMargin / 2;
                if (relativePosition.top < topScrollMargin)
                    fullViewScrollTop = Math.round(parentDimensions.scroll.top + relativePosition.top - topScrollMargin);
                else if (relativePosition.bottom < topScrollMargin) {
                    fullViewScrollTop = Math.round(parentDimensions.scroll.top +
                        Math.min(relativePosition.top, -relativePosition.bottom) +
                        topScrollMargin);
                }
            }
            return {
                left: fullViewScrollLeft,
                top: fullViewScrollTop,
            };
        };
        ScrollAutomation._getChildPoint = function (parentDimensions, childDimensions, offsets) {
            return {
                x: childDimensions.left - parentDimensions.left + parentDimensions.scroll.left +
                    childDimensions.border.left + offsets.x,
                y: childDimensions.top - parentDimensions.top + parentDimensions.scroll.top +
                    childDimensions.border.top + offsets.y,
            };
        };
        ScrollAutomation.prototype._getScrollPosition = function (parentDimensions, childDimensions, offsets, maxScrollMargin) {
            var childPoint = ScrollAutomation._getChildPoint(parentDimensions, childDimensions, offsets);
            var scrollToPoint = this._getScrollToPoint(parentDimensions, childPoint, maxScrollMargin);
            var scrollToFullView = this._getScrollToFullChildView(parentDimensions, childDimensions, maxScrollMargin);
            var left = Math.max(scrollToFullView.left === null ? scrollToPoint.left : scrollToFullView.left, 0);
            var top = Math.max(scrollToFullView.top === null ? scrollToPoint.top : scrollToFullView.top, 0);
            return { left: left, top: top };
        };
        ScrollAutomation._getChildPointAfterScroll = function (parentDimensions, childDimensions, currentScroll, offsets) {
            var x = Math.round(childDimensions.left + parentDimensions.scroll.left - currentScroll.left + offsets.x);
            var y = Math.round(childDimensions.top + parentDimensions.scroll.top - currentScroll.top + offsets.y);
            return { x: x, y: y };
        };
        ScrollAutomation.prototype._isChildFullyVisible = function (parentDimensions, childDimensions, offsets) {
            var _a = ScrollAutomation._getChildPointAfterScroll(parentDimensions, childDimensions, parentDimensions.scroll, offsets), x = _a.x, y = _a.y;
            var zeroMargin = { left: 0, top: 0 };
            var _b = this._getScrollPosition(parentDimensions, childDimensions, offsets, zeroMargin), left = _b.left, top = _b.top;
            return !this._isTargetElementObscuredInPoint(x, y) &&
                left === parentDimensions.scroll.left && top === parentDimensions.scroll.top;
        };
        ScrollAutomation.prototype._scrollToChild = function (parent, child, offsets) {
            var parentDimensions = testCafeCore.positionUtils.getClientDimensions(parent);
            var childDimensions = testCafeCore.positionUtils.getClientDimensions(child);
            var windowWidth = testCafeCore.styleUtils.getInnerWidth(window);
            var windowHeight = testCafeCore.styleUtils.getInnerHeight(window);
            var scrollPos = parentDimensions.scroll;
            var needScroll = !this._isChildFullyVisible(parentDimensions, childDimensions, offsets);
            while (needScroll) {
                scrollPos = this._getScrollPosition(parentDimensions, childDimensions, offsets, this.maxScrollMargin);
                var _a = ScrollAutomation._getChildPointAfterScroll(parentDimensions, childDimensions, scrollPos, offsets), x = _a.x, y = _a.y;
                var isTargetObscured = this._isTargetElementObscuredInPoint(x, y);
                this.maxScrollMargin.left += SCROLL_MARGIN_INCREASE_STEP;
                if (this.maxScrollMargin.left >= windowWidth) {
                    this.maxScrollMargin.left = DEFAULT_MAX_SCROLL_MARGIN;
                    this.maxScrollMargin.top += SCROLL_MARGIN_INCREASE_STEP;
                }
                needScroll = isTargetObscured && this.maxScrollMargin.top < windowHeight;
            }
            this.maxScrollMargin = { left: DEFAULT_MAX_SCROLL_MARGIN, top: DEFAULT_MAX_SCROLL_MARGIN };
            return this._setScroll(parent, scrollPos);
        };
        ScrollAutomation.prototype._scrollElement = function () {
            if (!testCafeCore.styleUtils.hasScroll(this.element))
                return Promise$2.resolve();
            var elementDimensions = testCafeCore.positionUtils.getClientDimensions(this.element);
            var scroll = this._getScrollToPoint(elementDimensions, { x: this.offsetX, y: this.offsetY }, this.maxScrollMargin);
            return this._setScroll(this.element, scroll);
        };
        ScrollAutomation.prototype._scrollParents = function () {
            var _this = this;
            var parents = testCafeCore.styleUtils.getScrollableParents(this.element);
            var currentChild = this.element;
            var currentOffsetX = this.offsetX - Math.round(testCafeCore.styleUtils.getScrollLeft(currentChild));
            var currentOffsetY = this.offsetY - Math.round(testCafeCore.styleUtils.getScrollTop(currentChild));
            var childDimensions = null;
            var parentDimensions = null;
            var scrollParentsPromise = testCafeCore.promiseUtils.times(parents.length, function (i) {
                return _this
                    ._scrollToChild(parents[i], currentChild, { x: currentOffsetX, y: currentOffsetY })
                    .then(function () {
                    childDimensions = testCafeCore.positionUtils.getClientDimensions(currentChild);
                    parentDimensions = testCafeCore.positionUtils.getClientDimensions(parents[i]);
                    currentOffsetX += childDimensions.left - parentDimensions.left + parentDimensions.border.left;
                    currentOffsetY += childDimensions.top - parentDimensions.top + parentDimensions.border.top;
                    currentChild = parents[i];
                });
            });
            return scrollParentsPromise
                .then(function () {
                if (isIframeWindow(window) && !_this.skipParentFrames) {
                    return testCafeCore.sendRequestToFrame({
                        cmd: SCROLL_REQUEST_CMD,
                        offsetX: currentOffsetX,
                        offsetY: currentOffsetY,
                        maxScrollMargin: _this.maxScrollMargin,
                    }, SCROLL_RESPONSE_CMD, window.parent);
                }
                return Promise$2.resolve();
            });
        };
        ScrollAutomation._getFixedAncestorOrSelf = function (element) {
            return testCafeCore.domUtils.findParent(element, true, testCafeCore.styleUtils.isFixedElement);
        };
        ScrollAutomation.prototype._isTargetElementObscuredInPoint = function (x, y) {
            var elementInPoint = testCafeCore.positionUtils.getElementFromPoint(x, y);
            if (!elementInPoint)
                return false;
            var fixedElement = ScrollAutomation._getFixedAncestorOrSelf(elementInPoint);
            return fixedElement && !fixedElement.contains(this.element);
        };
        ScrollAutomation.prototype.run = function () {
            var _this = this;
            return this
                ._scrollElement()
                .then(function () { return _this._scrollParents(); })
                .then(function () { return _this.scrollWasPerformed; });
        };
        return ScrollAutomation;
    }());

    // -------------------------------------------------------------
    // WARNING: this file is used by both the client and the server.
    // Do not use any browser or node-specific API!
    // -------------------------------------------------------------
    function createIntegerValidator(ErrorCtor) {
        return function (name, val) {
            var valType = typeof val;
            if (valType !== 'number')
                throw new ErrorCtor(name, valType);
            var isInteger = !isNaN(val) &&
                isFinite(val) &&
                val === Math.floor(val);
            if (!isInteger)
                throw new ErrorCtor(name, val);
        };
    }
    function createPositiveIntegerValidator(ErrorCtor) {
        var integerValidator = createIntegerValidator(ErrorCtor);
        return function (name, val) {
            integerValidator(name, val);
            if (val < 0)
                throw new ErrorCtor(name, val);
        };
    }
    function createBooleanValidator(ErrorCtor) {
        return function (name, val) {
            var valType = typeof val;
            if (valType !== 'boolean')
                throw new ErrorCtor(name, valType);
        };
    }
    function createSpeedValidator(ErrorCtor) {
        return function (name, val) {
            var valType = typeof val;
            if (valType !== 'number')
                throw new ErrorCtor(name, valType);
            if (isNaN(val) || val < 0.01 || val > 1)
                throw new ErrorCtor(name, val);
        };
    }

    // -------------------------------------------------------------
    var integerOption = createIntegerValidator(ActionIntegerOptionError);
    var positiveIntegerOption = createPositiveIntegerValidator(ActionPositiveIntegerOptionError);
    var booleanOption = createBooleanValidator(ActionBooleanOptionError);
    var speedOption = createSpeedValidator(ActionSpeedOptionError);
    // Actions
    var ActionOptions = /** @class */ (function (_super) {
        __extends(ActionOptions, _super);
        function ActionOptions(obj, validate) {
            var _this = _super.call(this) || this;
            _this.speed = null;
            _this._assignFrom(obj, validate);
            return _this;
        }
        ActionOptions.prototype._getAssignableProperties = function () {
            return [
                { name: 'speed', type: speedOption },
            ];
        };
        return ActionOptions;
    }(Assignable));
    // Offset
    var OffsetOptions = /** @class */ (function (_super) {
        __extends(OffsetOptions, _super);
        function OffsetOptions(obj, validate) {
            var _this = _super.call(this) || this;
            _this.offsetX = null;
            _this.offsetY = null;
            _this._assignFrom(obj, validate);
            return _this;
        }
        OffsetOptions.prototype._getAssignableProperties = function () {
            return _super.prototype._getAssignableProperties.call(this).concat([
                { name: 'offsetX', type: integerOption },
                { name: 'offsetY', type: integerOption },
            ]);
        };
        return OffsetOptions;
    }(ActionOptions));
    var ScrollOptions = /** @class */ (function (_super) {
        __extends(ScrollOptions, _super);
        function ScrollOptions(obj, validate) {
            var _this = _super.call(this) || this;
            _this.scrollToCenter = false;
            _this.skipParentFrames = false;
            _this._assignFrom(obj, validate);
            return _this;
        }
        ScrollOptions.prototype._getAssignableProperties = function () {
            return _super.prototype._getAssignableProperties.call(this).concat([
                { name: 'scrollToCenter', type: booleanOption },
                { name: 'skipParentFrames', type: booleanOption },
            ]);
        };
        return ScrollOptions;
    }(OffsetOptions));
    // Element Screenshot
    var ElementScreenshotOptions = /** @class */ (function (_super) {
        __extends(ElementScreenshotOptions, _super);
        function ElementScreenshotOptions(obj, validate) {
            var _this = _super.call(this) || this;
            _this.scrollTargetX = null;
            _this.scrollTargetY = null;
            _this.includeMargins = false;
            _this.includeBorders = true;
            _this.includePaddings = true;
            _this.crop = {
                left: null,
                right: null,
                top: null,
                bottom: null,
            };
            _this._assignFrom(obj, validate);
            return _this;
        }
        ElementScreenshotOptions.prototype._getAssignableProperties = function () {
            return _super.prototype._getAssignableProperties.call(this).concat([
                { name: 'scrollTargetX', type: integerOption },
                { name: 'scrollTargetY', type: integerOption },
                { name: 'crop.left', type: integerOption },
                { name: 'crop.right', type: integerOption },
                { name: 'crop.top', type: integerOption },
                { name: 'crop.bottom', type: integerOption },
                { name: 'includeMargins', type: booleanOption },
                { name: 'includeBorders', type: booleanOption },
                { name: 'includePaddings', type: booleanOption },
            ]);
        };
        return ElementScreenshotOptions;
    }(ActionOptions));
    // Mouse
    var MouseOptions = /** @class */ (function (_super) {
        __extends(MouseOptions, _super);
        function MouseOptions(obj, validate) {
            var _this = _super.call(this) || this;
            _this.modifiers = {
                ctrl: false,
                alt: false,
                shift: false,
                meta: false,
            };
            _this._assignFrom(obj, validate);
            return _this;
        }
        MouseOptions.prototype._getAssignableProperties = function () {
            return _super.prototype._getAssignableProperties.call(this).concat([
                { name: 'modifiers.ctrl', type: booleanOption },
                { name: 'modifiers.alt', type: booleanOption },
                { name: 'modifiers.shift', type: booleanOption },
                { name: 'modifiers.meta', type: booleanOption },
            ]);
        };
        return MouseOptions;
    }(OffsetOptions));
    // Click
    var ClickOptions = /** @class */ (function (_super) {
        __extends(ClickOptions, _super);
        function ClickOptions(obj, validate) {
            var _this = _super.call(this) || this;
            _this.caretPos = null;
            _this._assignFrom(obj, validate);
            return _this;
        }
        ClickOptions.prototype._getAssignableProperties = function () {
            return _super.prototype._getAssignableProperties.call(this).concat([
                { name: 'caretPos', type: positiveIntegerOption },
            ]);
        };
        return ClickOptions;
    }(MouseOptions));
    // Move
    var MoveOptions = /** @class */ (function (_super) {
        __extends(MoveOptions, _super);
        function MoveOptions(obj, validate) {
            var _this = _super.call(this) || this;
            _this.speed = null;
            _this.minMovingTime = null;
            _this.holdLeftButton = false;
            _this.skipScrolling = false;
            _this.skipDefaultDragBehavior = false;
            _this._assignFrom(obj, validate);
            return _this;
        }
        MoveOptions.prototype._getAssignableProperties = function () {
            return _super.prototype._getAssignableProperties.call(this).concat([
                { name: 'speed' },
                { name: 'minMovingTime' },
                { name: 'holdLeftButton' },
                { name: 'skipScrolling', type: booleanOption },
                { name: 'skipDefaultDragBehavior', type: booleanOption },
            ]);
        };
        return MoveOptions;
    }(MouseOptions));
    // Type
    var TypeOptions = /** @class */ (function (_super) {
        __extends(TypeOptions, _super);
        function TypeOptions(obj, validate) {
            var _this = _super.call(this) || this;
            _this.replace = false;
            _this.paste = false;
            _this.confidential = void 0;
            _this._assignFrom(obj, validate);
            return _this;
        }
        TypeOptions.prototype._getAssignableProperties = function () {
            return _super.prototype._getAssignableProperties.call(this).concat([
                { name: 'replace', type: booleanOption },
                { name: 'paste', type: booleanOption },
                { name: 'confidential', type: booleanOption },
            ]);
        };
        return TypeOptions;
    }(ClickOptions));
    // DragToElement
    var DragToElementOptions = /** @class */ (function (_super) {
        __extends(DragToElementOptions, _super);
        function DragToElementOptions(obj, validate) {
            var _this = _super.call(this, obj, validate) || this;
            _this.destinationOffsetX = null;
            _this.destinationOffsetY = null;
            _this._assignFrom(obj, validate);
            return _this;
        }
        DragToElementOptions.prototype._getAssignableProperties = function () {
            return _super.prototype._getAssignableProperties.call(this).concat([
                { name: 'destinationOffsetX', type: integerOption },
                { name: 'destinationOffsetY', type: integerOption },
            ]);
        };
        return DragToElementOptions;
    }(MouseOptions));
    //ResizeToFitDevice
    var ResizeToFitDeviceOptions = /** @class */ (function (_super) {
        __extends(ResizeToFitDeviceOptions, _super);
        function ResizeToFitDeviceOptions(obj, validate) {
            var _this = _super.call(this) || this;
            _this.portraitOrientation = false;
            _this._assignFrom(obj, validate);
            return _this;
        }
        ResizeToFitDeviceOptions.prototype._getAssignableProperties = function () {
            return [
                { name: 'portraitOrientation', type: booleanOption },
            ];
        };
        return ResizeToFitDeviceOptions;
    }(Assignable));
    //Assertion
    var AssertionOptions = /** @class */ (function (_super) {
        __extends(AssertionOptions, _super);
        function AssertionOptions(obj, validate) {
            var _this = _super.call(this) || this;
            _this.timeout = void 0;
            _this.allowUnawaitedPromise = false;
            _this._assignFrom(obj, validate);
            return _this;
        }
        AssertionOptions.prototype._getAssignableProperties = function () {
            return [
                { name: 'timeout', type: positiveIntegerOption },
                { name: 'allowUnawaitedPromise', type: booleanOption },
            ];
        };
        return AssertionOptions;
    }(Assignable));
    // Press
    var PressOptions = /** @class */ (function (_super) {
        __extends(PressOptions, _super);
        function PressOptions(obj, validate) {
            var _this = _super.call(this) || this;
            _this.confidential = void 0;
            _this._assignFrom(obj, validate);
            return _this;
        }
        PressOptions.prototype._getAssignableProperties = function () {
            return _super.prototype._getAssignableProperties.call(this).concat([
                { name: 'confidential', type: booleanOption },
            ]);
        };
        return PressOptions;
    }(ActionOptions));

    function getPointsDistance(start, end) {
        return Math.sqrt(Math.pow(end.x - start.x, 2) + Math.pow(end.y - start.y, 2));
    }
    function findLineAndRectSideIntersection(startLinePoint, endLinePoint, rectSide) {
        var intersectionX = null;
        var haveIntersectionInBounds = null;
        if (rectSide.isHorizontal) {
            intersectionX = testCafeCore.positionUtils.getLineXByYCoord(startLinePoint, endLinePoint, rectSide.y1);
            haveIntersectionInBounds = intersectionX && intersectionX >= rectSide.x1 && intersectionX <= rectSide.x2;
            return haveIntersectionInBounds ? { x: intersectionX, y: rectSide.y1 } : null;
        }
        var intersectionY = testCafeCore.positionUtils.getLineYByXCoord(startLinePoint, endLinePoint, rectSide.x1);
        haveIntersectionInBounds = intersectionY && intersectionY >= rectSide.y1 && intersectionY <= rectSide.y2;
        return haveIntersectionInBounds ? { x: rectSide.x1, y: intersectionY } : null;
    }
    function getLineRectIntersection (startLinePoint, endLinePoint, rect) {
        var res = [];
        var intersection = null;
        var rectLines = [
            { x1: rect.left, y1: rect.top, x2: rect.left, y2: rect.bottom, isHorizontal: false },
            { x1: rect.right, y1: rect.top, x2: rect.right, y2: rect.bottom, isHorizontal: false },
            { x1: rect.left, y1: rect.top, x2: rect.right, y2: rect.top, isHorizontal: true },
            { x1: rect.left, y1: rect.bottom, x2: rect.right, y2: rect.bottom, isHorizontal: true },
        ];
        for (var i = 0; i < rectLines.length; i++) {
            intersection = findLineAndRectSideIntersection(startLinePoint, endLinePoint, rectLines[i]);
            if (intersection)
                res.push(intersection);
        }
        if (!res.length)
            return null;
        if (res.length === 1)
            return res[0];
        // NOTE: if a line and rect have two intersection points, we return the nearest to startLinePoint
        return getPointsDistance(startLinePoint, res[0]) < getPointsDistance(startLinePoint, res[1]) ? res[0] : res[1];
    }

    var Promise$3 = hammerhead__default.Promise;
    var nativeMethods$4 = hammerhead__default.nativeMethods;
    function nextTick () {
        return new Promise$3(function (resolve) { return nativeMethods$4.setTimeout.call(window, resolve, 0); });
    }

    var DragAndDropState = /** @class */ (function () {
        function DragAndDropState() {
            this.enabled = false;
            this.dropAllowed = false;
            this.element = null;
            this.dataTransfer = null;
            this.dataStore = null;
        }
        return DragAndDropState;
    }());

    var browserUtils$2 = hammerhead__default.utils.browser;
    var MoveEventSequenceBase = /** @class */ (function () {
        function MoveEventSequenceBase(_a) {
            var moveEvent = _a.moveEvent;
            this.dragAndDropMode = false;
            this.dropAllowed = false;
            this.moveEvent = moveEvent;
        }
        MoveEventSequenceBase.prototype.setup = function () {
            this.dragAndDropMode = false;
            this.dropAllowed = false;
        };
        MoveEventSequenceBase.prototype.leaveElement = function ( /* currentElement, prevElement, commonAncestor, options */) {
        };
        MoveEventSequenceBase.prototype.move = function ( /* element, options */) {
        };
        MoveEventSequenceBase.prototype.enterElement = function ( /* currentElement, prevElement, commonAncestor, options */) {
        };
        MoveEventSequenceBase.prototype.dragAndDrop = function ( /* dragElement, currentElement, prevElement, options, dragDataStore */) {
        };
        MoveEventSequenceBase.prototype.teardown = function ( /* currentElement, eventOptions, prevElement */) {
        };
        MoveEventSequenceBase.prototype.run = function (currentElement, prevElement, options, dragElement, dragDataStore) {
            // NOTE: if last hovered element was in an iframe that has been removed, IE
            // raises an exception when we try to compare it with the current element
            var prevElementInDocument = prevElement && testCafeCore.domUtils.isElementInDocument(prevElement);
            var prevElementInRemovedIframe = prevElement && testCafeCore.domUtils.isElementInIframe(prevElement) &&
                !testCafeCore.domUtils.getIframeByElement(prevElement);
            if (!prevElementInDocument || prevElementInRemovedIframe)
                prevElement = null;
            var elementChanged = currentElement !== prevElement;
            var commonAncestor = elementChanged ? testCafeCore.domUtils.getCommonAncestor(currentElement, prevElement) : null;
            this.setup();
            if (elementChanged && !!prevElement)
                this.leaveElement(currentElement, prevElement, commonAncestor, options);
            if (browserUtils$2.isIE)
                this.move(currentElement, options);
            if (elementChanged && testCafeCore.domUtils.isElementInDocument(currentElement))
                this.enterElement(currentElement, prevElement, commonAncestor, options);
            if (!browserUtils$2.isIE)
                this.move(currentElement, options);
            this.dragAndDrop(dragElement, currentElement, prevElement, options, dragDataStore);
            this.teardown(currentElement, options, prevElement);
            var dragAndDropMode = this.dragAndDropMode;
            var dropAllowed = this.dropAllowed;
            this.dragAndDropMode = false;
            this.dropAllowed = false;
            return { dragAndDropMode: dragAndDropMode, dropAllowed: dropAllowed };
        };
        return MoveEventSequenceBase;
    }());

    var eventSimulator = hammerhead__default.eventSandbox.eventSimulator;
    var extend = hammerhead__default.utils.extend;
    var nativeMethods$5 = hammerhead__default.nativeMethods;
    var MoveBehaviour = /** @class */ (function () {
        function MoveBehaviour() {
        }
        MoveBehaviour.leaveElement = function (currentElement, prevElement, commonAncestor, options) {
            eventSimulator.mouseout(prevElement, extend({ relatedTarget: currentElement }, options));
            var currentParent = prevElement;
            while (currentParent && currentParent !== commonAncestor) {
                eventSimulator.mouseleave(currentParent, extend({ relatedTarget: currentElement }, options));
                currentParent = nativeMethods$5.nodeParentNodeGetter.call(currentParent);
            }
        };
        MoveBehaviour.enterElement = function (currentElement, prevElement, commonAncestor, options) {
            eventSimulator.mouseover(currentElement, extend({ relatedTarget: prevElement }, options));
            var currentParent = currentElement;
            var mouseenterElements = [];
            while (currentParent && currentParent !== commonAncestor) {
                mouseenterElements.push(currentParent);
                currentParent = testCafeCore.domUtils.getParentExceptShadowRoot(currentParent);
            }
            for (var i = mouseenterElements.length - 1; i > -1; i--)
                eventSimulator.mouseenter(mouseenterElements[i], extend({ relatedTarget: prevElement }, options));
        };
        MoveBehaviour.move = function (moveEvent, element, options) {
            eventSimulator[moveEvent](element, options);
        };
        return MoveBehaviour;
    }());
    var DragAndDropBehavior = /** @class */ (function () {
        function DragAndDropBehavior() {
        }
        DragAndDropBehavior.dragAndDrop = function (dragElement, currentElement, prevElement, options) {
            eventSimulator.drag(dragElement, options);
            var currentElementChanged = currentElement !== prevElement;
            if (currentElementChanged) {
                if (testCafeCore.domUtils.isElementInDocument(currentElement)) {
                    options.relatedTarget = prevElement;
                    eventSimulator.dragenter(currentElement, options);
                }
                if (prevElement) {
                    options.relatedTarget = currentElement;
                    eventSimulator.dragleave(prevElement, options);
                }
            }
            return !eventSimulator.dragover(currentElement, options);
        };
        return DragAndDropBehavior;
    }());

    var eventSimulator$1 = hammerhead__default.eventSandbox.eventSimulator;
    var TOUCH_MOVE_EVENT_NAME = 'touchmove';
    var MoveEventSequence = /** @class */ (function (_super) {
        __extends(MoveEventSequence, _super);
        function MoveEventSequence(options) {
            var _this = _super.call(this, options) || this;
            _this.holdLeftButton = options.holdLeftButton;
            return _this;
        }
        MoveEventSequence.prototype.leaveElement = function (currentElement, prevElement, commonAncestor, options) {
            MoveBehaviour.leaveElement(currentElement, prevElement, commonAncestor, options);
        };
        MoveEventSequence.prototype.enterElement = function (currentElement, prevElement, commonAncestor, options) {
            MoveBehaviour.enterElement(currentElement, prevElement, commonAncestor, options);
        };
        MoveEventSequence.prototype.move = function (element, options) {
            if (this._needEmulateMoveEvent())
                MoveBehaviour.move(this.moveEvent, element, options);
        };
        MoveEventSequence.prototype.teardown = function (currentElement, eventOptions, prevElement) {
            // NOTE: we need to add an extra 'mousemove' if the element was changed because sometimes
            // the client script requires several 'mousemove' events for an element (T246904)
            if (this._needEmulateMoveEvent() && testCafeCore.domUtils.isElementInDocument(currentElement) && currentElement !== prevElement)
                eventSimulator$1[this.moveEvent](currentElement, eventOptions);
        };
        MoveEventSequence.prototype._needEmulateMoveEvent = function () {
            return this.moveEvent !== TOUCH_MOVE_EVENT_NAME || this.holdLeftButton;
        };
        return MoveEventSequence;
    }(MoveEventSequenceBase));

    var DragAndDropMoveEventSequence = /** @class */ (function (_super) {
        __extends(DragAndDropMoveEventSequence, _super);
        function DragAndDropMoveEventSequence() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DragAndDropMoveEventSequence.prototype.setup = function () {
            _super.prototype.setup.call(this);
            this.dragAndDropMode = true;
        };
        DragAndDropMoveEventSequence.prototype.dragAndDrop = function (dragElement, currentElement, prevElement, options) {
            this.dropAllowed = DragAndDropBehavior.dragAndDrop(dragElement, currentElement, prevElement, options);
        };
        return DragAndDropMoveEventSequence;
    }(MoveEventSequenceBase));

    var eventSimulator$2 = hammerhead__default.eventSandbox.eventSimulator;
    var DragAndDropFirstMoveEventSequence = /** @class */ (function (_super) {
        __extends(DragAndDropFirstMoveEventSequence, _super);
        function DragAndDropFirstMoveEventSequence() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DragAndDropFirstMoveEventSequence.prototype.setup = function () {
            _super.prototype.setup.call(this);
            this.dragAndDropMode = true;
        };
        DragAndDropFirstMoveEventSequence.prototype.leaveElement = function (currentElement, prevElement, commonAncestor, options) {
            MoveBehaviour.leaveElement(currentElement, prevElement, commonAncestor, options);
        };
        DragAndDropFirstMoveEventSequence.prototype.move = function (element, option) {
            MoveBehaviour.move(this.moveEvent, element, option);
        };
        DragAndDropFirstMoveEventSequence.prototype.enterElement = function (currentElement, prevElement, commonAncestor, options) {
            MoveBehaviour.enterElement(currentElement, prevElement, commonAncestor, options);
        };
        DragAndDropFirstMoveEventSequence.prototype.dragAndDrop = function (dragElement, currentElement, prevElement, options, dragDataStore) {
            var dragAllowed = eventSimulator$2.dragstart(dragElement, options);
            dragDataStore.setReadOnlyMode();
            if (!dragAllowed) {
                this.dragAndDropMode = false;
                return;
            }
            this.dropAllowed = DragAndDropBehavior.dragAndDrop(dragElement, currentElement, prevElement, options);
        };
        DragAndDropFirstMoveEventSequence.prototype.run = function (currentElement, prevElement, options, dragElement, dragDataStore) {
            return _super.prototype.run.call(this, currentElement, null, options, dragElement, dragDataStore);
        };
        return DragAndDropFirstMoveEventSequence;
    }(MoveEventSequenceBase));

    function createEventSequence(dragAndDropEnabled, firstMovingStepOccured, options) {
        if (!dragAndDropEnabled)
            return new MoveEventSequence(options);
        if (firstMovingStepOccured)
            return new DragAndDropMoveEventSequence(options);
        return new DragAndDropFirstMoveEventSequence(options);
    }

    var lastHoveredElement = null;
    var lastHoveredElementHolder = {
        get: function () {
            return lastHoveredElement;
        },
        set: function (element) {
            lastHoveredElement = element;
        },
    };

    var Promise$4 = hammerhead__default.Promise;
    var nativeMethods$6 = hammerhead__default.nativeMethods;
    var featureDetection = hammerhead__default.utils.featureDetection;
    var htmlUtils = hammerhead__default.utils.html;
    var urlUtils = hammerhead__default.utils.url;
    var eventSimulator$3 = hammerhead__default.eventSandbox.eventSimulator;
    var messageSandbox$2 = hammerhead__default.eventSandbox.message;
    var DataTransfer = hammerhead__default.eventSandbox.DataTransfer;
    var DragDataStore = hammerhead__default.eventSandbox.DragDataStore;
    var positionUtils$1 = testCafeCore__default.positionUtils;
    var domUtils$2 = testCafeCore__default.domUtils;
    var styleUtils = testCafeCore__default.styleUtils;
    var eventUtils = testCafeCore__default.eventUtils;
    var promiseUtils = testCafeCore__default.promiseUtils;
    var sendRequestToFrame = testCafeCore__default.sendRequestToFrame;
    var MOVE_REQUEST_CMD = 'automation|move|request';
    var MOVE_RESPONSE_CMD = 'automation|move|response';
    // Setup cross-iframe interaction
    messageSandbox$2.on(messageSandbox$2.SERVICE_MSG_RECEIVED_EVENT, function (e) {
        if (e.message.cmd === MOVE_REQUEST_CMD) {
            if (e.source.parent === window)
                MoveAutomation.onMoveToIframeRequest(e);
            else {
                hammerhead__default.on(hammerhead__default.EVENTS.beforeUnload, function () { return messageSandbox$2.sendServiceMsg({ cmd: MOVE_RESPONSE_CMD }, e.source); });
                MoveAutomation.onMoveOutRequest(e);
            }
        }
    });
    // Utils
    function findDraggableElement(element) {
        var parentNode = element;
        while (parentNode) {
            if (parentNode.draggable)
                return parentNode;
            parentNode = nativeMethods$6.nodeParentNodeGetter.call(parentNode);
        }
        return null;
    }
    var MoveAutomation = /** @class */ (function () {
        function MoveAutomation(element, moveOptions) {
            this.touchMode = featureDetection.isTouchDevice;
            this.moveEvent = this.touchMode ? 'touchmove' : 'mousemove';
            this.holdLeftButton = moveOptions.holdLeftButton;
            this.dragElement = null;
            this.dragAndDropState = new DragAndDropState();
            this.automationSettings = new AutomationSettings(moveOptions.speed);
            var target = MoveAutomation.getTarget(element, moveOptions.offsetX, moveOptions.offsetY);
            this.element = target.element;
            this.offsetX = target.offsetX;
            this.offsetY = target.offsetY;
            this.speed = moveOptions.speed;
            this.cursorSpeed = this.holdLeftButton ? this.automationSettings.draggingSpeed : this.automationSettings.cursorSpeed;
            this.minMovingTime = moveOptions.minMovingTime || null;
            this.modifiers = moveOptions.modifiers || {};
            this.skipScrolling = moveOptions.skipScrolling;
            this.skipDefaultDragBehavior = moveOptions.skipDefaultDragBehavior;
            this.endPoint = null;
            // moving state
            this.movingTime = null;
            this.x = null;
            this.y = null;
            this.startTime = null;
            this.endTime = null;
            this.distanceX = null;
            this.distanceY = null;
            this.firstMovingStepOccured = false;
        }
        MoveAutomation.getTarget = function (el, offsetX, offsetY) {
            // NOTE: if the target point (considering offsets) is out of
            // the element change the target element to the document element
            var relateToDocument = !positionUtils$1.containsOffset(el, offsetX, offsetY);
            var relatedPoint = relateToDocument ? getAutomationPoint(el, offsetX, offsetY) : { x: offsetX, y: offsetY };
            return {
                element: relateToDocument ? document.documentElement : el,
                offsetX: relatedPoint.x,
                offsetY: relatedPoint.y,
            };
        };
        MoveAutomation.onMoveToIframeRequest = function (e) {
            var iframePoint = {
                x: e.message.endX,
                y: e.message.endY,
            };
            var iframeWin = e.source;
            var iframe = domUtils$2.findIframeByWindow(iframeWin);
            var iframeBorders = styleUtils.getBordersWidth(iframe);
            var iframePadding = styleUtils.getElementPadding(iframe);
            var iframeRectangle = positionUtils$1.getIframeClientCoordinates(iframe);
            var iframePointRelativeToParent = positionUtils$1.getIframePointRelativeToParentFrame(iframePoint, iframeWin);
            var cursorPosition = cursor.position;
            var intersectionPoint = positionUtils$1.isInRectangle(cursorPosition, iframeRectangle) ? cursorPosition :
                getLineRectIntersection(cursorPosition, iframePointRelativeToParent, iframeRectangle);
            var intersectionRelatedToIframe = {
                x: intersectionPoint.x - iframeRectangle.left,
                y: intersectionPoint.y - iframeRectangle.top,
            };
            var moveOptions = new MoveOptions({
                modifiers: e.message.modifiers,
                offsetX: intersectionRelatedToIframe.x + iframeBorders.left + iframePadding.left,
                offsetY: intersectionRelatedToIframe.y + iframeBorders.top + iframePadding.top,
                speed: e.message.speed,
                // NOTE: we should not perform scrolling because the active window was
                // already scrolled to the target element before the request (GH-847)
                skipScrolling: true,
            }, false);
            var moveAutomation = new MoveAutomation(iframe, moveOptions);
            var responseMsg = {
                cmd: MOVE_RESPONSE_CMD,
                x: intersectionRelatedToIframe.x,
                y: intersectionRelatedToIframe.y,
            };
            if (cursor.activeWindow !== iframeWin) {
                moveAutomation
                    .run()
                    .then(function () {
                    cursor.activeWindow = iframeWin;
                    messageSandbox$2.sendServiceMsg(responseMsg, iframeWin);
                });
            }
            else
                messageSandbox$2.sendServiceMsg(responseMsg, iframeWin);
        };
        MoveAutomation.onMoveOutRequest = function (e) {
            var parentWin = e.source;
            var iframeRectangle = {
                left: e.message.left,
                right: e.message.right,
                top: e.message.top,
                bottom: e.message.bottom,
            };
            if (!e.message.iframeUnderCursor) {
                var _a = e.message, startX = _a.startX, startY = _a.startY;
                var clientX = startX - iframeRectangle.left;
                var clientY = startY - iframeRectangle.top;
                // NOTE: We should not emulate mouseout and mouseleave if iframe was reloaded.
                var element = lastHoveredElementHolder.get();
                if (element) {
                    eventSimulator$3.mouseout(element, { clientX: clientX, clientY: clientY, relatedTarget: null });
                    eventSimulator$3.mouseleave(element, { clientX: clientX, clientY: clientY, relatedTarget: null });
                }
                messageSandbox$2.sendServiceMsg({ cmd: MOVE_RESPONSE_CMD }, parentWin);
                return;
            }
            var cursorPosition = cursor.position;
            var startPoint = {
                x: iframeRectangle.left + cursorPosition.x,
                y: iframeRectangle.top + cursorPosition.y,
            };
            var endPoint = { x: e.message.endX, y: e.message.endY };
            var intersectionPoint = getLineRectIntersection(startPoint, endPoint, iframeRectangle);
            // NOTE: We should not move the cursor out of the iframe if
            // the cursor path does not intersect with the iframe borders.
            if (!intersectionPoint) {
                messageSandbox$2.sendServiceMsg({
                    cmd: MOVE_RESPONSE_CMD,
                    x: iframeRectangle.left,
                    y: iframeRectangle.top,
                }, parentWin);
                return;
            }
            var moveOptions = new MoveOptions({
                modifiers: e.message.modifiers,
                offsetX: intersectionPoint.x - iframeRectangle.left,
                offsetY: intersectionPoint.y - iframeRectangle.top,
                speed: e.message.speed,
                // NOTE: we should not perform scrolling because the active window was
                // already scrolled to the target element before the request (GH-847)
                skipScrolling: true,
            }, false);
            var moveAutomation = new MoveAutomation(document.documentElement, moveOptions);
            moveAutomation
                .run()
                .then(function () {
                var responseMsg = {
                    cmd: MOVE_RESPONSE_CMD,
                    x: intersectionPoint.x,
                    y: intersectionPoint.y,
                };
                cursor.activeWindow = parentWin;
                messageSandbox$2.sendServiceMsg(responseMsg, parentWin);
            });
        };
        MoveAutomation.prototype._getTargetClientPoint = function () {
            var scroll = styleUtils.getElementScroll(this.element);
            if (domUtils$2.isHtmlElement(this.element)) {
                return {
                    x: Math.floor(this.offsetX - scroll.left),
                    y: Math.floor(this.offsetY - scroll.top),
                };
            }
            var clientPosition = positionUtils$1.getClientPosition(this.element);
            var isDocumentBody = this.element.tagName && domUtils$2.isBodyElement(this.element);
            return {
                x: Math.floor(isDocumentBody ? clientPosition.x + this.offsetX : clientPosition.x + this.offsetX -
                    scroll.left),
                y: Math.floor(isDocumentBody ? clientPosition.y + this.offsetY : clientPosition.y + this.offsetY -
                    scroll.top),
            };
        };
        MoveAutomation.prototype._emulateEvents = function (currentElement) {
            var button = this.holdLeftButton ? eventUtils.BUTTONS_PARAMETER.leftButton : eventUtils.BUTTONS_PARAMETER.noButton;
            var devicePoint = getDevicePoint({ x: this.x, y: this.y });
            var eventOptions = {
                clientX: this.x,
                clientY: this.y,
                screenX: devicePoint.x,
                screenY: devicePoint.y,
                buttons: button,
                ctrl: this.modifiers.ctrl,
                alt: this.modifiers.alt,
                shift: this.modifiers.shift,
                meta: this.modifiers.meta,
                dataTransfer: this.dragAndDropState.dataTransfer,
            };
            var eventSequenceOptions = { moveEvent: this.moveEvent, holdLeftButton: this.holdLeftButton };
            var eventSequence = createEventSequence(this.dragAndDropState.enabled, this.firstMovingStepOccured, eventSequenceOptions);
            var _a = eventSequence.run(currentElement, lastHoveredElementHolder.get(), eventOptions, this.dragElement, this.dragAndDropState.dataStore), dragAndDropMode = _a.dragAndDropMode, dropAllowed = _a.dropAllowed;
            this.firstMovingStepOccured = true;
            this.dragAndDropState.enabled = dragAndDropMode;
            this.dragAndDropState.dropAllowed = dropAllowed;
            lastHoveredElementHolder.set(currentElement);
        };
        MoveAutomation.prototype._movingStep = function () {
            var _this = this;
            if (this.touchMode && !this.holdLeftButton) {
                this.x = this.endPoint.x;
                this.y = this.endPoint.y;
            }
            else if (!this.startTime) {
                this.startTime = nativeMethods$6.dateNow();
                this.endTime = this.startTime + this.movingTime;
                // NOTE: the mousemove event can't be simulated at the point where the cursor
                // was located at the start. Therefore, we add a minimal distance 1 px.
                this.x += this.distanceX > 0 ? 1 : -1;
                this.y += this.distanceY > 0 ? 1 : -1;
            }
            else {
                var currentTime = Math.min(nativeMethods$6.dateNow(), this.endTime);
                var progress = (currentTime - this.startTime) / (this.endTime - this.startTime);
                this.x = Math.floor(this.startPoint.x + this.distanceX * progress);
                this.y = Math.floor(this.startPoint.y + this.distanceY * progress);
            }
            return cursor
                .move(this.x, this.y)
                .then(underCursor)
                // NOTE: in touch mode, events are simulated for the element for which mousedown was simulated (GH-372)
                .then(function (topElement) {
                var currentElement = _this.holdLeftButton && _this.touchMode ? _this.dragElement : topElement;
                // NOTE: it can be null in IE
                if (!currentElement)
                    return null;
                return _this._emulateEvents(currentElement);
            })
                .then(nextTick);
        };
        MoveAutomation.prototype._isMovingFinished = function () {
            return this.x === this.endPoint.x && this.y === this.endPoint.y;
        };
        MoveAutomation.prototype._move = function () {
            var _this = this;
            this.startPoint = cursor.position;
            this.x = this.startPoint.x;
            this.y = this.startPoint.y;
            this.distanceX = this.endPoint.x - this.startPoint.x;
            this.distanceY = this.endPoint.y - this.startPoint.y;
            this.movingTime = Math.max(Math.abs(this.distanceX), Math.abs(this.distanceY)) / this.cursorSpeed;
            if (this.minMovingTime)
                this.movingTime = Math.max(this.movingTime, this.minMovingTime);
            return promiseUtils.whilst(function () { return !_this._isMovingFinished(); }, function () { return _this._movingStep(); });
        };
        MoveAutomation.prototype._scroll = function () {
            if (this.skipScrolling)
                return Promise$4.resolve();
            var scrollOptions = new ScrollOptions({ offsetX: this.offsetX, offsetY: this.offsetY }, false);
            var scrollAutomation = new ScrollAutomation(this.element, scrollOptions);
            return scrollAutomation.run();
        };
        MoveAutomation.prototype._moveToCurrentFrame = function () {
            if (cursor.active)
                return Promise$4.resolve();
            var _a = cursor.position, x = _a.x, y = _a.y;
            var activeWindow = cursor.activeWindow;
            var iframe = null;
            var iframeUnderCursor = null;
            var iframeRectangle = null;
            var msg = {
                cmd: MOVE_REQUEST_CMD,
                startX: x,
                startY: y,
                endX: this.endPoint.x,
                endY: this.endPoint.y,
                modifiers: this.modifiers,
                speed: this.speed,
            };
            if (activeWindow.parent === window) {
                iframe = domUtils$2.findIframeByWindow(activeWindow);
                iframeRectangle = positionUtils$1.getIframeClientCoordinates(iframe);
                msg.left = iframeRectangle.left;
                msg.top = iframeRectangle.top;
                msg.right = iframeRectangle.right;
                msg.bottom = iframeRectangle.bottom;
            }
            return underCursor()
                .then(function (topElement) {
                iframeUnderCursor = topElement === iframe;
                if (activeWindow.parent === window)
                    msg.iframeUnderCursor = iframeUnderCursor;
                return sendRequestToFrame(msg, MOVE_RESPONSE_CMD, activeWindow);
            })
                .then(function (message) {
                cursor.activeWindow = window;
                if (iframeUnderCursor || isIframeWindow(window))
                    return cursor.move(message.x, message.y);
                return null;
            });
        };
        MoveAutomation.prototype.run = function () {
            var _this = this;
            return underCursor()
                .then(function (topElement) {
                _this.dragElement = _this.holdLeftButton ? topElement : null;
                var draggable = findDraggableElement(_this.dragElement);
                // NOTE: we should skip simulating drag&drop's native behavior if the mousedown event was prevented (GH - 2529)
                if (draggable && featureDetection.hasDataTransfer && !_this.skipDefaultDragBehavior) {
                    _this.dragAndDropState.enabled = true;
                    _this.dragElement = draggable;
                    _this.dragAndDropState.element = _this.dragElement;
                    _this.dragAndDropState.dataStore = new DragDataStore();
                    _this.dragAndDropState.dataTransfer = new DataTransfer(_this.dragAndDropState.dataStore);
                    var isLink = domUtils$2.isAnchorElement(_this.dragElement);
                    if (isLink || domUtils$2.isImgElement(_this.dragElement)) {
                        var srcAttr = isLink ? 'href' : 'src';
                        var parsedUrl = urlUtils.parseProxyUrl(_this.dragElement[srcAttr]);
                        var src = parsedUrl ? parsedUrl.destUrl : _this.dragElement[srcAttr];
                        var outerHTML = htmlUtils.cleanUpHtml(nativeMethods$6.elementOuterHTMLGetter.call(_this.dragElement));
                        _this.dragAndDropState.dataTransfer.setData('text/plain', src);
                        _this.dragAndDropState.dataTransfer.setData('text/uri-list', src);
                        _this.dragAndDropState.dataTransfer.setData('text/html', outerHTML);
                    }
                }
                return _this._scroll();
            })
                .then(function () {
                var _a = _this._getTargetClientPoint(), x = _a.x, y = _a.y;
                var windowWidth = styleUtils.getWidth(window);
                var windowHeight = styleUtils.getHeight(window);
                if (x >= 0 && x <= windowWidth && y >= 0 && y <= windowHeight) {
                    _this.endPoint = { x: x, y: y };
                    return _this
                        ._moveToCurrentFrame()
                        .then(function () { return _this._move(); });
                }
                return null;
            })
                .then(function () { return _this.dragAndDropState; });
        };
        return MoveAutomation;
    }());

    var extend$1 = hammerhead__default.utils.extend;
    var ElementState = /** @class */ (function () {
        function ElementState(_a) {
            var _b = _a.element, element = _b === void 0 ? null : _b, _c = _a.clientPoint, clientPoint = _c === void 0 ? null : _c, _d = _a.screenPoint, screenPoint = _d === void 0 ? null : _d, _e = _a.isTarget, isTarget = _e === void 0 ? false : _e, _f = _a.inMoving, inMoving = _f === void 0 ? false : _f;
            this.element = element;
            this.clientPoint = clientPoint;
            this.screenPoint = screenPoint;
            this.isTarget = isTarget;
            this.inMoving = inMoving;
            this.devicePoint = getDevicePoint(clientPoint);
        }
        return ElementState;
    }());
    var VisibleElementAutomation = /** @class */ (function (_super) {
        __extends(VisibleElementAutomation, _super);
        function VisibleElementAutomation(element, offsetOptions) {
            var _this = _super.call(this) || this;
            _this.TARGET_ELEMENT_FOUND_EVENT = 'automation|target-element-found-event';
            _this.element = element;
            _this.options = offsetOptions;
            _this.automationSettings = new AutomationSettings(offsetOptions.speed);
            return _this;
        }
        VisibleElementAutomation.prototype._getElementForEvent = function (eventArgs) {
            var _a = eventArgs.point, x = _a.x, y = _a.y;
            var expectedElement = testCafeCore.positionUtils.containsOffset(this.element, this.options.offsetX, this.options.offsetY) ? this.element : null;
            return fromPoint(x, y, expectedElement).then(function (_a) {
                var element = _a.element;
                return element;
            });
        };
        VisibleElementAutomation.prototype._moveToElement = function () {
            var _this = this;
            var moveOptions = new MoveOptions(extend$1({ skipScrolling: true }, this.options), false);
            var moveAutomation = new MoveAutomation(this.element, moveOptions);
            return moveAutomation
                .run()
                .then(function () { return testCafeCore.delay(_this.automationSettings.mouseActionStepDelay); });
        };
        VisibleElementAutomation.prototype._scrollToElement = function () {
            var _this = this;
            var scrollOptions = new ScrollOptions(this.options);
            var scrollAutomation = new ScrollAutomation(this.element, scrollOptions);
            var wasScrolled = false;
            return scrollAutomation
                .run()
                .then(function (scrollWasPerformed) {
                wasScrolled = scrollWasPerformed;
                return testCafeCore.delay(_this.automationSettings.mouseActionStepDelay);
            })
                .then(underCursor)
                .then(function (currentElement) {
                var elementUnderCursorContainsTarget = !!currentElement && testCafeCore.domUtils.contains(_this.element, currentElement);
                if (!elementUnderCursorContainsTarget || !wasScrolled)
                    return null;
                var prevElement = lastHoveredElementHolder.get();
                var commonAncestor = testCafeCore.domUtils.getCommonAncestor(currentElement, prevElement);
                var clientPosition = testCafeCore.positionUtils.getClientPosition(currentElement);
                var devicePoint = getDevicePoint({ x: clientPosition.x, y: clientPosition.y });
                var options = {
                    clientX: clientPosition.x,
                    clientY: clientPosition.y,
                    screenX: devicePoint.x,
                    screenY: devicePoint.y,
                    ctrl: false,
                    alt: false,
                    shift: false,
                    meta: false,
                    buttons: testCafeCore.eventUtils.BUTTONS_PARAMETER.leftButton,
                };
                MoveBehaviour.leaveElement(currentElement, prevElement, commonAncestor, options);
                MoveBehaviour.enterElement(currentElement, prevElement, commonAncestor, options);
                lastHoveredElementHolder.set(currentElement);
                return wasScrolled;
            });
        };
        VisibleElementAutomation.prototype._getElementOffset = function () {
            var defaultOffsets = getOffsetOptions(this.element);
            var _a = this.options, offsetX = _a.offsetX, offsetY = _a.offsetY;
            offsetX = offsetX || offsetX === 0 ? offsetX : defaultOffsets.offsetX;
            offsetY = offsetY || offsetY === 0 ? offsetY : defaultOffsets.offsetY;
            return { offsetX: offsetX, offsetY: offsetY };
        };
        VisibleElementAutomation.prototype._wrapAction = function (action) {
            var _this = this;
            var _a = this._getElementOffset(), offsetX = _a.offsetX, offsetY = _a.offsetY;
            var screenPointBeforeAction = getAutomationPoint(this.element, offsetX, offsetY);
            var clientPositionBeforeAction = testCafeCore.positionUtils.getClientPosition(this.element);
            return action()
                .then(function () {
                var screenPointAfterAction = getAutomationPoint(_this.element, offsetX, offsetY);
                var clientPositionAfterAction = testCafeCore.positionUtils.getClientPosition(_this.element);
                var clientPoint = convertToClient(_this.element, screenPointAfterAction);
                var expectedElement = testCafeCore.positionUtils.containsOffset(_this.element, offsetX, offsetY) ? _this.element : null;
                return fromPoint(clientPoint.x, clientPoint.y, expectedElement)
                    .then(function (_a) {
                    var element = _a.element, corrected = _a.corrected;
                    var foundElement = element;
                    if (!foundElement)
                        return new ElementState({});
                    var isTarget = !expectedElement || corrected || foundElement === _this.element;
                    if (!isTarget) {
                        // NOTE: perform an operation with searching in dom only if necessary
                        isTarget = testCafeCore.arrayUtils.indexOf(testCafeCore.domUtils.getParents(foundElement), _this.element) > -1;
                    }
                    var offsetPositionChanged = screenPointBeforeAction.x !== screenPointAfterAction.x ||
                        screenPointBeforeAction.y !== screenPointAfterAction.y;
                    var clientPositionChanged = clientPositionBeforeAction.x !== clientPositionAfterAction.x ||
                        clientPositionBeforeAction.y !== clientPositionAfterAction.y;
                    // NOTE: We consider the element moved if its offset position and client position
                    // are changed both. If only client position was changed it means the page was
                    // scrolled and the element keeps its position on the page. If only offset position was
                    // changed it means the element is fixed on the page (it can be implemented via script).
                    var targetElementIsMoving = offsetPositionChanged && clientPositionChanged;
                    return new ElementState({
                        element: element,
                        clientPoint: clientPoint,
                        screenPoint: screenPointAfterAction,
                        isTarget: isTarget,
                        inMoving: targetElementIsMoving,
                    });
                });
            });
        };
        VisibleElementAutomation._checkElementState = function (state, useStrictElementCheck) {
            if (!state.element)
                throw new Error(AUTOMATION_ERROR_TYPES.elementIsInvisibleError);
            if (useStrictElementCheck && (!state.isTarget || state.inMoving))
                throw new Error(AUTOMATION_ERROR_TYPES.foundElementIsNotTarget);
            return state;
        };
        VisibleElementAutomation.prototype._ensureElement = function (useStrictElementCheck, skipCheckAfterMoving, skipMoving) {
            var _this = this;
            return this
                ._wrapAction(function () { return _this._scrollToElement(); })
                .then(function (state) { return VisibleElementAutomation._checkElementState(state, useStrictElementCheck); })
                .then(function (state) {
                return skipMoving ? state : _this._wrapAction(function () { return _this._moveToElement(); });
            })
                .then(function (state) {
                if (!skipCheckAfterMoving)
                    VisibleElementAutomation._checkElementState(state, useStrictElementCheck);
                return state;
            })
                .then(function (state) {
                _this.emit(_this.TARGET_ELEMENT_FOUND_EVENT, { element: state.element });
                return {
                    element: state.element,
                    clientPoint: state.clientPoint,
                    screenPoint: state.screenPoint,
                    devicePoint: state.devicePoint,
                };
            });
        };
        return VisibleElementAutomation;
    }(testCafeCore.serviceUtils.EventEmitter));

    var Promise$5 = hammerhead__default.Promise;
    function calculatePosition(el, position) {
        var centerX = Math.floor(el.scrollWidth / 2 - el.clientWidth / 2);
        var centerY = Math.floor(el.scrollHeight / 2 - el.clientHeight / 2);
        var positions = {
            'top': [centerX, 0],
            'right': [el.scrollWidth, centerY],
            'bottom': [centerX, el.scrollHeight],
            'left': [0, centerY],
            'topRight': [el.scrollWidth, 0],
            'topLeft': [0, 0],
            'bottomRight': [el.scrollWidth, el.scrollHeight],
            'bottomLeft': [0, el.scrollHeight],
            'center': [centerX, centerY],
        };
        return positions[position];
    }
    var SetScrollAutomation = /** @class */ (function (_super) {
        __extends(SetScrollAutomation, _super);
        function SetScrollAutomation(element, _a, offsetOptions) {
            var _b;
            var x = _a.x, y = _a.y, position = _a.position, byX = _a.byX, byY = _a.byY;
            var _this = _super.call(this, element, offsetOptions) || this;
            if (position)
                _b = calculatePosition(element, position), x = _b[0], y = _b[1];
            _this.scrollLeft = typeof x === 'number' ? x : element.scrollLeft;
            _this.scrollTop = typeof y === 'number' ? y : element.scrollTop;
            if (byX)
                _this.scrollLeft += byX;
            if (byY)
                _this.scrollTop += byY;
            return _this;
        }
        SetScrollAutomation.prototype.run = function (useStrictElementCheck) {
            var _this = this;
            var promise = Promise$5.resolve();
            if (this.element !== document.scrollingElement && this.element !== document.documentElement)
                promise = this._ensureElement(useStrictElementCheck, true, true);
            return promise
                .then(function () {
                _this.element.scrollLeft = _this.scrollLeft;
                _this.element.scrollTop = _this.scrollTop;
            });
        };
        return SetScrollAutomation;
    }(VisibleElementAutomation));

    var ScrollIntoViewAutomation = /** @class */ (function (_super) {
        __extends(ScrollIntoViewAutomation, _super);
        function ScrollIntoViewAutomation(element, offsetOptions) {
            return _super.call(this, element, offsetOptions) || this;
        }
        ScrollIntoViewAutomation.prototype.run = function (useStrictElementCheck) {
            return this._ensureElement(useStrictElementCheck, true, true);
        };
        return ScrollIntoViewAutomation;
    }(VisibleElementAutomation));

    // Ensure command element properties
    function ensureElementEditable(element) {
        if (!testCafeCore.domUtils.isEditableElement(element))
            throw new ActionElementNonEditableError();
    }
    function ensureTextAreaElement(element) {
        if (!testCafeCore.domUtils.isTextAreaElement(element))
            throw new ActionElementNotTextAreaError();
    }
    function ensureContentEditableElement(element, argumentTitle) {
        if (!testCafeCore.domUtils.isContentEditableElement(element))
            throw new ActionElementNonContentEditableError(argumentTitle);
    }
    function ensureRootContainer(elements) {
        // NOTE: We should find a common element for the nodes to perform the select action
        if (!testCafeCore.contentEditable.getNearestCommonAncestor(elements[0], elements[1]))
            throw new ActionRootContainerNotFoundError();
        return elements;
    }
    function ensureFileInput(element) {
        if (!testCafeCore.domUtils.isFileInput(element))
            throw new ActionElementIsNotFileInputError();
    }
    function ensureOffsetOptions(element, options) {
        var _a = testcafeAutomation.getOffsetOptions(element, options.offsetX, options.offsetY), offsetX = _a.offsetX, offsetY = _a.offsetY;
        options.offsetX = offsetX;
        options.offsetY = offsetY;
    }
    var MAX_DELAY_AFTER_EXECUTION = 2000;
    var CHECK_ELEMENT_IN_AUTOMATIONS_INTERVAL = 250;
    var DateCtor$1 = hammerhead.nativeMethods.date;
    var ActionExecutor = /** @class */ (function () {
        function ActionExecutor(command, globalSelectorTimeout, statusBar, testSpeed) {
            this.command = command;
            this.globalSelectorTimeout = globalSelectorTimeout;
            this.statusBar = statusBar;
            this.testSpeed = testSpeed;
            this.targetElement = null;
            this.elements = [];
            this.ensureElementsPromise = null;
            this.ensureElementsStartTime = null;
            this.executionStartTime = null;
            this.executionStartedHandler = null;
            this.commandSelectorTimeout = null;
        }
        ActionExecutor.prototype._getSpecificTimeout = function () {
            var hasSpecificTimeout = this.command.selector && typeof this.command.selector.timeout === 'number';
            return hasSpecificTimeout ? this.command.selector.timeout : this.globalSelectorTimeout;
        };
        ActionExecutor.prototype._delayAfterExecution = function () {
            if (!this.command.options || this.command.options.speed === 1)
                return hammerhead.Promise.resolve();
            return testCafeCore.delay((1 - this.command.options.speed) * MAX_DELAY_AFTER_EXECUTION);
        };
        ActionExecutor.prototype._isExecutionTimeoutExpired = function () {
            return hammerhead.nativeMethods.dateNow() - this.executionStartTime >= this.commandSelectorTimeout;
        };
        ActionExecutor.prototype._ensureCommandArguments = function () {
            if (this.command.type === COMMAND_TYPE.pressKey) {
                var parsedKeySequence = testCafeCore.parseKeySequence(this.command.keys);
                if (parsedKeySequence.error)
                    throw new ActionIncorrectKeysError('keys');
            }
        };
        ActionExecutor.prototype._ensureCommandElements = function () {
            var _this = this;
            var elementDescriptors = [];
            if (this.command.selector)
                elementDescriptors.push(createElementDescriptor(this.command.selector));
            if (this.command.type === COMMAND_TYPE.dragToElement)
                elementDescriptors.push(createAdditionalElementDescriptor(this.command.destinationSelector, 'destinationSelector'));
            else if (this.command.type === COMMAND_TYPE.selectEditableContent) {
                elementDescriptors.push(createAdditionalElementDescriptor(this.command.startSelector, 'startSelector'));
                elementDescriptors.push(createAdditionalElementDescriptor(this.command.endSelector || this.command.startSelector, 'endSelector'));
            }
            else if (this.command.type === COMMAND_TYPE.dispatchEvent && this.command.relatedTarget)
                elementDescriptors.push(createAdditionalElementDescriptor(this.command.relatedTarget, 'relatedTarget'));
            return ensureElements(elementDescriptors, this.globalSelectorTimeout)
                .then(function (elements) {
                _this.elements = elements;
            });
        };
        ActionExecutor.prototype._ensureCommandElementsProperties = function () {
            if (this.command.type === COMMAND_TYPE.selectText)
                ensureElementEditable(this.elements[0]);
            else if (this.command.type === COMMAND_TYPE.selectTextAreaContent)
                ensureTextAreaElement(this.elements[0]);
            else if (this.command.type === COMMAND_TYPE.selectEditableContent) {
                ensureContentEditableElement(this.elements[0], 'startSelector');
                ensureContentEditableElement(this.elements[1], 'endSelector');
                ensureRootContainer(this.elements);
            }
            else if (this.command.type === COMMAND_TYPE.setFilesToUpload || this.command.type === COMMAND_TYPE.clearUpload)
                ensureFileInput(this.elements[0]);
        };
        ActionExecutor.prototype._ensureCommandOptions = function () {
            if (this.elements.length && this.command.options && 'offsetX' in this.command.options && 'offsetY' in this.command.options)
                ensureOffsetOptions(this.elements[0], this.command.options);
        };
        ActionExecutor.prototype._createAutomation = function () {
            var selectArgs = null;
            switch (this.command.type) {
                case COMMAND_TYPE.dispatchEvent:
                    if (this.elements[1])
                        this.command.options.relatedTarget = this.elements[1];
                    return new testcafeAutomation.DispatchEvent(this.elements[0], this.command.eventName, this.command.options);
                case COMMAND_TYPE.click:
                    if (/option|optgroup/.test(testCafeCore.domUtils.getTagName(this.elements[0])))
                        return new testcafeAutomation.SelectChildClick(this.elements[0], this.command.options);
                    return new testcafeAutomation.Click(this.elements[0], this.command.options);
                case COMMAND_TYPE.rightClick:
                    return new testcafeAutomation.RClick(this.elements[0], this.command.options);
                case COMMAND_TYPE.doubleClick:
                    return new testcafeAutomation.DblClick(this.elements[0], this.command.options);
                case COMMAND_TYPE.hover:
                    return new testcafeAutomation.Hover(this.elements[0], this.command.options);
                case COMMAND_TYPE.drag:
                    return new testcafeAutomation.DragToOffset(this.elements[0], this.command.dragOffsetX, this.command.dragOffsetY, this.command.options);
                case COMMAND_TYPE.dragToElement:
                    return new testcafeAutomation.DragToElement(this.elements[0], this.elements[1], this.command.options);
                case COMMAND_TYPE.scroll: {
                    var _a = this.command, x = _a.x, y = _a.y, position = _a.position, options = _a.options;
                    return new SetScrollAutomation(this.elements[0], { x: x, y: y, position: position }, options);
                }
                case COMMAND_TYPE.scrollBy: {
                    var _b = this.command, byX = _b.byX, byY = _b.byY, options = _b.options;
                    return new SetScrollAutomation(this.elements[0], { byX: byX, byY: byY }, options);
                }
                case COMMAND_TYPE.scrollIntoView: {
                    return new ScrollIntoViewAutomation(this.elements[0], this.command.options);
                }
                case COMMAND_TYPE.typeText:
                    // eslint-disable-next-line no-restricted-properties
                    return new testcafeAutomation.Type(this.elements[0], this.command.text, this.command.options);
                case COMMAND_TYPE.selectText:
                case COMMAND_TYPE.selectTextAreaContent:
                    selectArgs = testcafeAutomation.calculateSelectTextArguments(this.elements[0], this.command);
                    return new testcafeAutomation.SelectText(this.elements[0], selectArgs.startPos, selectArgs.endPos, this.command.options);
                case COMMAND_TYPE.selectEditableContent:
                    return new testcafeAutomation.SelectEditableContent(this.elements[0], this.elements[1], this.command.options);
                case COMMAND_TYPE.pressKey:
                    return new testcafeAutomation.Press(testCafeCore.parseKeySequence(this.command.keys).combinations, this.command.options);
                case COMMAND_TYPE.setFilesToUpload:
                    return new testcafeAutomation.Upload(this.elements[0], this.command.filePath, function (filePaths, scannedFilePaths) { return new ActionCannotFindFileToUploadError(filePaths, scannedFilePaths); });
                case COMMAND_TYPE.clearUpload:
                    return new testcafeAutomation.Upload(this.elements[0]);
            }
            return null;
        };
        ActionExecutor.prototype._runAction = function (strictElementCheck) {
            var _this = this;
            return this
                ._ensureCommandElements()
                .then(function () { return _this._ensureCommandElementsProperties(); })
                .then(function () {
                _this._ensureCommandOptions();
                var automation = _this._createAutomation();
                if (automation.TARGET_ELEMENT_FOUND_EVENT) {
                    automation.on(automation.TARGET_ELEMENT_FOUND_EVENT, function (e) {
                        _this.targetElement = e.element;
                        _this.statusBar.hideWaitingElementStatus(true);
                        _this.executionStartedHandler();
                    });
                }
                else {
                    _this.statusBar.hideWaitingElementStatus(true);
                    _this.executionStartedHandler();
                }
                return automation
                    .run(strictElementCheck);
            });
        };
        ActionExecutor.prototype._runRecursively = function () {
            var _this = this;
            var actionFinished = false;
            var strictElementCheck = true;
            return testCafeCore.promiseUtils.whilst(function () { return !actionFinished; }, function () {
                return _this
                    ._runAction(strictElementCheck)
                    .then(function () {
                    actionFinished = true;
                })
                    .catch(function (err) {
                    if (_this._isExecutionTimeoutExpired()) {
                        if (err.message === testcafeAutomation.ERROR_TYPES.foundElementIsNotTarget) {
                            // If we can't get a target element via elementFromPoint but it's
                            // visible we click on the point where the element is located.
                            strictElementCheck = false;
                            return hammerhead.Promise.resolve();
                        }
                        throw err.message === testcafeAutomation.ERROR_TYPES.elementIsInvisibleError ?
                            new ActionElementIsInvisibleError() : err;
                    }
                    return testCafeCore.delay(CHECK_ELEMENT_IN_AUTOMATIONS_INTERVAL);
                });
            });
        };
        ActionExecutor.prototype.execute = function () {
            var _this = this;
            if (this.command.options && !this.command.options.speed)
                this.command.options.speed = this.testSpeed;
            var startPromise = new hammerhead.Promise(function (resolve) {
                _this.executionStartedHandler = resolve;
            });
            var completionPromise = new hammerhead.Promise(function (resolve) {
                _this.executionStartTime = new DateCtor$1();
                try {
                    _this._ensureCommandArguments();
                }
                catch (err) {
                    resolve(new DriverStatus({ isCommandResult: true, executionError: err }));
                    return;
                }
                _this.commandSelectorTimeout = _this._getSpecificTimeout();
                _this.statusBar.showWaitingElementStatus(_this.commandSelectorTimeout);
                var _a = runWithBarriers(function () { return _this._runRecursively(); }), actionPromise = _a.actionPromise, barriersPromise = _a.barriersPromise;
                actionPromise
                    .then(function () { return hammerhead.Promise.all([
                    _this._delayAfterExecution(),
                    barriersPromise,
                ]); })
                    .then(function () {
                    var status = { isCommandResult: true };
                    var elements = __spreadArrays(_this.elements);
                    if (_this.targetElement)
                        elements[0] = _this.targetElement;
                    status.result = createReplicator(new SelectorElementActionTransform()).encode(elements);
                    resolve(new DriverStatus(status));
                })
                    .catch(function (err) {
                    return _this.statusBar.hideWaitingElementStatus(false)
                        .then(function () { return resolve(new DriverStatus({ isCommandResult: true, executionError: err })); });
                });
            });
            return { startPromise: startPromise, completionPromise: completionPromise };
        };
        return ActionExecutor;
    }());
    function executeAction(command, globalSelectorTimeout, statusBar, testSpeed) {
        var actionExecutor = new ActionExecutor(command, globalSelectorTimeout, statusBar, testSpeed);
        return actionExecutor.execute();
    }

    // -------------------------------------------------------------
    // WARNING: this file is used by both the client and the server.
    // Do not use any browser or node-specific API!
    // -------------------------------------------------------------
    function limitNumber (value, min, max) {
        return Math.min(Math.max(min, value), max);
    }

    function determineDimensionBounds(bounds, maximum) {
        var hasMin = typeof bounds.min === 'number';
        var hasMax = typeof bounds.max === 'number';
        var hasLength = typeof bounds.length === 'number';
        if (hasLength)
            bounds.length = limitNumber(bounds.length, 0, maximum);
        if (hasMin && bounds.min < 0)
            bounds.min += maximum;
        if (hasMax && bounds.max < 0)
            bounds.max += maximum;
        if (!hasMin)
            bounds.min = hasMax && hasLength ? bounds.max - bounds.length : 0;
        if (!hasMax)
            bounds.max = hasLength ? bounds.min + bounds.length : maximum;
        bounds.min = limitNumber(bounds.min, 0, maximum);
        bounds.max = limitNumber(bounds.max, 0, maximum);
        bounds.length = bounds.max - bounds.min;
        return bounds;
    }
    function determineScrollPoint(cropStart, cropEnd, viewportBound) {
        return Math.round(cropStart + limitNumber(cropEnd - cropStart, 0, viewportBound) / 2);
    }
    function ensureCropOptions(element, options) {
        var elementRectangle = element.getBoundingClientRect();
        var elementBounds = {
            left: elementRectangle.left,
            right: elementRectangle.right,
            top: elementRectangle.top,
            bottom: elementRectangle.bottom,
        };
        var elementMargin = testCafeCore.styleUtils.getElementMargin(element);
        var elementPadding = testCafeCore.styleUtils.getElementPadding(element);
        var elementBordersWidth = testCafeCore.styleUtils.getBordersWidth(element);
        options.originOffset = { x: 0, y: 0 };
        var scrollRight = elementBounds.left + element.scrollWidth + elementBordersWidth.left + elementBordersWidth.right;
        var scrollBottom = elementBounds.top + element.scrollHeight + elementBordersWidth.top + elementBordersWidth.bottom;
        elementBounds.right = Math.max(elementBounds.right, scrollRight);
        elementBounds.bottom = Math.max(elementBounds.bottom, scrollBottom);
        if (!options.includeBorders || !options.includePaddings) {
            options.originOffset.x += elementBordersWidth.left;
            options.originOffset.y += elementBordersWidth.top;
            elementBounds.left += elementBordersWidth.left;
            elementBounds.top += elementBordersWidth.top;
            elementBounds.right -= elementBordersWidth.right;
            elementBounds.bottom -= elementBordersWidth.bottom;
            if (!options.includePaddings) {
                options.originOffset.x += elementPadding.left;
                options.originOffset.y += elementPadding.top;
                elementBounds.left += elementPadding.left;
                elementBounds.top += elementPadding.top;
                elementBounds.right -= elementPadding.right;
                elementBounds.bottom -= elementPadding.bottom;
            }
        }
        else if (options.includeMargins) {
            options.originOffset.x -= elementMargin.left;
            options.originOffset.y -= elementMargin.top;
            elementBounds.left -= elementMargin.left;
            elementBounds.top -= elementMargin.top;
            elementBounds.right += elementMargin.right;
            elementBounds.bottom += elementMargin.bottom;
        }
        elementBounds.width = elementBounds.right - elementBounds.left;
        elementBounds.height = elementBounds.bottom - elementBounds.top;
        var horizontalCropBounds = determineDimensionBounds({ min: options.crop.left, max: options.crop.right, length: options.crop.width }, elementBounds.width);
        var verticalCropBounds = determineDimensionBounds({ min: options.crop.top, max: options.crop.bottom, length: options.crop.height }, elementBounds.height);
        options.crop.left = horizontalCropBounds.min;
        options.crop.right = horizontalCropBounds.max;
        options.crop.width = horizontalCropBounds.length;
        options.crop.top = verticalCropBounds.min;
        options.crop.bottom = verticalCropBounds.max;
        options.crop.height = verticalCropBounds.length;
        if (options.crop.width <= 0 || options.crop.height <= 0)
            throw new InvalidElementScreenshotDimensionsError(options.crop.width, options.crop.height);
        var viewportDimensions = testCafeCore.styleUtils.getViewportDimensions();
        if (elementBounds.width > viewportDimensions.width || elementBounds.height > viewportDimensions.height)
            options.scrollToCenter = true;
        var hasScrollTargetX = typeof options.scrollTargetX === 'number';
        var hasScrollTargetY = typeof options.scrollTargetY === 'number';
        if (!hasScrollTargetX)
            options.scrollTargetX = determineScrollPoint(options.crop.left, options.crop.right, viewportDimensions.width);
        if (!hasScrollTargetY)
            options.scrollTargetY = determineScrollPoint(options.crop.top, options.crop.bottom, viewportDimensions.height);
        var _a = testcafeAutomation.getOffsetOptions(element, options.scrollTargetX, options.scrollTargetY), offsetX = _a.offsetX, offsetY = _a.offsetY;
        options.scrollTargetX = offsetX;
        options.scrollTargetY = offsetY;
        var isScrollTargetXValid = !hasScrollTargetX || options.scrollTargetX >= options.crop.left && options.scrollTargetX <= options.crop.right;
        var isScrollTargetYValid = !hasScrollTargetY || options.scrollTargetY >= options.crop.top && options.scrollTargetY <= options.crop.bottom;
        if (!isScrollTargetXValid || !isScrollTargetYValid)
            throw new ActionInvalidScrollTargetError(isScrollTargetXValid, isScrollTargetYValid);
    }

    var messageSandbox$3 = hammerhead.eventSandbox.message;
    var HIDING_UI_RELAYOUT_DELAY = 500;
    var POSSIBLE_RESIZE_ERROR_DELAY = 200;
    var MANIPULATION_REQUEST_CMD = 'driver|browser-manipulation|request';
    var MANIPULATION_RESPONSE_CMD = 'driver|browser-manipulation|response';
    // Setup cross-iframe interaction
    messageSandbox$3.on(messageSandbox$3.SERVICE_MSG_RECEIVED_EVENT, function (e) {
        if (e.message.cmd === MANIPULATION_REQUEST_CMD) {
            var element = testCafeCore.domUtils.findIframeByWindow(e.source);
            var _a = e.message, command = _a.command, cropDimensions = _a.cropDimensions;
            if (cropDimensions)
                command.options = new ElementScreenshotOptions({ crop: cropDimensions, includePaddings: false });
            var manipulation = new ManipulationExecutor(command);
            manipulation.element = element;
            manipulation
                .execute()
                .then(function (result) { return messageSandbox$3.sendServiceMsg({ cmd: MANIPULATION_RESPONSE_CMD, result: result }, e.source); });
        }
    });
    var ManipulationExecutor = /** @class */ (function () {
        function ManipulationExecutor(command, globalSelectorTimeout, statusBar) {
            this.command = command;
            this.globalSelectorTimeout = globalSelectorTimeout;
            this.statusBar = statusBar;
            this.element = null;
        }
        ManipulationExecutor.prototype._getAbsoluteCropValues = function () {
            var _a = this.element.getBoundingClientRect(), top = _a.top, left = _a.left;
            left += this.command.options.originOffset.x;
            top += this.command.options.originOffset.y;
            var right = left + this.command.options.crop.right;
            var bottom = top + this.command.options.crop.bottom;
            top += this.command.options.crop.top;
            left += this.command.options.crop.left;
            return { top: top, left: left, bottom: bottom, right: right };
        };
        ManipulationExecutor.prototype._createManipulationReadyMessage = function () {
            var dpr = window.devicePixelRatio || 1;
            var message = {
                cmd: TEST_RUN_MESSAGES.readyForBrowserManipulation,
                pageDimensions: {
                    dpr: dpr,
                    innerWidth: window.innerWidth,
                    innerHeight: window.innerHeight,
                    documentWidth: document.documentElement.clientWidth,
                    documentHeight: document.documentElement.clientHeight,
                    bodyWidth: document.body.clientWidth,
                    bodyHeight: document.body.clientHeight,
                },
                disableResending: true,
            };
            if (this.command.type === COMMAND_TYPE.takeElementScreenshot)
                message.cropDimensions = this._getAbsoluteCropValues();
            return message;
        };
        ManipulationExecutor.prototype._runScrollBeforeScreenshot = function () {
            var _this = this;
            return hammerhead.Promise
                .resolve()
                .then(function () {
                if (_this.element || !_this.command.selector)
                    return hammerhead.Promise.resolve();
                var selectorTimeout = _this.command.selector.timeout;
                var specificSelectorTimeout = typeof selectorTimeout === 'number' ? selectorTimeout : _this.globalSelectorTimeout;
                _this.statusBar.showWaitingElementStatus(specificSelectorTimeout);
                return ensureElements([createElementDescriptor(_this.command.selector)], _this.globalSelectorTimeout)
                    .then(function (elements) {
                    _this.statusBar.hideWaitingElementStatus();
                    _this.element = elements[0];
                })
                    .catch(function (error) {
                    _this.statusBar.hideWaitingElementStatus();
                    throw error;
                });
            })
                .then(function () {
                ensureCropOptions(_this.element, _this.command.options);
                var _a = _this.command.options, scrollTargetX = _a.scrollTargetX, scrollTargetY = _a.scrollTargetY, scrollToCenter = _a.scrollToCenter;
                var scrollAutomation = new testcafeAutomation.Scroll(_this.element, new ScrollOptions({
                    offsetX: scrollTargetX,
                    offsetY: scrollTargetY,
                    scrollToCenter: scrollToCenter,
                    skipParentFrames: true,
                }));
                return scrollAutomation.run();
            });
        };
        ManipulationExecutor.prototype._hideUI = function () {
            testCafeUI.hide();
            if (this.command.markData)
                testCafeUI.showScreenshotMark(this.command.markData);
            return testCafeCore.delay(HIDING_UI_RELAYOUT_DELAY);
        };
        ManipulationExecutor.prototype._showUI = function () {
            if (this.command.markData)
                testCafeUI.hideScreenshotMark();
            testCafeUI.show();
        };
        ManipulationExecutor.prototype._requestManipulation = function () {
            if (!isIframeWindow(window))
                return hammerhead.transport.queuedAsyncServiceMsg(this._createManipulationReadyMessage());
            var cropDimensions = this._getAbsoluteCropValues();
            var iframeRequestPromise = testCafeCore.sendRequestToFrame({
                cmd: MANIPULATION_REQUEST_CMD,
                command: this.command,
                cropDimensions: cropDimensions,
            }, MANIPULATION_RESPONSE_CMD, window.parent);
            return iframeRequestPromise
                .then(function (message) {
                if (!message.result)
                    return { result: null };
                var _a = message.result, result = _a.result, executionError = _a.executionError;
                if (executionError)
                    throw executionError;
                return { result: result };
            });
        };
        ManipulationExecutor.prototype._runManipulation = function () {
            var _this = this;
            var manipulationResult = null;
            return hammerhead.Promise
                .resolve()
                .then(function () {
                if (_this.command.type !== COMMAND_TYPE.takeElementScreenshot)
                    return hammerhead.Promise.resolve();
                testCafeCore.scrollController.stopPropagation();
                return _this._runScrollBeforeScreenshot();
            })
                .then(function () {
                if (!isIframeWindow(window))
                    return _this._hideUI();
                return hammerhead.Promise.resolve();
            })
                .then(function () { return _this._requestManipulation(); })
                .then(function (_a) {
                var result = _a.result, error = _a.error;
                if (error)
                    throw error;
                testCafeCore.scrollController.enablePropagation();
                manipulationResult = result;
                if (!isIframeWindow(window))
                    _this._showUI();
                return testCafeCore.delay(POSSIBLE_RESIZE_ERROR_DELAY);
            })
                .then(function () { return new DriverStatus({ isCommandResult: true, result: manipulationResult }); })
                .catch(function (err) {
                testCafeCore.scrollController.enablePropagation();
                return new DriverStatus({ isCommandResult: true, executionError: err });
            });
        };
        ManipulationExecutor.prototype.execute = function () {
            var _this = this;
            var barriersPromise = runWithBarriers(function () { return _this._runManipulation(); }).barriersPromise;
            return barriersPromise;
        };
        return ManipulationExecutor;
    }());
    function executeManipulationCommand (command, globalSelectorTimeout, statusBar) {
        var manipulationExecutor = new ManipulationExecutor(command, globalSelectorTimeout, statusBar);
        return manipulationExecutor.execute();
    }

    function executeNavigateTo(command) {
        return __awaiter(this, void 0, void 0, function () {
            var requestBarrier, error_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        requestBarrier = new testCafeCore.RequestBarrier();
                        hammerhead.navigateTo(command.url, command.forceReload);
                        return [4 /*yield*/, hammerhead.Promise.all([requestBarrier.wait(), testCafeCore.pageUnloadBarrier.wait()])];
                    case 1:
                        _a.sent();
                        return [2 /*return*/, new DriverStatus({ isCommandResult: true })];
                    case 2:
                        error_1 = _a.sent();
                        return [2 /*return*/, new DriverStatus({ isCommandResult: true, executionError: error_1 })];
                    case 3: return [2 /*return*/];
                }
            });
        });
    }

    function getExecutorResultDriverStatus(executor) {
        return executor
            .getResult()
            .then(function (result) { return new DriverStatus({
            isCommandResult: true,
            result: executor.encodeResult(result),
        }); })
            .catch(function (err) { return new DriverStatus({
            isCommandResult: true,
            executionError: err,
        }); });
    }

    function getResult(command, globalTimeout, startTime, createNotFoundError, createIsInvisibleError, statusBar) {
        var selectorExecutor = new SelectorExecutor(command, globalTimeout, startTime, createNotFoundError, createIsInvisibleError);
        statusBar.showWaitingElementStatus(selectorExecutor.timeout);
        return selectorExecutor.getResult()
            .then(function (el) {
            return statusBar.hideWaitingElementStatus(!!el)
                .then(function () { return el; });
        })
            .catch(function (err) {
            return statusBar.hideWaitingElementStatus(false)
                .then(function () {
                throw err;
            });
        });
    }
    function getResultDriverStatus(command, globalTimeout, startTime, createNotFoundError, createIsInvisibleError, statusBar) {
        var selectorExecutor = new SelectorExecutor(command, globalTimeout, startTime, createNotFoundError, createIsInvisibleError);
        statusBar.showWaitingElementStatus(selectorExecutor.timeout);
        return getExecutorResultDriverStatus(selectorExecutor)
            .then(function (status) {
            return statusBar.hideWaitingElementStatus(!!status.result)
                .then(function () { return status; });
        });
    }

    var Promise$6 = hammerhead__default.Promise;
    function executeChildWindowDriverLinkSelector(selector, childWindowLinks) {
        if (typeof selector === 'string') {
            var foundChildWindowDriverLink = testCafeCore.arrayUtils.find(childWindowLinks, function (link) { return link.windowId === selector; });
            if (!foundChildWindowDriverLink) {
                var error = new ChildWindowNotFoundError();
                return Promise$6.reject(error);
            }
            // NOTE: We cannot pass the driver window of the found child window driver link
            // because the current Promise implementation checks the type of the value passed to the 'resolve' function.
            // It causes an unhandled JavaScript error on accessing to cross-domain iframe.
            return Promise$6.resolve(foundChildWindowDriverLink);
        }
        // TODO:  Query url and title properties of the all driverLinks' windows
        return Promise$6.resolve(null);
    }

    var ChildWindowDriverLink = /** @class */ (function () {
        function ChildWindowDriverLink(driverWindow, windowId) {
            this.driverWindow = driverWindow;
            this.windowId = windowId;
        }
        ChildWindowDriverLink.prototype.setAsMaster = function (finalizePendingCommand) {
            var msg = new SetAsMasterMessage(finalizePendingCommand);
            return sendMessageToDriver(msg, this.driverWindow, WAIT_FOR_WINDOW_DRIVER_RESPONSE_TIMEOUT, CannotSwitchToWindowError);
        };
        ChildWindowDriverLink.prototype.closeAllChildWindows = function () {
            var msg = new CloseAllChildWindowsMessage();
            return sendMessageToDriver(msg, this.driverWindow, WAIT_FOR_WINDOW_DRIVER_RESPONSE_TIMEOUT, CloseChildWindowError);
        };
        ChildWindowDriverLink.prototype.findChildWindows = function (options, MessageCtor) {
            var msg = new MessageCtor(options);
            return sendMessageToDriver(msg, this.driverWindow, WAIT_FOR_WINDOW_DRIVER_RESPONSE_TIMEOUT, CannotSwitchToWindowError);
        };
        ChildWindowDriverLink.prototype.startToRestore = function () {
            var msg = new StartToRestoreChildLinkMessage();
            return sendMessageToDriver(msg, this.driverWindow, WAIT_FOR_WINDOW_DRIVER_RESPONSE_TIMEOUT, CannotSwitchToWindowError);
        };
        return ChildWindowDriverLink;
    }());

    var ParentWindowDriverLink = /** @class */ (function () {
        function ParentWindowDriverLink(currentDriverWindow) {
            this.currentDriverWindow = currentDriverWindow;
        }
        ParentWindowDriverLink.prototype._getTopOpenedWindow = function (wnd) {
            var topOpened = wnd;
            while (topOpened.opener)
                topOpened = topOpened.opener;
            return topOpened.top;
        };
        ParentWindowDriverLink.prototype._setAsMaster = function (wnd, finalizePendingCommand) {
            var msg = new SetAsMasterMessage(finalizePendingCommand);
            return sendMessageToDriver(msg, wnd, WAIT_FOR_WINDOW_DRIVER_RESPONSE_TIMEOUT, CannotSwitchToWindowError);
        };
        ParentWindowDriverLink.prototype.getTopOpenedWindow = function () {
            return this._getTopOpenedWindow(this.currentDriverWindow);
        };
        ParentWindowDriverLink.prototype.setTopOpenedWindowAsMaster = function () {
            var wnd = this._getTopOpenedWindow(this.currentDriverWindow);
            return this._setAsMaster(wnd);
        };
        ParentWindowDriverLink.prototype.setParentWindowAsMaster = function (opts) {
            if (opts === void 0) { opts = {}; }
            var wnd = this.currentDriverWindow.opener;
            return this._setAsMaster(wnd, opts.finalizePendingCommand);
        };
        ParentWindowDriverLink.prototype.restoreChild = function (windowId) {
            return __awaiter(this, void 0, void 0, function () {
                var msg, wnd;
                return __generator(this, function (_a) {
                    msg = new RestoreChildLinkMessage(windowId);
                    wnd = this.currentDriverWindow.opener;
                    sendMessageToDriver(msg, wnd, WAIT_FOR_WINDOW_DRIVER_RESPONSE_TIMEOUT, CannotSwitchToWindowError);
                    return [2 /*return*/];
                });
            });
        };
        return ParentWindowDriverLink;
    }());

    var DriverRole = {
        master: 'master',
        replica: 'replica',
    };

    // @ts-ignore
    var initializer = {
        isProxyless: false,
        nativeMethods: hammerhead.nativeMethods,
        PromiseCtor: hammerhead.Promise,
        delay: testCafeCore.delay,
        isShadowRoot: testCafeCore.domUtils.isShadowRoot,
        isDomElement: testCafeCore.domUtils.isDomElement,
        isTextNode: testCafeCore.domUtils.isTextNode,
        isOptionElement: testCafeCore.domUtils.isOptionElement,
        getTagName: testCafeCore.domUtils.getTagName,
        isOptionElementVisible: testCafeUI.selectElement.isOptionElementVisible,
        isElementVisible: testCafeCore.positionUtils.isElementVisible,
        getActiveElement: testCafeCore.domUtils.getActiveElement,
    };

    var settings = hammerhead__default.settings;
    var transport = hammerhead__default.transport;
    var Promise$7 = hammerhead__default.Promise;
    var messageSandbox$4 = hammerhead__default.eventSandbox.message;
    var storages = hammerhead__default.storages;
    var nativeMethods$7 = hammerhead__default.nativeMethods;
    var DateCtor$2 = nativeMethods$7.date;
    var listeners = hammerhead__default.eventSandbox.listeners;
    var TEST_DONE_SENT_FLAG = 'testcafe|driver|test-done-sent-flag';
    var PENDING_STATUS = 'testcafe|driver|pending-status';
    var EXECUTING_CLIENT_FUNCTION_DESCRIPTOR = 'testcafe|driver|executing-client-function-descriptor';
    var SELECTOR_EXECUTION_START_TIME = 'testcafe|driver|selector-execution-start-time';
    var PENDING_PAGE_ERROR = 'testcafe|driver|pending-page-error';
    var ACTIVE_IFRAME_SELECTOR = 'testcafe|driver|active-iframe-selector';
    var TEST_SPEED = 'testcafe|driver|test-speed';
    var ASSERTION_RETRIES_TIMEOUT = 'testcafe|driver|assertion-retries-timeout';
    var ASSERTION_RETRIES_START_TIME = 'testcafe|driver|assertion-retries-start-time';
    var CONSOLE_MESSAGES = 'testcafe|driver|console-messages';
    var PENDING_CHILD_WINDOW_COUNT = 'testcafe|driver|pending-child-window-count';
    var ACTION_IFRAME_ERROR_CTORS = {
        NotLoadedError: ActionIframeIsNotLoadedError,
        NotFoundError: ActionElementNotFoundError,
        IsInvisibleError: ActionElementIsInvisibleError,
    };
    var CURRENT_IFRAME_ERROR_CTORS = {
        NotLoadedError: CurrentIframeIsNotLoadedError,
        NotFoundError: CurrentIframeNotFoundError,
        IsInvisibleError: CurrentIframeIsInvisibleError,
    };
    var COMMAND_EXECUTION_MAX_TIMEOUT = Math.pow(2, 31) - 1;
    var EMPTY_COMMAND_EVENT_WAIT_TIMEOUT = 30 * 1000;
    var CHILD_WINDOW_CLOSED_EVENT_TIMEOUT = 2000;
    var RESTORE_CHILD_WINDOWS_TIMEOUT = 30 * 1000;
    var STATUS_WITH_COMMAND_RESULT_EVENT = 'status-with-command-result-event';
    var EMPTY_COMMAND_EVENT = 'empty-command-event';
    var CHILD_WINDOW_CLOSED_EVENT = 'child-window-closed';
    var Driver = /** @class */ (function (_super) {
        __extends(Driver, _super);
        function Driver(testRunId, communicationUrls, runInfo, options) {
            var _this = _super.call(this) || this;
            _this.COMMAND_EXECUTING_FLAG = 'testcafe|driver|command-executing-flag';
            _this.EXECUTING_IN_IFRAME_FLAG = 'testcafe|driver|executing-in-iframe-flag';
            _this.PENDING_WINDOW_SWITCHING_FLAG = 'testcafe|driver|pending-window-switching-flag';
            _this.WINDOW_COMMAND_API_CALL_FLAG = 'testcafe|driver|window-command-api-flag';
            _this.testRunId = testRunId;
            _this.heartbeatUrl = communicationUrls.heartbeat;
            _this.browserStatusUrl = communicationUrls.status;
            _this.browserStatusDoneUrl = communicationUrls.statusDone;
            _this.browserActiveWindowId = communicationUrls.activeWindowId;
            _this.userAgent = runInfo.userAgent;
            _this.fixtureName = runInfo.fixtureName;
            _this.testName = runInfo.testName;
            _this.selectorTimeout = options.selectorTimeout;
            _this.pageLoadTimeout = options.pageLoadTimeout;
            _this.childWindowReadyTimeout = options.childWindowReadyTimeout;
            _this.initialSpeed = options.speed;
            _this.skipJsErrors = options.skipJsErrors;
            _this.dialogHandler = options.dialogHandler;
            _this.canUseDefaultWindowActions = options.canUseDefaultWindowActions;
            _this.isFirstPageLoad = settings.get().isFirstPageLoad;
            initializeAdapter(initializer);
            _this.customCommandHandlers = {};
            _this.contextStorage = null;
            _this.nativeDialogsTracker = null;
            _this.childIframeDriverLinks = [];
            _this.activeChildIframeDriverLink = null;
            _this.childWindowDriverLinks = [];
            _this.parentWindowDriverLink = null;
            _this.statusBar = null;
            _this.windowId = _this._getCurrentWindowId();
            _this.role = DriverRole.replica;
            _this.setAsMasterInProgress = false;
            _this.checkClosedChildWindowIntervalId = null;
            _this.pageInitialRequestBarrier = new testCafeCore.RequestBarrier();
            _this.readyPromise = _this._getReadyPromise();
            _this._initChildDriverListening();
            testCafeCore.pageUnloadBarrier.init();
            testCafeCore.preventRealEvents();
            hammerhead__default.on(hammerhead__default.EVENTS.uncaughtJsError, function (err) { return _this._onJsError(err); });
            hammerhead__default.on(hammerhead__default.EVENTS.unhandledRejection, function (err) { return _this._onJsError(err); });
            hammerhead__default.on(hammerhead__default.EVENTS.consoleMethCalled, function (e) { return _this._onConsoleMessage(e); });
            hammerhead__default.on(hammerhead__default.EVENTS.beforeFormSubmit, function (e) { return _this._onFormSubmit(e); });
            hammerhead__default.on(hammerhead__default.EVENTS.windowOpened, function (e) { return _this._onChildWindowOpened(e); });
            _this.setCustomCommandHandlers(COMMAND_TYPE.unlockPage, function () { return _this._unlockPageAfterTestIsDone(); });
            _this.setCustomCommandHandlers(COMMAND_TYPE.getActiveElement, function () { return _this._getActiveElement(); });
            // NOTE: initiate the child links restoring process before the window is reloaded
            listeners.addInternalEventBeforeListener(window, ['beforeunload'], function () {
                _this._sendStartToRestoreCommand();
            });
            _this.replicator = createReplicator([new SelectorNodeTransform()]);
            return _this;
        }
        Driver.prototype._isOpenedInIframe = function () {
            var opener = window.opener;
            return opener && opener.top && opener.top !== opener;
        };
        Object.defineProperty(Driver.prototype, "speed", {
            get: function () {
                return this.contextStorage.getItem(TEST_SPEED);
            },
            set: function (val) {
                this.contextStorage.setItem(TEST_SPEED, val);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Driver.prototype, "consoleMessages", {
            get: function () {
                return new ClientBrowserConsoleMessages(this.contextStorage.getItem(CONSOLE_MESSAGES));
            },
            set: function (messages) {
                return this.contextStorage.setItem(CONSOLE_MESSAGES, messages ? messages.getCopy() : null);
            },
            enumerable: false,
            configurable: true
        });
        Driver.prototype._getReadyPromise = function () {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, testCafeCore.eventUtils.documentReady(this.pageLoadTimeout)];
                        case 1:
                            _a.sent();
                            return [4 /*yield*/, this.pageInitialRequestBarrier.wait(true)];
                        case 2:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            });
        };
        Driver.prototype._hasPendingActionFlags = function (contextStorage) {
            return contextStorage.getItem(this.COMMAND_EXECUTING_FLAG) ||
                contextStorage.getItem(this.EXECUTING_IN_IFRAME_FLAG);
        };
        Driver.prototype._getCurrentWindowId = function () {
            var currentUrl = window.location.toString();
            var parsedProxyUrl = hammerhead__default.utils.url.parseProxyUrl(currentUrl);
            return parsedProxyUrl && parsedProxyUrl.windowId || null;
        };
        // Error handling
        Driver.prototype._onJsError = function (err) {
            // NOTE: we should not send any message to the server if we've
            // sent the 'test-done' message but haven't got the response.
            if (this.skipJsErrors || this.contextStorage.getItem(TEST_DONE_SENT_FLAG))
                return Promise$7.resolve();
            var error = new UncaughtErrorOnPage(err.stack, err.pageUrl);
            if (!this.contextStorage.getItem(PENDING_PAGE_ERROR))
                this.contextStorage.setItem(PENDING_PAGE_ERROR, error);
            return null;
        };
        Driver.prototype._unlockPageAfterTestIsDone = function () {
            testCafeCore.disableRealEventsPreventing();
            return Promise$7.resolve();
        };
        Driver.prototype._getActiveElement = function () {
            return __awaiter(this, void 0, void 0, function () {
                var activeElement;
                return __generator(this, function (_a) {
                    activeElement = testCafeCore.domUtils.getActiveElement();
                    return [2 /*return*/, this.replicator.encode(activeElement)];
                });
            });
        };
        Driver.prototype._failIfClientCodeExecutionIsInterrupted = function () {
            // NOTE: ClientFunction should be used primarily for observation. We raise
            // an error if the page was reloaded during ClientFunction execution.
            var executingClientFnDescriptor = this.contextStorage.getItem(EXECUTING_CLIENT_FUNCTION_DESCRIPTOR);
            if (executingClientFnDescriptor) {
                this._onReady(new DriverStatus({
                    isCommandResult: true,
                    executionError: new ClientFunctionExecutionInterruptionError(executingClientFnDescriptor.instantiationCallsiteName),
                }));
                return true;
            }
            return false;
        };
        Driver.prototype.onCustomClientScriptError = function (err, moduleName) {
            var error = moduleName
                ? new UncaughtErrorInCustomClientScriptLoadedFromModule(err, moduleName)
                : new UncaughtErrorInCustomClientScriptCode(err);
            if (!this.contextStorage.getItem(PENDING_PAGE_ERROR))
                this.contextStorage.setItem(PENDING_PAGE_ERROR, error);
        };
        Driver.prototype._addChildWindowDriverLink = function (e) {
            var childWindowDriverLink = new ChildWindowDriverLink(e.window, e.windowId);
            this.childWindowDriverLinks.push(childWindowDriverLink);
            this._ensureClosedChildWindowWatcher();
        };
        Driver.prototype._ensureClosedChildWindowWatcher = function () {
            var _this = this;
            if (this.checkClosedChildWindowIntervalId)
                return;
            this.checkClosedChildWindowIntervalId = nativeMethods$7.setInterval.call(window, function () {
                var firstClosedChildWindowDriverLink = testCafeCore.arrayUtils.find(_this.childWindowDriverLinks, function (childWindowDriverLink) { return childWindowDriverLink.driverWindow.closed; });
                if (!firstClosedChildWindowDriverLink)
                    return;
                _this.emit(CHILD_WINDOW_CLOSED_EVENT);
                testCafeCore.arrayUtils.remove(_this.childWindowDriverLinks, firstClosedChildWindowDriverLink);
                if (!firstClosedChildWindowDriverLink.ignoreMasterSwitching)
                    _this._setCurrentWindowAsMaster();
                if (!_this.childWindowDriverLinks.length) {
                    nativeMethods$7.clearInterval.call(window, _this.checkClosedChildWindowIntervalId);
                    delete _this.checkClosedChildWindowIntervalId;
                }
            }, CHECK_CHILD_WINDOW_CLOSED_INTERVAL);
        };
        Driver.prototype._setAsMasterInProgressOrCompleted = function () {
            return this.setAsMasterInProgress || this.role === DriverRole.master;
        };
        Driver.prototype._setCurrentWindowAsMaster = function () {
            var _this = this;
            if (this._setAsMasterInProgressOrCompleted())
                return;
            this.setAsMasterInProgress = true;
            this._clearActiveChildIframeInfo();
            Promise$7.resolve()
                .then(function () {
                return testCafeCore.browser.setActiveWindowId(_this.browserActiveWindowId, hammerhead__default.createNativeXHR, _this.windowId);
            })
                .then(function () {
                _this._startInternal({
                    finalizePendingCommand: true,
                    isFirstRequestAfterWindowSwitching: true,
                });
                _this.setAsMasterInProgress = false;
            })
                .catch(function () {
                _this._onReady(new DriverStatus({
                    isCommandResult: true,
                    executionError: new CannotSwitchToWindowError(),
                }));
            });
        };
        Driver.prototype._onChildWindowOpened = function (e) {
            this._addChildWindowDriverLink(e);
            this._switchToChildWindow(e.windowId);
        };
        Driver.prototype._sendStartToRestoreCommand = function () {
            if (!this.contextStorage)
                return;
            // NOTE: the situation is possible when the child window responds before the parent window is reloaded,
            // so we should not respond to the child window if the parent window is not reloaded
            this._stopRespondToChildren = true;
            // NOTE: save the child window count that we expect to restore after the parent window is reloaded
            this.contextStorage.setItem(PENDING_CHILD_WINDOW_COUNT, this.childWindowDriverLinks.length);
            for (var _i = 0, _a = this.childWindowDriverLinks; _i < _a.length; _i++) {
                var childLink = _a[_i];
                childLink.startToRestore();
            }
        };
        // HACK: For https://github.com/DevExpress/testcafe/issues/3560
        // We have to cancel every form submit after a test is done
        // to prevent requests to a closed session
        Driver.prototype._onFormSubmit = function (e) {
            // NOTE: We need to refactor this code to avoid the undefined value in contextStorage
            // https://github.com/DevExpress/testcafe/issues/4360
            if (this.contextStorage && this.contextStorage.getItem(TEST_DONE_SENT_FLAG))
                e.preventSubmit = true;
        };
        // Console messages
        Driver.prototype._onConsoleMessage = function (_a) {
            var meth = _a.meth, line = _a.line;
            var messages = this.consoleMessages;
            messages.addMessage(meth, line, this.windowId);
            this.consoleMessages = messages;
        };
        // Status
        Driver.prototype._addPendingErrorToStatus = function (status) {
            var pendingPageError = this.contextStorage.getItem(PENDING_PAGE_ERROR);
            if (pendingPageError) {
                this.contextStorage.setItem(PENDING_PAGE_ERROR, null);
                status.pageError = pendingPageError;
            }
        };
        Driver.prototype._addUnexpectedDialogErrorToStatus = function (status) {
            var dialogError = this.nativeDialogsTracker.getUnexpectedDialogError();
            status.pageError = status.pageError || dialogError;
        };
        Driver.prototype._addConsoleMessagesToStatus = function (status) {
            status.consoleMessages = this.consoleMessages;
            this.consoleMessages = null;
        };
        Driver.prototype._addPendingWindowSwitchingStateToStatus = function (status) {
            status.isPendingWindowSwitching = !!this.contextStorage.getItem(this.PENDING_WINDOW_SWITCHING_FLAG);
        };
        Driver.prototype._sendStatusRequest = function (status) {
            var statusRequestOptions = {
                cmd: TEST_RUN_MESSAGES.ready,
                status: status,
                disableResending: true,
                allowRejecting: true,
            };
            var requestAttempt = function () { return testCafeCore.getTimeLimitedPromise(transport.asyncServiceMsg(statusRequestOptions), SEND_STATUS_REQUEST_TIME_LIMIT); };
            var retryRequest = function () { return testCafeCore.delay(SEND_STATUS_REQUEST_RETRY_DELAY).then(requestAttempt); };
            var statusPromise = requestAttempt();
            for (var i = 0; i < SEND_STATUS_REQUEST_RETRY_COUNT; i++)
                statusPromise = statusPromise.catch(retryRequest);
            return statusPromise;
        };
        Driver.prototype._sendStatus = function (status) {
            var _this = this;
            // NOTE: We should not modify the status if it is resent after
            // the page load because the server has cached the response
            if (!status.resent) {
                this._addPendingErrorToStatus(status);
                this._addUnexpectedDialogErrorToStatus(status);
                this._addConsoleMessagesToStatus(status);
                this._addPendingWindowSwitchingStateToStatus(status);
            }
            this.contextStorage.setItem(PENDING_STATUS, status);
            var readyCommandResponse = null;
            // NOTE: postpone status sending if the page is unloading
            return testCafeCore.pageUnloadBarrier
                .wait(0)
                .then(function () { return _this._sendStatusRequest(status); })
                //NOTE: do not execute the next command if the page is unloading
                .then(function (res) {
                readyCommandResponse = res;
                return testCafeCore.pageUnloadBarrier.wait(0);
            })
                .then(function () {
                _this.contextStorage.setItem(PENDING_STATUS, null);
                return readyCommandResponse;
            });
        };
        // Iframes and child windows interaction
        Driver.prototype._addChildIframeDriverLink = function (id, driverWindow) {
            var childIframeDriverLink = this._getChildIframeDriverLinkByWindow(driverWindow);
            if (!childIframeDriverLink) {
                var driverId = this.testRunId + "-" + generateId();
                childIframeDriverLink = new ChildIframeDriverLink(driverWindow, driverId);
                this.childIframeDriverLinks.push(childIframeDriverLink);
            }
            childIframeDriverLink.sendConfirmationMessage(id);
        };
        Driver.prototype._getTargetWindowNotFoundResult = function (errCode, errMsg) {
            return Promise$7.resolve({
                success: false,
                errCode: errCode,
                errMsg: errMsg,
            });
        };
        Driver.prototype._getChildWindowValidateResult = function (arr) {
            var success = arr.find(function (item) { return item.result.success; });
            if (success)
                return success.result;
            var errItem = arr.find(function (item) {
                return item.result.errCode === TEST_RUN_ERRORS.cannotCloseWindowWithChildrenError ||
                    item.result.errCode === TEST_RUN_ERRORS.cannotCloseWindowWithoutParent;
            });
            if (!errItem)
                errItem = arr.find(function (item) { return !!item.result.errCode; });
            return errItem ? { errCode: errItem.result.errCode } : void 0;
        };
        Driver.prototype._handleWindowValidation = function (msg, wnd, getWindowFoundResult, WindowValidationMessageCtor) {
            return __awaiter(this, void 0, void 0, function () {
                var result;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this._validateWindow(msg, wnd, getWindowFoundResult, WindowValidationMessageCtor)];
                        case 1:
                            result = _a.sent();
                            sendConfirmationMessage({
                                requestMsgId: msg.id,
                                window: wnd,
                                result: result,
                            });
                            return [2 /*return*/];
                    }
                });
            });
        };
        Driver.prototype._getWindowInfo = function () {
            var parsedUrl = hammerhead__default.utils.url.parseProxyUrl(window.location.toString());
            return {
                id: this.windowId,
                title: document.title,
                url: parsedUrl.destUrl,
            };
        };
        Driver.prototype._isTargetWindow = function (msg) {
            return msg.windowId === this.windowId;
        };
        Driver.prototype._validateWindow = function (msg, wnd, getWindowFoundResult, WindowValidationMessageCtor) {
            return __awaiter(this, void 0, void 0, function () {
                var windowExists, searchQueries, searchResults;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            windowExists = this._isTargetWindow(msg);
                            if (windowExists)
                                return [2 /*return*/, getWindowFoundResult()];
                            if (!this.childWindowDriverLinks.length)
                                return [2 /*return*/, this._getTargetWindowNotFoundResult(TEST_RUN_ERRORS.targetWindowNotFoundError)];
                            searchQueries = this.childWindowDriverLinks.map(function (childWindowDriverLink) {
                                return childWindowDriverLink.findChildWindows(msg, WindowValidationMessageCtor);
                            });
                            return [4 /*yield*/, Promise$7.all(searchQueries)];
                        case 1:
                            searchResults = _a.sent();
                            return [2 /*return*/, this._getChildWindowValidateResult(searchResults)];
                    }
                });
            });
        };
        Driver._createWindowValidationError = function (_a) {
            var errCode = _a.errCode;
            if (errCode === TEST_RUN_ERRORS.cannotCloseWindowWithChildrenError)
                return new CannotCloseWindowWithChildrenError();
            if (errCode === TEST_RUN_ERRORS.cannotCloseWindowWithoutParent)
                return new CannotCloseWindowWithoutParentError();
            return new WindowNotFoundError();
        };
        Driver.prototype._getCloseWindowFoundResult = function () {
            if (!this.parentWindowDriverLink) {
                return Promise$7.resolve({
                    success: false,
                    errCode: TEST_RUN_ERRORS.cannotCloseWindowWithoutParent,
                });
            }
            if (this.childWindowDriverLinks.length) {
                return Promise$7.resolve({
                    success: false,
                    errCode: TEST_RUN_ERRORS.cannotCloseWindowWithChildrenError,
                });
            }
            return Promise$7.resolve({ success: true });
        };
        Driver.prototype._handleCloseWindowValidation = function (msg, wnd) {
            var _this = this;
            var getWindowFoundResult = function () {
                return _this._getCloseWindowFoundResult();
            };
            return this._handleWindowValidation(msg, wnd, getWindowFoundResult, CloseWindowValidationMessage);
        };
        Driver.prototype._handleSwitchToWindowValidation = function (msg, wnd) {
            var getWindowFoundResult = function () {
                return Promise$7.resolve({ success: true });
            };
            return this._handleWindowValidation(msg, wnd, getWindowFoundResult, SwitchToWindowValidationMessage);
        };
        Driver.prototype._handleCloseWindow = function (msg, wnd) {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this._closeWindow(msg, wnd)];
                        case 1:
                            _a.sent();
                            sendConfirmationMessage({
                                requestMsgId: msg.id,
                                window: wnd,
                            });
                            return [2 /*return*/];
                    }
                });
            });
        };
        Driver.prototype._closeWindowAndWait = function (childWindowToClose, msg) {
            var waitWindowForClose = this._createWaitForEventPromise(CHILD_WINDOW_CLOSED_EVENT, CHILD_WINDOW_CLOSED_EVENT_TIMEOUT);
            childWindowToClose.ignoreMasterSwitching = !msg.isCurrentWindow;
            childWindowToClose.driverWindow.close();
            return waitWindowForClose;
        };
        Driver.prototype._closeWindow = function (msg) {
            if (!this.childWindowDriverLinks.length)
                return Promise$7.resolve();
            var childWindowToClose = this.childWindowDriverLinks.find(function (link) { return link.windowId === msg.windowId; });
            if (childWindowToClose)
                return this._closeWindowAndWait(childWindowToClose, msg);
            var searchQueries = this.childWindowDriverLinks.map(function (childWindowDriverLink) {
                return childWindowDriverLink.findChildWindows(msg, CloseWindowCommandMessage);
            });
            return Promise$7.all(searchQueries);
        };
        Driver.prototype._getWindows = function () {
            return __awaiter(this, void 0, void 0, function () {
                var searchQueries, searchResults, result, _i, searchResults_1, item;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!this.childWindowDriverLinks.length)
                                return [2 /*return*/, [this._getWindowInfo()]];
                            searchQueries = this.childWindowDriverLinks.map(function (childWindowDriverLink) {
                                return childWindowDriverLink.findChildWindows({}, GetWindowsMessage);
                            });
                            return [4 /*yield*/, Promise$7.all(searchQueries)];
                        case 1:
                            searchResults = _a.sent();
                            result = [this._getWindowInfo()];
                            for (_i = 0, searchResults_1 = searchResults; _i < searchResults_1.length; _i++) {
                                item = searchResults_1[_i];
                                if (Array.isArray(item.result))
                                    result = result.concat(item.result);
                            }
                            return [2 /*return*/, result];
                    }
                });
            });
        };
        Driver.prototype._handleGetWindows = function (msg, wnd) {
            return __awaiter(this, void 0, void 0, function () {
                var result;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this._getWindows(msg, wnd)];
                        case 1:
                            result = _a.sent();
                            sendConfirmationMessage({
                                requestMsgId: msg.id,
                                window: wnd,
                                result: result,
                            });
                            return [2 /*return*/];
                    }
                });
            });
        };
        Driver.prototype._handleSwitchToWindow = function (msg, wnd) {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this._switchToWindow(msg)];
                        case 1:
                            _a.sent();
                            sendConfirmationMessage({
                                requestMsgId: msg.id,
                                window: wnd,
                            });
                            return [2 /*return*/];
                    }
                });
            });
        };
        Driver.prototype._switchToWindow = function (msg) {
            var _this = this;
            if (this._isTargetWindow(msg)) {
                return Promise$7.resolve()
                    .then(function () {
                    _this._setCurrentWindowAsMaster();
                });
            }
            if (!this.childWindowDriverLinks.length)
                return Promise$7.resolve();
            return Promise$7.all(this.childWindowDriverLinks.map(function (childWindowDriverLink) {
                return childWindowDriverLink.findChildWindows(msg, SwitchToWindowCommandMessage);
            }));
        };
        Driver.prototype._handleSetAsMasterMessage = function (msg, wnd) {
            var _this = this;
            // NOTE: The 'setAsMaster' message can be send a few times because
            // the 'sendMessageToDriver' function resend messages if the message confirmation is not received in 1 sec.
            // This message can be send even after driver is started.
            if (this._setAsMasterInProgressOrCompleted())
                return;
            this.setAsMasterInProgress = true;
            sendConfirmationMessage({
                requestMsgId: msg.id,
                window: wnd,
            });
            Promise$7.resolve()
                .then(function () {
                return testCafeCore.browser.setActiveWindowId(_this.browserActiveWindowId, hammerhead__default.createNativeXHR, _this.windowId);
            })
                .then(function () {
                _this._startInternal({
                    finalizePendingCommand: msg.finalizePendingCommand,
                    result: { id: _this.windowId },
                });
                _this.setAsMasterInProgress = false;
            })
                .catch(function () {
                _this._onReady(new DriverStatus({
                    isCommandResult: true,
                    executionError: new CannotSwitchToWindowError(),
                }));
            });
        };
        Driver.prototype._handleCloseAllWindowsMessage = function (msg, wnd) {
            var _this = this;
            this._closeAllChildWindows()
                .then(function () {
                sendConfirmationMessage({
                    requestMsgId: msg.id,
                    window: wnd,
                });
            })
                .catch(function () {
                _this._onReady(new DriverStatus({
                    isCommandResult: true,
                    executionError: new CloseChildWindowError(),
                }));
            });
        };
        Driver.prototype._handleStartToRestoreChildLinkMessage = function () {
            this.parentWindowDriverLink.restoreChild(this._getCurrentWindowId());
        };
        Driver.prototype._handleHasPendingActionFlags = function (msg, window) {
            var result = this._hasPendingActionFlags(this.contextStorage);
            sendConfirmationMessage({
                requestMsgId: msg.id,
                window: window,
                result: result,
            });
        };
        Driver.prototype._handleRestoreChildLink = function (msg, wnd) {
            if (this._stopRespondToChildren)
                return;
            this._addChildWindowDriverLink({ window: wnd, windowId: msg.windowId });
            var allChildWindowLinksRestored = this.childWindowDriverLinks.length === this.contextStorage.getItem(PENDING_CHILD_WINDOW_COUNT);
            if (allChildWindowLinksRestored && this._restoreChildWindowsPromiseResolver) {
                this._restoreChildWindowsPromiseResolver();
                delete this._restoreChildWindowsPromiseResolver;
                this.contextStorage.setItem(PENDING_CHILD_WINDOW_COUNT, 0);
            }
            sendConfirmationMessage({
                requestMsgId: msg.id,
                window: wnd,
            });
        };
        Driver.prototype._handleChildWindowIsOpenedInIFrame = function () {
            var _this = this;
            // NOTE: when the child window is opened in iframe we need to wait until the
            // child window is fully loaded
            this._pendingChildWindowInIFrame = new Promise$7(function (resolve) {
                _this._resolvePendingChildWindowInIframe = resolve;
            });
        };
        Driver.prototype._handleChildWindowIsLoadedInIFrame = function (msg, wnd) {
            sendConfirmationMessage({
                requestMsgId: msg.id,
                window: wnd,
            });
            this._resolvePendingChildWindowInIframe();
            var childWindowDriverLinkExists = !!this.childWindowDriverLinks.find(function (link) { return link.windowId === msg.windowId; });
            if (!childWindowDriverLinkExists)
                this._onChildWindowOpened({ window: wnd, windowId: msg.windowId });
        };
        Driver.prototype._initChildDriverListening = function () {
            var _this = this;
            messageSandbox$4.on(messageSandbox$4.SERVICE_MSG_RECEIVED_EVENT, function (e) {
                var msg = e.message;
                var window = e.source;
                switch (msg.type) {
                    case TYPE.establishConnection:
                        _this._addChildIframeDriverLink(msg.id, window);
                        break;
                    case TYPE.childWindowIsOpenedInIFrame:
                        _this._handleChildWindowIsOpenedInIFrame(msg, window);
                        break;
                    case TYPE.childWindowIsLoadedInIFrame:
                        _this._handleChildWindowIsLoadedInIFrame(msg, window);
                        break;
                    case TYPE.setAsMaster:
                        _this._handleSetAsMasterMessage(msg, window);
                        break;
                    case TYPE.switchToWindow:
                        _this._handleSwitchToWindow(msg, window);
                        break;
                    case TYPE.closeWindow:
                        _this._handleCloseWindow(msg, window);
                        break;
                    case TYPE.switchToWindowValidation:
                        _this._handleSwitchToWindowValidation(msg, window);
                        break;
                    case TYPE.closeWindowValidation:
                        _this._handleCloseWindowValidation(msg, window);
                        break;
                    case TYPE.getWindows:
                        _this._handleGetWindows(msg, window);
                        break;
                    case TYPE.closeAllChildWindows:
                        _this._handleCloseAllWindowsMessage(msg, window);
                        break;
                    case TYPE.startToRestoreChildLink:
                        _this._handleStartToRestoreChildLinkMessage();
                        break;
                    case TYPE.hasPendingActionFlags:
                        _this._handleHasPendingActionFlags(msg, window);
                        break;
                    case TYPE.restoreChildLink:
                        _this._handleRestoreChildLink(msg, window);
                }
            });
        };
        Driver.prototype._getChildIframeDriverLinkByWindow = function (driverWindow) {
            return testCafeCore.arrayUtils.find(this.childIframeDriverLinks, function (link) { return link.driverWindow === driverWindow; });
        };
        Driver.prototype._getChildWindowDriverLinkByWindow = function (childDriverWindow) {
            return testCafeCore.arrayUtils.find(this.childWindowDriverLinks, function (link) { return link.driverWindow === childDriverWindow; });
        };
        Driver.prototype._runInActiveIframe = function (command) {
            var _this = this;
            var runningChain = Promise$7.resolve();
            var activeIframeSelector = this.contextStorage.getItem(ACTIVE_IFRAME_SELECTOR);
            // NOTE: if the page was reloaded we restore the active child driver link via the iframe selector
            if (!this.activeChildIframeDriverLink && activeIframeSelector)
                runningChain = this._switchToIframe(activeIframeSelector, CURRENT_IFRAME_ERROR_CTORS);
            runningChain
                .then(function () {
                _this.contextStorage.setItem(_this.EXECUTING_IN_IFRAME_FLAG, true);
                return _this.activeChildIframeDriverLink.executeCommand(command, _this.speed);
            })
                .then(function (status) { return _this._onCommandExecutedInIframe(status); })
                .catch(function (err) { return _this._onCommandExecutedInIframe(new DriverStatus({
                isCommandResult: true,
                executionError: err,
            })); });
        };
        Driver.prototype._onCommandExecutedInIframe = function (status) {
            var _this = this;
            this.contextStorage.setItem(this.EXECUTING_IN_IFRAME_FLAG, false);
            var promise = Promise$7.resolve();
            if (this._pendingChildWindowInIFrame)
                promise = this._pendingChildWindowInIFrame;
            promise.then(function () {
                _this._onReady(status);
            });
        };
        Driver.prototype._ensureChildIframeDriverLink = function (iframeWindow, ErrorCtor, selectorTimeout) {
            var _this = this;
            // NOTE: a child iframe driver should establish connection with the parent when it's loaded.
            // Here we are waiting while the appropriate child iframe driver do this if it didn't do yet.
            return testCafeCore.waitFor(function () { return _this._getChildIframeDriverLinkByWindow(iframeWindow); }, CHECK_IFRAME_DRIVER_LINK_DELAY, selectorTimeout)
                .catch(function () {
                throw new ErrorCtor();
            });
        };
        Driver.prototype._ensureChildWindowDriverLink = function (childWindow, ErrorCtor, timeout) {
            var _this = this;
            // NOTE: a child window driver should establish connection with the parent when it's loaded.
            // Here we are waiting while the appropriate child window driver do this if it didn't do yet.
            return testCafeCore.waitFor(function () { return _this._getChildWindowDriverLinkByWindow(childWindow); }, CHECK_CHILD_WINDOW_DRIVER_LINK_DELAY, timeout)
                .catch(function () {
                throw new ErrorCtor();
            });
        };
        Driver.prototype._switchToIframe = function (selector, iframeErrorCtors) {
            var _this = this;
            var hasSpecificTimeout = typeof selector.timeout === 'number';
            var commandSelectorTimeout = hasSpecificTimeout ? selector.timeout : this.selectorTimeout;
            return getResult(selector, commandSelectorTimeout, null, function (fn) { return new iframeErrorCtors.NotFoundError(fn); }, function () { return new iframeErrorCtors.IsInvisibleError(); }, this.statusBar)
                .then(function (iframe) {
                if (!testCafeCore.domUtils.isIframeElement(iframe))
                    throw new ActionElementNotIframeError();
                window['%switchedIframe%'] = iframe;
                return _this._ensureChildIframeDriverLink(nativeMethods$7.contentWindowGetter.call(iframe), iframeErrorCtors.NotLoadedError, commandSelectorTimeout);
            })
                .then(function (childDriverLink) {
                childDriverLink.availabilityTimeout = commandSelectorTimeout;
                _this.activeChildIframeDriverLink = childDriverLink;
                _this.contextStorage.setItem(ACTIVE_IFRAME_SELECTOR, selector);
            });
        };
        Driver.prototype._createWaitForEventPromise = function (eventName, timeout) {
            var _this = this;
            var eventHandler = null;
            var timeoutPromise = new Promise$7(function (resolve) {
                nativeMethods$7.setTimeout.call(window, function () {
                    _this.off(eventName, eventHandler);
                    resolve();
                }, timeout);
            });
            var resultPromise = new Promise$7(function (resolve) {
                eventHandler = function () {
                    this.off(eventName, eventHandler);
                    resolve();
                };
                _this.on(eventName, eventHandler);
            });
            return Promise$7.race([timeoutPromise, resultPromise]);
        };
        Driver.prototype._waitForCurrentCommandCompletion = function () {
            if (!this.contextStorage.getItem(this.COMMAND_EXECUTING_FLAG))
                return Promise$7.resolve();
            return this._createWaitForEventPromise(STATUS_WITH_COMMAND_RESULT_EVENT, COMMAND_EXECUTION_MAX_TIMEOUT);
        };
        Driver.prototype._waitForEmptyCommand = function () {
            return this._createWaitForEventPromise(EMPTY_COMMAND_EVENT, EMPTY_COMMAND_EVENT_WAIT_TIMEOUT);
        };
        Driver.prototype._abortSwitchingToChildWindowIfItClosed = function () {
            if (!this.activeChildWindowDriverLink.driverWindow.closed)
                return;
            testCafeCore.arrayUtils.remove(this.childWindowDriverLinks, this.activeChildWindowDriverLink);
            this.activeChildWindowDriverLink = null;
            throw new ChildWindowClosedBeforeSwitchingError();
        };
        Driver.prototype._switchToChildWindow = function (selector) {
            var _this = this;
            this.contextStorage.setItem(this.PENDING_WINDOW_SWITCHING_FLAG, true);
            var isWindowOpenedViaAPI = this.contextStorage.getItem(this.WINDOW_COMMAND_API_CALL_FLAG);
            return executeChildWindowDriverLinkSelector(selector, this.childWindowDriverLinks)
                .then(function (childWindowDriverLink) {
                return _this._ensureChildWindowDriverLink(childWindowDriverLink.driverWindow, ChildWindowIsNotLoadedError, _this.childWindowReadyTimeout);
            })
                .then(function (childWindowDriverLink) {
                _this.activeChildWindowDriverLink = childWindowDriverLink;
                return _this._waitForCurrentCommandCompletion();
            })
                .then(function () {
                return isWindowOpenedViaAPI ? void 0 : _this._waitForEmptyCommand();
            })
                .then(function () {
                _this._abortSwitchingToChildWindowIfItClosed();
                _this._stopInternal();
                return _this.activeChildWindowDriverLink.setAsMaster(isWindowOpenedViaAPI);
            })
                .then(function () {
                _this.contextStorage.setItem(_this.PENDING_WINDOW_SWITCHING_FLAG, false);
            })
                .catch(function (err) {
                _this.contextStorage.setItem(_this.PENDING_WINDOW_SWITCHING_FLAG, false);
                if (err instanceof ChildWindowClosedBeforeSwitchingError) {
                    _this._onReady(new DriverStatus());
                    return;
                }
                _this._onReady(new DriverStatus({
                    isCommandResult: true,
                    executionError: new CannotSwitchToWindowError(),
                }));
            });
        };
        Driver.prototype._switchToTopParentWindow = function () {
            var switchFn = this.parentWindowDriverLink.setTopOpenedWindowAsMaster.bind(this.parentWindowDriverLink);
            this._switchToParentWindowInternal(switchFn);
        };
        Driver.prototype._switchToParentWindow = function (opts) {
            if (opts === void 0) { opts = {}; }
            var switchFn = this.parentWindowDriverLink.setParentWindowAsMaster.bind(this.parentWindowDriverLink);
            this._switchToParentWindowInternal(switchFn, opts);
        };
        Driver.prototype._switchToParentWindowInternal = function (parentWindowSwitchFn, opts) {
            var _this = this;
            if (opts === void 0) { opts = {}; }
            this.contextStorage.setItem(this.PENDING_WINDOW_SWITCHING_FLAG, true);
            return Promise$7.resolve()
                .then(function () {
                _this._stopInternal();
                return parentWindowSwitchFn(opts);
            })
                .then(function () {
                _this.contextStorage.setItem(_this.PENDING_WINDOW_SWITCHING_FLAG, false);
            })
                .catch(function () {
                _this.contextStorage.setItem(_this.PENDING_WINDOW_SWITCHING_FLAG, false);
                _this._onReady(new DriverStatus({
                    isCommandResult: true,
                    executionError: new CannotSwitchToWindowError(),
                }));
            });
        };
        Driver.prototype._switchToMainWindow = function (command) {
            if (this.activeChildIframeDriverLink)
                this.activeChildIframeDriverLink.executeCommand(command);
            this._clearActiveChildIframeInfo();
        };
        Driver.prototype._clearActiveChildIframeInfo = function () {
            this.contextStorage.setItem(ACTIVE_IFRAME_SELECTOR, null);
            this.activeChildIframeDriverLink = null;
        };
        Driver.prototype._setNativeDialogHandlerInIframes = function (dialogHandler) {
            var msg = new SetNativeDialogHandlerMessage(dialogHandler);
            for (var i = 0; i < this.childIframeDriverLinks.length; i++)
                messageSandbox$4.sendServiceMsg(msg, this.childIframeDriverLinks[i].driverWindow);
        };
        // Commands handling
        Driver.prototype._onActionCommand = function (command) {
            var _this = this;
            var _a = executeAction(command, this.selectorTimeout, this.statusBar, this.speed), startPromise = _a.startPromise, completionPromise = _a.completionPromise;
            startPromise.then(function () { return _this.contextStorage.setItem(_this.COMMAND_EXECUTING_FLAG, true); });
            completionPromise
                .then(function (driverStatus) {
                _this.contextStorage.setItem(_this.COMMAND_EXECUTING_FLAG, false);
                return _this._onReady(driverStatus);
            });
        };
        Driver.prototype._onSetNativeDialogHandlerCommand = function (command) {
            this.nativeDialogsTracker.setHandler(command.dialogHandler);
            this._setNativeDialogHandlerInIframes(command.dialogHandler);
            this._onReady(new DriverStatus({ isCommandResult: true }));
        };
        Driver.prototype._onGetNativeDialogHistoryCommand = function () {
            this._onReady(new DriverStatus({
                isCommandResult: true,
                result: this.nativeDialogsTracker.appearedDialogs,
            }));
        };
        Driver.prototype._onGetBrowserConsoleMessagesCommand = function () {
            this._onReady(new DriverStatus({ isCommandResult: true }));
        };
        Driver.prototype._onNavigateToCommand = function (command) {
            var _this = this;
            this.contextStorage.setItem(this.COMMAND_EXECUTING_FLAG, true);
            executeNavigateTo(command)
                .then(function (driverStatus) {
                _this.contextStorage.setItem(_this.COMMAND_EXECUTING_FLAG, false);
                return _this._onReady(driverStatus);
            });
        };
        Driver.prototype._onExecuteClientFunctionCommand = function (command) {
            var _this = this;
            this.contextStorage.setItem(EXECUTING_CLIENT_FUNCTION_DESCRIPTOR, { instantiationCallsiteName: command.instantiationCallsiteName });
            var executor = new ClientFunctionExecutor(command);
            getExecutorResultDriverStatus(executor)
                .then(function (driverStatus) {
                _this.contextStorage.setItem(EXECUTING_CLIENT_FUNCTION_DESCRIPTOR, null);
                _this._onReady(driverStatus);
            });
        };
        Driver.prototype._onExecuteSelectorCommand = function (command) {
            var _this = this;
            var startTime = this.contextStorage.getItem(SELECTOR_EXECUTION_START_TIME) || new DateCtor$2();
            var elementNotFoundOrNotVisible = function (fn) { return new CannotObtainInfoForElementSpecifiedBySelectorError(null, fn); };
            var createError = command.needError ? elementNotFoundOrNotVisible : null;
            getResultDriverStatus(command, this.selectorTimeout, startTime, createError, createError, this.statusBar)
                .then(function (driverStatus) {
                _this.contextStorage.setItem(SELECTOR_EXECUTION_START_TIME, null);
                _this._onReady(driverStatus);
            });
        };
        Driver.prototype._onSwitchToMainWindowCommand = function (command) {
            this._switchToMainWindow(command);
            this._onReady(new DriverStatus({ isCommandResult: true }));
        };
        Driver.prototype._onSwitchToIframeCommand = function (command) {
            var _this = this;
            this
                ._switchToIframe(command.selector, ACTION_IFRAME_ERROR_CTORS)
                .then(function () { return _this._onReady(new DriverStatus({ isCommandResult: true })); })
                .catch(function (err) { return _this._onReady(new DriverStatus({
                isCommandResult: true,
                executionError: err,
            })); });
        };
        Driver.prototype._onWindowOpenCommand = function (command) {
            this.contextStorage.setItem(this.WINDOW_COMMAND_API_CALL_FLAG, true);
            window.open(command.url);
        };
        Driver.prototype._onWindowCloseCommand = function (command) {
            return __awaiter(this, void 0, void 0, function () {
                var wnd, windowId, isCurrentWindow, response, result, err_1;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            wnd = this._getTopOpenedWindow();
                            windowId = command.windowId || this.windowId;
                            isCurrentWindow = windowId === this.windowId;
                            _a.label = 1;
                        case 1:
                            _a.trys.push([1, 4, , 5]);
                            return [4 /*yield*/, this._validateChildWindowCloseCommandExists(windowId, wnd)];
                        case 2:
                            response = _a.sent();
                            result = response.result;
                            if (!result.success)
                                throw Driver._createWindowValidationError(result);
                            return [4 /*yield*/, sendMessageToDriver(new CloseWindowCommandMessage({
                                    windowId: windowId,
                                    isCurrentWindow: isCurrentWindow,
                                }), wnd, WAIT_FOR_WINDOW_DRIVER_RESPONSE_TIMEOUT, CannotSwitchToWindowError)];
                        case 3:
                            _a.sent();
                            // NOTE: we do not need to send a new Driver Status if we close the current window
                            // in this case the new Driver Status will be sent from the `_setCurrentWindowAsMaster` method
                            // in other cases we need to send a new Driver Status from here.
                            if (!isCurrentWindow) {
                                this._onReady(new DriverStatus({
                                    isCommandResult: true,
                                }));
                            }
                            return [3 /*break*/, 5];
                        case 4:
                            err_1 = _a.sent();
                            this._onReady(new DriverStatus({
                                isCommandResult: true,
                                executionError: err_1,
                            }));
                            return [3 /*break*/, 5];
                        case 5: return [2 /*return*/];
                    }
                });
            });
        };
        Driver.prototype._onGetCurrentWindowCommand = function () {
            this._onReady(new DriverStatus({
                isCommandResult: true,
                result: {
                    id: this.windowId,
                },
            }));
        };
        Driver.prototype._onGetWindowsCommand = function () {
            return __awaiter(this, void 0, void 0, function () {
                var wnd, response;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            wnd = this._getTopOpenedWindow();
                            return [4 /*yield*/, sendMessageToDriver(new GetWindowsMessage(), wnd, WAIT_FOR_WINDOW_DRIVER_RESPONSE_TIMEOUT, CannotSwitchToWindowError)];
                        case 1:
                            response = _a.sent();
                            this._onReady(new DriverStatus({
                                isCommandResult: true,
                                result: response.result,
                            }));
                            return [2 /*return*/];
                    }
                });
            });
        };
        Driver.prototype._validateChildWindowCloseCommandExists = function (windowId, wnd) {
            return sendMessageToDriver(new CloseWindowValidationMessage({ windowId: windowId }), wnd, WAIT_FOR_WINDOW_DRIVER_RESPONSE_TIMEOUT, CannotSwitchToWindowError);
        };
        Driver.prototype._validateChildWindowSwitchToWindowCommandExists = function (_a, wnd) {
            var windowId = _a.windowId, fn = _a.fn;
            return sendMessageToDriver(new SwitchToWindowValidationMessage({ windowId: windowId, fn: fn }), wnd, WAIT_FOR_WINDOW_DRIVER_RESPONSE_TIMEOUT, CannotSwitchToWindowError);
        };
        Driver.prototype._getTopOpenedWindow = function () {
            var _a;
            var wnd = ((_a = this.parentWindowDriverLink) === null || _a === void 0 ? void 0 : _a.getTopOpenedWindow()) || window;
            return wnd.top;
        };
        Driver.prototype._onSwitchToWindow = function (command, err) {
            return __awaiter(this, void 0, void 0, function () {
                var wnd, response, result;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            wnd = this._getTopOpenedWindow();
                            return [4 /*yield*/, this._validateChildWindowSwitchToWindowCommandExists({ windowId: command.windowId, fn: command.checkWindow }, wnd)];
                        case 1:
                            response = _a.sent();
                            result = response.result;
                            if (!result.success) {
                                this._onReady(new DriverStatus({
                                    isCommandResult: true,
                                    executionError: err || Driver._createWindowValidationError(result),
                                }));
                            }
                            else {
                                this._stopInternal();
                                sendMessageToDriver(new SwitchToWindowCommandMessage({ windowId: command.windowId, fn: command.checkWindow }), wnd, WAIT_FOR_WINDOW_DRIVER_RESPONSE_TIMEOUT, CannotSwitchToWindowError);
                            }
                            return [2 /*return*/];
                    }
                });
            });
        };
        Driver.prototype._restoreChildWindowLinks = function () {
            return __awaiter(this, void 0, void 0, function () {
                var restoreChildWindowsPromise, err_2;
                var _this = this;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!this.contextStorage.getItem(PENDING_CHILD_WINDOW_COUNT))
                                return [2 /*return*/];
                            restoreChildWindowsPromise = new Promise$7(function (resolve) {
                                _this._restoreChildWindowsPromiseResolver = resolve;
                            });
                            _a.label = 1;
                        case 1:
                            _a.trys.push([1, 3, , 4]);
                            return [4 /*yield*/, testCafeCore.getTimeLimitedPromise(restoreChildWindowsPromise, RESTORE_CHILD_WINDOWS_TIMEOUT)];
                        case 2:
                            _a.sent();
                            return [3 /*break*/, 4];
                        case 3:
                            err_2 = _a.sent();
                            this._onReady(new DriverStatus({
                                isCommandResult: true,
                                executionError: new CannotRestoreChildWindowError(),
                            }));
                            return [3 /*break*/, 4];
                        case 4: return [2 /*return*/];
                    }
                });
            });
        };
        Driver.prototype._onSwitchToPreviousWindow = function (command) {
            this._onSwitchToWindow(command, new PreviousWindowNotFoundError());
        };
        Driver.prototype._onSwitchToParentWindow = function () {
            if (this.parentWindowDriverLink)
                this._switchToParentWindow({ finalizePendingCommand: true });
            else {
                this._onReady(new DriverStatus({
                    isCommandResult: true,
                    executionError: new ParentWindowNotFoundError(),
                }));
            }
        };
        Driver.prototype._onBrowserManipulationCommand = function (command) {
            var _this = this;
            this.contextStorage.setItem(this.COMMAND_EXECUTING_FLAG, true);
            executeManipulationCommand(command, this.selectorTimeout, this.statusBar)
                .then(function (driverStatus) {
                _this.contextStorage.setItem(_this.COMMAND_EXECUTING_FLAG, false);
                return _this._onReady(driverStatus);
            });
        };
        Driver.prototype._onSetBreakpointCommand = function (_a) {
            var _this = this;
            var isTestError = _a.isTestError, inCompilerService = _a.inCompilerService;
            var showDebuggingStatusPromise = this.statusBar.showDebuggingStatus(isTestError);
            if (inCompilerService) {
                showDebuggingStatusPromise.then(function (debug) {
                    _this.debug = debug;
                });
                this._onReady(new DriverStatus({
                    isCommandResult: true,
                    result: true,
                }));
            }
            else {
                showDebuggingStatusPromise.then(function (debug) {
                    var stopAfterNextAction = debug === STATUS_BAR_DEBUG_ACTION.step;
                    _this._onReady(new DriverStatus({
                        isCommandResult: true,
                        result: stopAfterNextAction,
                    }));
                });
            }
        };
        Driver.prototype._onDisableDebugCommand = function () {
            this.statusBar._resetState();
            this._onReady(new DriverStatus({
                isCommandResult: true,
            }));
        };
        Driver.prototype._onSetTestSpeedCommand = function (command) {
            this.speed = command.speed;
            this._onReady(new DriverStatus({ isCommandResult: true }));
        };
        Driver.prototype._onShowAssertionRetriesStatusCommand = function (command) {
            this.contextStorage.setItem(ASSERTION_RETRIES_TIMEOUT, command.timeout);
            this.contextStorage.setItem(ASSERTION_RETRIES_START_TIME, nativeMethods$7.dateNow());
            this.statusBar.showWaitingAssertionRetriesStatus(command.timeout);
            this._onReady(new DriverStatus({ isCommandResult: true }));
        };
        Driver.prototype._onHideAssertionRetriesStatusCommand = function (command) {
            var _this = this;
            this.contextStorage.setItem(ASSERTION_RETRIES_TIMEOUT, null);
            this.contextStorage.setItem(ASSERTION_RETRIES_START_TIME, null);
            this.statusBar.hideWaitingAssertionRetriesStatus(command.success)
                .then(function () { return _this._onReady(new DriverStatus({ isCommandResult: true })); });
        };
        Driver.prototype._checkStatus = function () {
            var _this = this;
            return testCafeCore.browser
                .checkStatus(this.browserStatusDoneUrl, hammerhead__default.createNativeXHR, { manualRedirect: true })
                .then(function (_a) {
                var command = _a.command, redirecting = _a.redirecting;
                var isSessionChange = redirecting && command.url.indexOf(_this.testRunId) < 0;
                if (isSessionChange) {
                    storages.clear();
                    storages.lock();
                }
                else
                    _this.contextStorage.setItem(TEST_DONE_SENT_FLAG, false);
                if (redirecting)
                    testCafeCore.browser.redirect(command);
                else
                    _this._onReady({ isCommandResult: false });
            })
                .catch(function () {
                return testCafeCore.delay(CHECK_STATUS_RETRY_DELAY);
            });
        };
        Driver.prototype._onCustomCommand = function (command) {
            var _this = this;
            var handler = this.customCommandHandlers[command.type].handler;
            handler(command).then(function (result) {
                _this._onReady(new DriverStatus({ isCommandResult: true, result: result }));
            });
        };
        Driver.prototype._closeAllChildWindows = function () {
            var _this = this;
            if (!this.childWindowDriverLinks.length)
                return Promise$7.resolve();
            return Promise$7.all(this.childWindowDriverLinks.map(function (childWindowDriverLink) {
                return childWindowDriverLink.closeAllChildWindows();
            }))
                .then(function () {
                nativeMethods$7.arrayForEach.call(_this.childWindowDriverLinks, function (childWindowDriverLink) {
                    childWindowDriverLink.driverWindow.close();
                });
            });
        };
        Driver.prototype._onTestDone = function (status) {
            var _this = this;
            this.contextStorage.setItem(TEST_DONE_SENT_FLAG, true);
            if (this.parentWindowDriverLink)
                this._switchToTopParentWindow();
            else {
                this._closeAllChildWindows()
                    .then(function () {
                    return _this._sendStatus(status);
                })
                    .then(function () {
                    _this._checkStatus();
                })
                    .catch(function () {
                    _this._onReady(new DriverStatus({
                        isCommandResult: true,
                        executionError: CloseChildWindowError,
                    }));
                });
            }
        };
        Driver.prototype._onBackupStoragesCommand = function () {
            this._onReady(new DriverStatus({
                isCommandResult: true,
                result: storages.backup(),
            }));
        };
        Driver.prototype._isStatusWithCommandResultInPendingWindowSwitchingMode = function (status) {
            return status.isCommandResult && !!this.contextStorage.getItem(this.PENDING_WINDOW_SWITCHING_FLAG);
        };
        Driver.prototype._isEmptyCommandInPendingWindowSwitchingMode = function (command) {
            return !command && !!this.contextStorage.getItem(this.PENDING_WINDOW_SWITCHING_FLAG);
        };
        // Routing
        Driver.prototype._onReady = function (status) {
            var _this = this;
            if (this.debug) {
                status.debug = this.debug;
                this.debug = null;
            }
            if (this._isStatusWithCommandResultInPendingWindowSwitchingMode(status))
                this.emit(STATUS_WITH_COMMAND_RESULT_EVENT);
            this._sendStatus(status)
                .then(function (command) {
                if (command)
                    _this._onCommand(command);
                else {
                    if (_this._isEmptyCommandInPendingWindowSwitchingMode(command)) {
                        _this.emit(EMPTY_COMMAND_EVENT);
                        return;
                    }
                    // NOTE: the driver gets an empty response if TestRun doesn't get a new command within 2 minutes
                    _this._onReady(new DriverStatus());
                }
            });
        };
        Driver.prototype._executeCommand = function (command) {
            this.contextStorage.setItem(this.WINDOW_COMMAND_API_CALL_FLAG, false);
            if (this.customCommandHandlers[command.type])
                this._onCustomCommand(command);
            else if (command.type === COMMAND_TYPE.testDone)
                this._onTestDone(new DriverStatus({ isCommandResult: true }));
            else if (command.type === COMMAND_TYPE.setBreakpoint)
                this._onSetBreakpointCommand(command);
            else if (command.type === COMMAND_TYPE.disableDebug)
                this._onDisableDebugCommand();
            else if (command.type === COMMAND_TYPE.switchToMainWindow)
                this._onSwitchToMainWindowCommand(command);
            else if (command.type === COMMAND_TYPE.switchToIframe)
                this._onSwitchToIframeCommand(command);
            else if (command.type === COMMAND_TYPE.openWindow)
                this._onWindowOpenCommand(command);
            else if (command.type === COMMAND_TYPE.closeWindow)
                this._onWindowCloseCommand(command);
            else if (command.type === COMMAND_TYPE.getCurrentWindow)
                this._onGetCurrentWindowCommand(command);
            else if (command.type === COMMAND_TYPE.getCurrentWindows)
                this._onGetWindowsCommand();
            else if (command.type === COMMAND_TYPE.switchToWindow)
                this._onSwitchToWindow(command);
            else if (command.type === COMMAND_TYPE.switchToPreviousWindow)
                this._onSwitchToPreviousWindow(command);
            else if (command.type === COMMAND_TYPE.switchToParentWindow)
                this._onSwitchToParentWindow();
            else if (isBrowserManipulationCommand(command))
                this._onBrowserManipulationCommand(command);
            else if (command.type === COMMAND_TYPE.executeClientFunction)
                this._onExecuteClientFunctionCommand(command);
            else if (command.type === COMMAND_TYPE.executeSelector)
                this._onExecuteSelectorCommand(command);
            else if (command.type === COMMAND_TYPE.navigateTo)
                this._onNavigateToCommand(command);
            else if (command.type === COMMAND_TYPE.setNativeDialogHandler)
                this._onSetNativeDialogHandlerCommand(command);
            else if (command.type === COMMAND_TYPE.getNativeDialogHistory)
                this._onGetNativeDialogHistoryCommand(command);
            else if (command.type === COMMAND_TYPE.getBrowserConsoleMessages)
                this._onGetBrowserConsoleMessagesCommand(command);
            else if (command.type === COMMAND_TYPE.setTestSpeed)
                this._onSetTestSpeedCommand(command);
            else if (command.type === COMMAND_TYPE.showAssertionRetriesStatus)
                this._onShowAssertionRetriesStatusCommand(command);
            else if (command.type === COMMAND_TYPE.hideAssertionRetriesStatus)
                this._onHideAssertionRetriesStatusCommand(command);
            else if (command.type === COMMAND_TYPE.backupStorages)
                this._onBackupStoragesCommand();
            else
                this._onActionCommand(command);
        };
        Driver.prototype._isExecutableInTopWindowOnly = function (command) {
            if (isExecutableInTopWindowOnly(command))
                return true;
            var customCommandHandler = this.customCommandHandlers[command.type];
            return command.forceExecutionInTopWindowOnly || customCommandHandler && customCommandHandler.isExecutableInTopWindowOnly;
        };
        Driver.prototype._onCommand = function (command) {
            var _this = this;
            // NOTE: the driver sends status to the server as soon as it's created,
            // but it should wait until the page is loaded before executing a command.
            this.readyPromise
                .then(function () {
                // NOTE: we should not execute a command if we already have a pending page error and this command is
                // rejectable by page errors. In this case, we immediately send status with this error to the server.
                var isCommandRejectableByError = isCommandRejectableByPageError(command);
                var pendingPageError = _this.contextStorage.getItem(PENDING_PAGE_ERROR);
                if (pendingPageError && isCommandRejectableByError) {
                    _this._onReady(new DriverStatus({ isCommandResult: true }));
                    return;
                }
                // NOTE: we should execute a command in an iframe if the current execution context belongs to
                // this iframe and the command is not one of those that can be executed only in the top window.
                var isThereActiveIframe = _this.activeChildIframeDriverLink ||
                    _this.contextStorage.getItem(ACTIVE_IFRAME_SELECTOR);
                if (!_this._isExecutableInTopWindowOnly(command) && isThereActiveIframe) {
                    _this._runInActiveIframe(command);
                    return;
                }
                _this._executeCommand(command);
            });
        };
        // API
        Driver.prototype.setCustomCommandHandlers = function (command, handler, executeInTopWindowOnly) {
            this.customCommandHandlers[command] = {
                isExecutableInTopWindowOnly: executeInTopWindowOnly,
                handler: handler,
            };
        };
        Driver.prototype._startInternal = function (opts) {
            this.role = DriverRole.master;
            testCafeCore.browser.startHeartbeat(this.heartbeatUrl, hammerhead__default.createNativeXHR);
            this._setupAssertionRetryIndication();
            this._startCommandsProcessing(opts);
        };
        Driver.prototype._stopInternal = function () {
            this.role = DriverRole.replica;
            testCafeCore.browser.stopHeartbeat();
            testcafeAutomation.cursor.hide();
        };
        Driver.prototype._setupAssertionRetryIndication = function () {
            var _this = this;
            this.readyPromise.then(function () {
                _this.statusBar.hidePageLoadingStatus();
                var assertionRetriesTimeout = _this.contextStorage.getItem(ASSERTION_RETRIES_TIMEOUT);
                if (assertionRetriesTimeout) {
                    var startTime = _this.contextStorage.getItem(ASSERTION_RETRIES_START_TIME);
                    var timeLeft = assertionRetriesTimeout - (new DateCtor$2() - startTime);
                    if (timeLeft > 0)
                        _this.statusBar.showWaitingAssertionRetriesStatus(assertionRetriesTimeout, startTime);
                }
            });
        };
        Driver.prototype._startCommandsProcessing = function (opts) {
            if (opts === void 0) { opts = { finalizePendingCommand: false, isFirstRequestAfterWindowSwitching: false, result: void 0 }; }
            var pendingStatus = this.contextStorage.getItem(PENDING_STATUS);
            if (pendingStatus)
                pendingStatus.resent = true;
            // NOTE: we should not send any message to the server if we've
            // sent the 'test-done' message but haven't got the response.
            if (this.contextStorage.getItem(TEST_DONE_SENT_FLAG)) {
                if (pendingStatus)
                    this._onTestDone(pendingStatus);
                else
                    this._checkStatus();
                return;
            }
            if (this._failIfClientCodeExecutionIsInterrupted())
                return;
            var finalizePendingCommand = opts.finalizePendingCommand || this._hasPendingActionFlags(this.contextStorage);
            var status = pendingStatus || new DriverStatus({
                isCommandResult: finalizePendingCommand,
                isFirstRequestAfterWindowSwitching: opts.isFirstRequestAfterWindowSwitching,
                result: opts.result,
            });
            this.contextStorage.setItem(this.COMMAND_EXECUTING_FLAG, false);
            this.contextStorage.setItem(this.EXECUTING_IN_IFRAME_FLAG, false);
            this.contextStorage.setItem(this.PENDING_WINDOW_SWITCHING_FLAG, false);
            this._onReady(status);
        };
        Driver.prototype._initParentWindowLink = function () {
            // NOTE: we need to create parentWindowDriverLinks in the following cases:
            // multiple-windows mode is enabled
            // current window has parent window
            // current window parent is not the same as current window
            // the last case is possible when we have the series of multiple and non-multiple windows tests
            if (window.opener && window.opener !== window && this.windowId)
                this.parentWindowDriverLink = new ParentWindowDriverLink(window);
        };
        Driver.prototype._initConsoleMessages = function () {
            var messages = this.consoleMessages;
            messages.ensureMessageContainer(this.windowId);
            this.consoleMessages = messages;
        };
        Driver.prototype._getDriverRole = function () {
            return __awaiter(this, void 0, void 0, function () {
                var activeWindowId;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!this.windowId)
                                return [2 /*return*/, DriverRole.master];
                            return [4 /*yield*/, testCafeCore.browser.getActiveWindowId(this.browserActiveWindowId, hammerhead__default.createNativeXHR)];
                        case 1:
                            activeWindowId = (_a.sent()).activeWindowId;
                            return [2 /*return*/, activeWindowId === this.windowId ?
                                    DriverRole.master :
                                    DriverRole.replica];
                    }
                });
            });
        };
        Driver.prototype._init = function () {
            this.contextStorage = new Storage(window, this.testRunId, this.windowId);
            this.nativeDialogsTracker = new NativeDialogTracker(this.contextStorage, this.dialogHandler);
            this.statusBar = new testCafeUI.StatusBar(this.userAgent, this.fixtureName, this.testName, this.contextStorage);
            this.statusBar.on(this.statusBar.UNLOCK_PAGE_BTN_CLICK, testCafeCore.disableRealEventsPreventing);
            this.speed = this.initialSpeed;
            this._initConsoleMessages();
            this._initParentWindowLink();
            if (this._isOpenedInIframe())
                sendMessageToDriver(new ChildWindowIsLoadedInFrameMessage(this.windowId), window.opener.top, WAIT_FOR_WINDOW_DRIVER_RESPONSE_TIMEOUT, WindowNotFoundError);
        };
        Driver.prototype._doFirstPageLoadSetup = function () {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    if (this.isFirstPageLoad && this.canUseDefaultWindowActions) ;
                    return [2 /*return*/];
                });
            });
        };
        Driver.prototype.start = function () {
            return __awaiter(this, void 0, void 0, function () {
                var role;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            this._init();
                            return [4 /*yield*/, this._doFirstPageLoadSetup()];
                        case 1:
                            _a.sent();
                            return [4 /*yield*/, this._restoreChildWindowLinks()];
                        case 2:
                            _a.sent();
                            return [4 /*yield*/, this._getDriverRole()];
                        case 3:
                            role = _a.sent();
                            // NOTE: the child window can become master during the preceding async requests
                            // in this case we do not need to call the `_startInternal` method again
                            // since it was called during the `_handleSetAsMasterMessage` method.
                            if (this.role === DriverRole.master)
                                return [2 /*return*/];
                            if (role === DriverRole.master)
                                this._startInternal();
                            return [2 /*return*/];
                    }
                });
            });
        };
        return Driver;
    }(testCafeCore.serviceUtils.EventEmitter));

    var ParentIframeDriverLink = /** @class */ (function () {
        function ParentIframeDriverLink(parentDriverWindow) {
            this.driverWindow = parentDriverWindow;
        }
        ParentIframeDriverLink.prototype.establishConnection = function () {
            var msg = new EstablishConnectionMessage();
            return sendMessageToDriver(msg, this.driverWindow, WAIT_FOR_IFRAME_DRIVER_RESPONSE_TIMEOUT, CurrentIframeIsNotLoadedError)
                .then(function (response) { return response.result.id; });
        };
        ParentIframeDriverLink.prototype.sendConfirmationMessage = function (requestMsgId) {
            sendConfirmationMessage({
                requestMsgId: requestMsgId,
                window: this.driverWindow,
            });
        };
        ParentIframeDriverLink.prototype.onCommandExecuted = function (status) {
            var msg = new CommandExecutedMessage(status);
            hammerhead.eventSandbox.message.sendServiceMsg(msg, this.driverWindow);
        };
        ParentIframeDriverLink.prototype.hasPendingActionFlags = function () {
            return __awaiter(this, void 0, void 0, function () {
                var response;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, sendMessageToDriver(new HasPendingActionFlagsMessage(), this.driverWindow, WAIT_FOR_IFRAME_DRIVER_RESPONSE_TIMEOUT, CurrentIframeIsNotLoadedError)];
                        case 1:
                            response = _a.sent();
                            return [2 /*return*/, response.result];
                    }
                });
            });
        };
        return ParentIframeDriverLink;
    }());

    var messageSandbox$5 = hammerhead__default.eventSandbox.message;
    var IframeNativeDialogTracker = /** @class */ (function (_super) {
        __extends(IframeNativeDialogTracker, _super);
        function IframeNativeDialogTracker(dialogHandler) {
            return _super.call(this, null, dialogHandler) || this;
        }
        IframeNativeDialogTracker.prototype._defaultDialogHandler = function (type) {
            messageSandbox$5.sendServiceMsg({
                type: MESSAGE_TYPE.unexpectedDialog,
                dialogType: type,
                url: NativeDialogTracker._getPageUrl(),
            }, window.top);
        };
        IframeNativeDialogTracker.prototype._addAppearedDialogs = function (type, text) {
            messageSandbox$5.sendServiceMsg({
                type: MESSAGE_TYPE.appearedDialog,
                dialogType: type,
                text: text,
                url: NativeDialogTracker._getPageUrl(),
            }, window.top);
        };
        IframeNativeDialogTracker.prototype._onHandlerError = function (type, message) {
            messageSandbox$5.sendServiceMsg({
                type: MESSAGE_TYPE.handlerError,
                dialogType: type,
                message: message,
                url: NativeDialogTracker._getPageUrl(),
            }, window.top);
        };
        return IframeNativeDialogTracker;
    }(NativeDialogTracker));

    var messageSandbox$6 = hammerhead.eventSandbox.message;
    var IframeDriver = /** @class */ (function (_super) {
        __extends(IframeDriver, _super);
        function IframeDriver(testRunId, options) {
            var _this = _super.call(this, testRunId, {}, {}, options) || this;
            _this.lastParentDriverMessageId = null;
            _this.parentDriverLink = new ParentIframeDriverLink(window.parent);
            _this._initParentDriverListening();
            return _this;
        }
        // Errors handling
        IframeDriver.prototype._onJsError = function () {
            // NOTE: do nothing because hammerhead sends js error to the top window directly
        };
        IframeDriver.prototype._onConsoleMessage = function () {
            // NOTE: do nothing because hammerhead sends console messages to the top window directly
        };
        // NOTE: when the new page is opened in the iframe we send a message to the top window
        // to start waiting for the new page is loaded
        IframeDriver.prototype._onChildWindowOpened = function () {
            messageSandbox$6.sendServiceMsg(new ChildWindowIsOpenedInFrameMessage(), window.top);
        };
        // Messaging between drivers
        IframeDriver.prototype._initParentDriverListening = function () {
            var _this = this;
            hammerhead.eventSandbox.message.on(hammerhead.eventSandbox.message.SERVICE_MSG_RECEIVED_EVENT, function (e) {
                var msg = e.message;
                testCafeCore.pageUnloadBarrier
                    .wait(0)
                    .then(function () {
                    // NOTE: the parent driver repeats commands sent to a child driver if it doesn't get a confirmation
                    // from the child in time. However, confirmations sent by child drivers may be delayed when the browser
                    // is heavily loaded. That's why the child driver should ignore repeated messages from its parent.
                    if (msg.type === TYPE.executeCommand) {
                        if (_this.lastParentDriverMessageId === msg.id)
                            return;
                        _this.lastParentDriverMessageId = msg.id;
                        _this.readyPromise.then(function () {
                            _this.speed = msg.testSpeed;
                            _this.parentDriverLink.sendConfirmationMessage(msg.id);
                            _this._onCommand(msg.command);
                        });
                    }
                    if (msg.type === TYPE.setNativeDialogHandler) {
                        _this.nativeDialogsTracker.setHandler(msg.dialogHandler);
                        _this._setNativeDialogHandlerInIframes(msg.dialogHandler);
                    }
                });
            });
        };
        // Commands handling
        IframeDriver.prototype._onSwitchToMainWindowCommand = function (command) {
            this._switchToMainWindow(command);
        };
        // Routing
        IframeDriver.prototype._onReady = function (status) {
            this.parentDriverLink.onCommandExecuted(status);
        };
        IframeDriver.prototype._isInCommandExecution = function () {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!hammerhead.utils.dom.isCrossDomainWindows(window, window.parent)) return [3 /*break*/, 2];
                            return [4 /*yield*/, this.parentDriverLink.hasPendingActionFlags()];
                        case 1: return [2 /*return*/, _a.sent()];
                        case 2: return [2 /*return*/, this._hasPendingActionFlags(this.contextStorage)];
                    }
                });
            });
        };
        IframeDriver.prototype._init = function () {
            return __awaiter(this, void 0, void 0, function () {
                var id, inCommandExecution;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.parentDriverLink.establishConnection()];
                        case 1:
                            id = _a.sent();
                            this.contextStorage = new Storage(window, id, this.windowId);
                            if (this._failIfClientCodeExecutionIsInterrupted())
                                return [2 /*return*/];
                            return [4 /*yield*/, this._isInCommandExecution()];
                        case 2:
                            inCommandExecution = _a.sent();
                            if (!inCommandExecution)
                                return [2 /*return*/];
                            this.contextStorage.setItem(this.COMMAND_EXECUTING_FLAG, false);
                            this.contextStorage.setItem(this.EXECUTING_IN_IFRAME_FLAG, false);
                            this._onReady(new DriverStatus({ isCommandResult: true }));
                            return [2 /*return*/];
                    }
                });
            });
        };
        // API
        IframeDriver.prototype.start = function () {
            this.nativeDialogsTracker = new IframeNativeDialogTracker(this.dialogHandler);
            this.statusBar = new testCafeUI.IframeStatusBar();
            var initializePromise = this._init();
            this.readyPromise = hammerhead.Promise.all([this.readyPromise, initializePromise]);
        };
        return IframeDriver;
    }(Driver));

    var embeddingUtils = {
        NodeSnapshot: NodeSnapshot,
        ElementSnapshot: ElementSnapshot,
        SelectorExecutor: SelectorExecutor,
    };

    var INTERNAL_PROPERTIES = {
        testCafeDriver: '%testCafeDriver%',
        testCafeIframeDriver: '%testCafeIframeDriver%',
        scriptExecutionBarrier: '%ScriptExecutionBarrier%',
        testCafeEmbeddingUtils: '%testCafeEmbeddingUtils%',
        testCafeDriverInstance: '%testCafeDriverInstance%',
    };

    var nativeMethods$8 = hammerhead__default.nativeMethods;
    var evalIframeScript = hammerhead__default.EVENTS.evalIframeScript;
    nativeMethods$8.objectDefineProperty(window, INTERNAL_PROPERTIES.testCafeDriver, { configurable: true, value: Driver });
    nativeMethods$8.objectDefineProperty(window, INTERNAL_PROPERTIES.testCafeIframeDriver, { configurable: true, value: IframeDriver });
    nativeMethods$8.objectDefineProperty(window, INTERNAL_PROPERTIES.scriptExecutionBarrier, {
        configurable: true,
        value: ScriptExecutionBarrier,
    });
    nativeMethods$8.objectDefineProperty(window, INTERNAL_PROPERTIES.testCafeEmbeddingUtils, { configurable: true, value: embeddingUtils });
    // eslint-disable-next-line no-undef
    hammerhead__default.on(evalIframeScript, function (e) { return initTestCafeClientDrivers(nativeMethods$8.contentWindowGetter.call(e.iframe), true); });

}(window['%hammerhead%'], window['%hammerhead%'].Promise, window['%testCafeCore%'], window['%testCafeAutomation%'], window['%testCafeUI%']));

    }

    initTestCafeClientDrivers(window);
})();
