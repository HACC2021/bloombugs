"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
const delay_1 = __importDefault(require("../utils/delay"));
const thennable_1 = require("../utils/thennable");
const test_run_1 = require("../errors/test-run");
const re_executable_promise_1 = __importDefault(require("../utils/re-executable-promise"));
const get_fn_1 = __importDefault(require("./get-fn"));
const marker_1 = require("../services/serialization/replicator/transforms/function-marker-transform/marker");
const marker_2 = require("../services/serialization/replicator/transforms/promise-marker-transform/marker");
const ASSERTION_DELAY = 200;
class AssertionExecutor extends events_1.EventEmitter {
    constructor(command, timeout, callsite) {
        super();
        this.command = command;
        this.timeout = timeout;
        this.callsite = callsite;
        this.startTime = null;
        this.passed = false;
        this.inRetry = false;
        const fn = get_fn_1.default(this.command);
        const actualCommand = this.command.actual;
        if (actualCommand instanceof re_executable_promise_1.default)
            this.fn = this._wrapFunction(fn);
        else if (!this.command.options.allowUnawaitedPromise && this._isPromise(actualCommand))
            throw new test_run_1.AssertionUnawaitedPromiseError(this.callsite);
        else
            this.fn = fn;
    }
    _isPromise(val) {
        return thennable_1.isThennable(val) ||
            val === Symbol.for(marker_2.PROMISE_MARKER_DESCRIPTION);
    }
    _getTimeLeft() {
        const executionTime = new Date().getTime() - this.startTime; // eslint-disable-line @typescript-eslint/no-extra-parens
        return this.timeout - executionTime;
    }
    _onExecutionFinished() {
        if (this.inRetry)
            this.emit('end-assertion-retries', this.passed);
    }
    _wrapFunction(fn) {
        return async () => {
            const resultPromise = this.command.actual;
            while (!this.passed) {
                this.command.actual = await resultPromise._reExecute();
                try {
                    fn();
                    this.passed = true;
                    this._onExecutionFinished();
                }
                catch (err) {
                    if (this._getTimeLeft() <= 0) {
                        this._onExecutionFinished();
                        throw err;
                    }
                    await delay_1.default(ASSERTION_DELAY);
                    this.inRetry = true;
                    this.emit('start-assertion-retries', this._getTimeLeft());
                }
            }
        };
    }
    _onBeforeRun() {
        if (this.command.actual !== Symbol.for(marker_1.FUNCTION_MARKER_DESCRIPTION))
            return;
        this.emit('non-serializable-actual-value', this);
    }
    async run() {
        this._onBeforeRun();
        this.startTime = new Date().getTime();
        try {
            await this.fn();
        }
        catch (err) {
            if (err.name === 'AssertionError' || err.constructor.name === 'AssertionError')
                throw new test_run_1.ExternalAssertionLibraryError(err, this.callsite);
            if (err.isTestCafeError)
                err.callsite = this.callsite;
            throw err;
        }
    }
}
exports.default = AssertionExecutor;
module.exports = exports.default;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXhlY3V0b3IuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvYXNzZXJ0aW9ucy9leGVjdXRvci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLG1DQUFzQztBQUN0QywyREFBbUM7QUFDbkMsa0RBQWlEO0FBQ2pELGlEQUFtRztBQUNuRywyRkFBaUU7QUFDakUsc0RBQTZCO0FBRzdCLDZHQUErSDtBQUMvSCw0R0FBNkg7QUFFN0gsTUFBTSxlQUFlLEdBQUcsR0FBRyxDQUFDO0FBRTVCLE1BQXFCLGlCQUFrQixTQUFRLHFCQUFZO0lBU3ZELFlBQW9CLE9BQXlCLEVBQUUsT0FBZSxFQUFFLFFBQXdCO1FBQ3BGLEtBQUssRUFBRSxDQUFDO1FBRVIsSUFBSSxDQUFDLE9BQU8sR0FBSSxPQUFPLENBQUM7UUFDeEIsSUFBSSxDQUFDLE9BQU8sR0FBSSxPQUFPLENBQUM7UUFDeEIsSUFBSSxDQUFDLFFBQVEsR0FBRyxRQUFRLENBQUM7UUFFekIsSUFBSSxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUM7UUFDdEIsSUFBSSxDQUFDLE1BQU0sR0FBTSxLQUFLLENBQUM7UUFDdkIsSUFBSSxDQUFDLE9BQU8sR0FBSyxLQUFLLENBQUM7UUFFdkIsTUFBTSxFQUFFLEdBQWMsZ0JBQUssQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDMUMsTUFBTSxhQUFhLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUM7UUFFMUMsSUFBSSxhQUFhLFlBQVksK0JBQW1CO1lBQzVDLElBQUksQ0FBQyxFQUFFLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQyxFQUFFLENBQUMsQ0FBQzthQUNoQyxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMscUJBQXFCLElBQUksSUFBSSxDQUFDLFVBQVUsQ0FBQyxhQUFhLENBQUM7WUFDbEYsTUFBTSxJQUFJLHlDQUE4QixDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQzs7WUFFeEQsSUFBSSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUM7SUFDckIsQ0FBQztJQUVPLFVBQVUsQ0FBRSxHQUFZO1FBQzVCLE9BQU8sdUJBQVcsQ0FBQyxHQUFHLENBQUM7WUFDbkIsR0FBRyxLQUFLLE1BQU0sQ0FBQyxHQUFHLENBQUMsbUNBQTBCLENBQUMsQ0FBQztJQUN2RCxDQUFDO0lBRU8sWUFBWTtRQUNoQixNQUFNLGFBQWEsR0FBRyxJQUFJLElBQUksRUFBRSxDQUFDLE9BQU8sRUFBRSxHQUFJLElBQUksQ0FBQyxTQUFvQixDQUFDLENBQUMseURBQXlEO1FBRWxJLE9BQU8sSUFBSSxDQUFDLE9BQU8sR0FBRyxhQUFhLENBQUM7SUFDeEMsQ0FBQztJQUVPLG9CQUFvQjtRQUN4QixJQUFJLElBQUksQ0FBQyxPQUFPO1lBQ1osSUFBSSxDQUFDLElBQUksQ0FBQyx1QkFBdUIsRUFBRSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDeEQsQ0FBQztJQUVPLGFBQWEsQ0FBRSxFQUFZO1FBQy9CLE9BQU8sS0FBSyxJQUFJLEVBQUU7WUFDZCxNQUFNLGFBQWEsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLE1BQTZCLENBQUM7WUFFakUsT0FBTyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUU7Z0JBQ2pCLElBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxHQUFHLE1BQU0sYUFBYSxDQUFDLFVBQVUsRUFBRSxDQUFDO2dCQUV2RCxJQUFJO29CQUNBLEVBQUUsRUFBRSxDQUFDO29CQUNMLElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDO29CQUNuQixJQUFJLENBQUMsb0JBQW9CLEVBQUUsQ0FBQztpQkFDL0I7Z0JBRUQsT0FBTyxHQUFHLEVBQUU7b0JBQ1IsSUFBSSxJQUFJLENBQUMsWUFBWSxFQUFFLElBQUksQ0FBQyxFQUFFO3dCQUMxQixJQUFJLENBQUMsb0JBQW9CLEVBQUUsQ0FBQzt3QkFDNUIsTUFBTSxHQUFHLENBQUM7cUJBQ2I7b0JBRUQsTUFBTSxlQUFLLENBQUMsZUFBZSxDQUFDLENBQUM7b0JBRTdCLElBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDO29CQUNwQixJQUFJLENBQUMsSUFBSSxDQUFDLHlCQUF5QixFQUFFLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQyxDQUFDO2lCQUM3RDthQUNKO1FBQ0wsQ0FBQyxDQUFDO0lBQ04sQ0FBQztJQUVPLFlBQVk7UUFDaEIsSUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sS0FBSyxNQUFNLENBQUMsR0FBRyxDQUFDLG9DQUEyQixDQUFDO1lBQy9ELE9BQU87UUFFWCxJQUFJLENBQUMsSUFBSSxDQUFDLCtCQUErQixFQUFFLElBQUksQ0FBQyxDQUFDO0lBQ3JELENBQUM7SUFFTSxLQUFLLENBQUMsR0FBRztRQUNaLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQztRQUVwQixJQUFJLENBQUMsU0FBUyxHQUFHLElBQUksSUFBSSxFQUFFLENBQUMsT0FBTyxFQUFFLENBQUM7UUFFdEMsSUFBSTtZQUNBLE1BQU0sSUFBSSxDQUFDLEVBQUUsRUFBRSxDQUFDO1NBQ25CO1FBRUQsT0FBTyxHQUFHLEVBQUU7WUFDUixJQUFJLEdBQUcsQ0FBQyxJQUFJLEtBQUssZ0JBQWdCLElBQUksR0FBRyxDQUFDLFdBQVcsQ0FBQyxJQUFJLEtBQUssZ0JBQWdCO2dCQUMxRSxNQUFNLElBQUksd0NBQTZCLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztZQUVoRSxJQUFJLEdBQUcsQ0FBQyxlQUFlO2dCQUNuQixHQUFHLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUM7WUFFakMsTUFBTSxHQUFHLENBQUM7U0FDYjtJQUNMLENBQUM7Q0FDSjtBQXJHRCxvQ0FxR0MiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICdldmVudHMnO1xuaW1wb3J0IGRlbGF5IGZyb20gJy4uL3V0aWxzL2RlbGF5JztcbmltcG9ydCB7IGlzVGhlbm5hYmxlIH0gZnJvbSAnLi4vdXRpbHMvdGhlbm5hYmxlJztcbmltcG9ydCB7IEV4dGVybmFsQXNzZXJ0aW9uTGlicmFyeUVycm9yLCBBc3NlcnRpb25VbmF3YWl0ZWRQcm9taXNlRXJyb3IgfSBmcm9tICcuLi9lcnJvcnMvdGVzdC1ydW4nO1xuaW1wb3J0IFJlRXhlY3V0YWJsZVByb21pc2UgZnJvbSAnLi4vdXRpbHMvcmUtZXhlY3V0YWJsZS1wcm9taXNlJztcbmltcG9ydCBnZXRGbiBmcm9tICcuL2dldC1mbic7XG5pbXBvcnQgQXNzZXJ0aW9uQ29tbWFuZCBmcm9tICcuLi90ZXN0LXJ1bi9jb21tYW5kcy9hc3NlcnRpb24nO1xuaW1wb3J0IHsgQ2FsbHNpdGVSZWNvcmQgfSBmcm9tICdjYWxsc2l0ZS1yZWNvcmQnO1xuaW1wb3J0IHsgRlVOQ1RJT05fTUFSS0VSX0RFU0NSSVBUSU9OIH0gZnJvbSAnLi4vc2VydmljZXMvc2VyaWFsaXphdGlvbi9yZXBsaWNhdG9yL3RyYW5zZm9ybXMvZnVuY3Rpb24tbWFya2VyLXRyYW5zZm9ybS9tYXJrZXInO1xuaW1wb3J0IHsgUFJPTUlTRV9NQVJLRVJfREVTQ1JJUFRJT04gfSBmcm9tICcuLi9zZXJ2aWNlcy9zZXJpYWxpemF0aW9uL3JlcGxpY2F0b3IvdHJhbnNmb3Jtcy9wcm9taXNlLW1hcmtlci10cmFuc2Zvcm0vbWFya2VyJztcblxuY29uc3QgQVNTRVJUSU9OX0RFTEFZID0gMjAwO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBc3NlcnRpb25FeGVjdXRvciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gICAgcHVibGljIHJlYWRvbmx5IGNvbW1hbmQ6IEFzc2VydGlvbkNvbW1hbmQ7XG4gICAgcHJpdmF0ZSByZWFkb25seSB0aW1lb3V0OiBudW1iZXI7XG4gICAgcHJpdmF0ZSByZWFkb25seSBjYWxsc2l0ZTogQ2FsbHNpdGVSZWNvcmQ7XG4gICAgcHJpdmF0ZSBzdGFydFRpbWU6IG51bWJlciB8IG51bGw7XG4gICAgcHJpdmF0ZSBwYXNzZWQ6IGJvb2xlYW47XG4gICAgcHJpdmF0ZSBpblJldHJ5OiBib29sZWFuO1xuICAgIHB1YmxpYyBmbjogRnVuY3Rpb247XG5cbiAgICBwdWJsaWMgY29uc3RydWN0b3IgKGNvbW1hbmQ6IEFzc2VydGlvbkNvbW1hbmQsIHRpbWVvdXQ6IG51bWJlciwgY2FsbHNpdGU6IENhbGxzaXRlUmVjb3JkKSB7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgdGhpcy5jb21tYW5kICA9IGNvbW1hbmQ7XG4gICAgICAgIHRoaXMudGltZW91dCAgPSB0aW1lb3V0O1xuICAgICAgICB0aGlzLmNhbGxzaXRlID0gY2FsbHNpdGU7XG5cbiAgICAgICAgdGhpcy5zdGFydFRpbWUgPSBudWxsO1xuICAgICAgICB0aGlzLnBhc3NlZCAgICA9IGZhbHNlO1xuICAgICAgICB0aGlzLmluUmV0cnkgICA9IGZhbHNlO1xuXG4gICAgICAgIGNvbnN0IGZuICAgICAgICAgICAgPSBnZXRGbih0aGlzLmNvbW1hbmQpO1xuICAgICAgICBjb25zdCBhY3R1YWxDb21tYW5kID0gdGhpcy5jb21tYW5kLmFjdHVhbDtcblxuICAgICAgICBpZiAoYWN0dWFsQ29tbWFuZCBpbnN0YW5jZW9mIFJlRXhlY3V0YWJsZVByb21pc2UpXG4gICAgICAgICAgICB0aGlzLmZuID0gdGhpcy5fd3JhcEZ1bmN0aW9uKGZuKTtcbiAgICAgICAgZWxzZSBpZiAoIXRoaXMuY29tbWFuZC5vcHRpb25zLmFsbG93VW5hd2FpdGVkUHJvbWlzZSAmJiB0aGlzLl9pc1Byb21pc2UoYWN0dWFsQ29tbWFuZCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgQXNzZXJ0aW9uVW5hd2FpdGVkUHJvbWlzZUVycm9yKHRoaXMuY2FsbHNpdGUpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLmZuID0gZm47XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfaXNQcm9taXNlICh2YWw6IHVua25vd24pOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIGlzVGhlbm5hYmxlKHZhbCkgfHxcbiAgICAgICAgICAgIHZhbCA9PT0gU3ltYm9sLmZvcihQUk9NSVNFX01BUktFUl9ERVNDUklQVElPTik7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfZ2V0VGltZUxlZnQgKCk6IG51bWJlciB7XG4gICAgICAgIGNvbnN0IGV4ZWN1dGlvblRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtICh0aGlzLnN0YXJ0VGltZSBhcyBudW1iZXIpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHRyYS1wYXJlbnNcblxuICAgICAgICByZXR1cm4gdGhpcy50aW1lb3V0IC0gZXhlY3V0aW9uVGltZTtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9vbkV4ZWN1dGlvbkZpbmlzaGVkICgpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuaW5SZXRyeSlcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnZW5kLWFzc2VydGlvbi1yZXRyaWVzJywgdGhpcy5wYXNzZWQpO1xuICAgIH1cblxuICAgIHByaXZhdGUgX3dyYXBGdW5jdGlvbiAoZm46IEZ1bmN0aW9uKTogRnVuY3Rpb24ge1xuICAgICAgICByZXR1cm4gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0UHJvbWlzZSA9IHRoaXMuY29tbWFuZC5hY3R1YWwgYXMgUmVFeGVjdXRhYmxlUHJvbWlzZTtcblxuICAgICAgICAgICAgd2hpbGUgKCF0aGlzLnBhc3NlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29tbWFuZC5hY3R1YWwgPSBhd2FpdCByZXN1bHRQcm9taXNlLl9yZUV4ZWN1dGUoKTtcblxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGZuKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFzc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb25FeGVjdXRpb25GaW5pc2hlZCgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2dldFRpbWVMZWZ0KCkgPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fb25FeGVjdXRpb25GaW5pc2hlZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgZGVsYXkoQVNTRVJUSU9OX0RFTEFZKTtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLmluUmV0cnkgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3N0YXJ0LWFzc2VydGlvbi1yZXRyaWVzJywgdGhpcy5fZ2V0VGltZUxlZnQoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHByaXZhdGUgX29uQmVmb3JlUnVuICgpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuY29tbWFuZC5hY3R1YWwgIT09IFN5bWJvbC5mb3IoRlVOQ1RJT05fTUFSS0VSX0RFU0NSSVBUSU9OKSlcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICB0aGlzLmVtaXQoJ25vbi1zZXJpYWxpemFibGUtYWN0dWFsLXZhbHVlJywgdGhpcyk7XG4gICAgfVxuXG4gICAgcHVibGljIGFzeW5jIHJ1biAoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIHRoaXMuX29uQmVmb3JlUnVuKCk7XG5cbiAgICAgICAgdGhpcy5zdGFydFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5mbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgaWYgKGVyci5uYW1lID09PSAnQXNzZXJ0aW9uRXJyb3InIHx8IGVyci5jb25zdHJ1Y3Rvci5uYW1lID09PSAnQXNzZXJ0aW9uRXJyb3InKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFeHRlcm5hbEFzc2VydGlvbkxpYnJhcnlFcnJvcihlcnIsIHRoaXMuY2FsbHNpdGUpO1xuXG4gICAgICAgICAgICBpZiAoZXJyLmlzVGVzdENhZmVFcnJvcilcbiAgICAgICAgICAgICAgICBlcnIuY2FsbHNpdGUgPSB0aGlzLmNhbGxzaXRlO1xuXG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICB9XG59XG4iXX0=