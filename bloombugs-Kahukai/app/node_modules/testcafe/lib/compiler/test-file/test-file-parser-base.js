"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TestFileParserBase = exports.Test = exports.Fixture = void 0;
const promisified_functions_1 = require("../../utils/promisified-functions");
const util_1 = require("util");
const runtime_1 = require("../../errors/runtime");
const types_1 = require("../../errors/types");
const METHODS_SPECIFYING_NAME = ['only', 'skip'];
const COMPUTED_NAME_TEXT_TMP = '<computed name>(line: %s)';
const SKIP_PROPERTY_NAME = 'skip';
function getLoc(loc) {
    // NOTE: Don't modify the Babel's parser data structure
    const locCopy = Object.assign({}, loc);
    // NOTE: 'fileName' and 'identifierName' fields with 'undefined' values added in the SourceLocation class constructor.
    // https://github.com/babel/babel/blob/d51aa6d76177b544590cdfe3868f9f4d33d8813d/packages/babel-parser/src/util/location.js#L22
    // Since this is useless information, we remove it.
    delete locCopy.filename;
    delete locCopy.identifierName;
    return locCopy;
}
class Fixture {
    constructor(name, start, end, loc, meta, isSkipped) {
        this.name = name;
        this.loc = getLoc(loc);
        this.start = start;
        this.end = end;
        this.meta = meta;
        this.tests = [];
        this.isSkipped = !!isSkipped;
    }
}
exports.Fixture = Fixture;
class Test {
    constructor(name, start, end, loc, meta, isSkipped) {
        this.name = name;
        this.loc = getLoc(loc);
        this.start = start;
        this.end = end;
        this.meta = meta;
        this.isSkipped = !!isSkipped;
    }
}
exports.Test = Test;
class TestFileParserBase {
    constructor(tokenType) {
        this.tokenType = tokenType;
    }
    static formatComputedName(line) {
        return util_1.format(COMPUTED_NAME_TEXT_TMP, line);
    }
    isAsyncFn( /* token */) {
        throw new Error('Not implemented');
    }
    getRValue( /* token */) {
        throw new Error('Not implemented');
    }
    getFunctionBody( /* token */) {
        throw new Error('Not implemented');
    }
    formatFnData( /* name, value, token */) {
        throw new Error('Not implemented');
    }
    analyzeMemberExp( /* token */) {
        throw new Error('Not implemented');
    }
    formatFnArg( /* arg */) {
        throw new Error('Not implemented');
    }
    getFnCall( /* token */) {
        throw new Error('Not implemented');
    }
    getTaggedTemplateExp( /* token */) {
        throw new Error('Not implemented');
    }
    analyzeFnCall( /* token */) {
        throw new Error('Not implemented');
    }
    parse( /* filePath, code */) {
        throw new Error('Not implemented');
    }
    getTokenType( /* token */) {
        throw new Error('Not implemented');
    }
    getCalleeToken( /* token */) {
        throw new Error('Not implemented');
    }
    getMemberFnName() {
        throw new Error('Not implemented');
    }
    getKeyValue() {
        throw new Error('Not implemented');
    }
    getStringValue() {
        throw new Error('Not implemented');
    }
    isApiFn(fn) {
        return fn === 'fixture' || fn === 'test';
    }
    serializeObjExp(token) {
        if (this.getTokenType(token) !== this.tokenType.ObjectLiteralExpression)
            return {};
        return token.properties.reduce((obj, prop) => {
            const { key, value } = this.getKeyValue(prop);
            if (typeof value !== 'string')
                return {};
            obj[key] = value;
            return obj;
        }, {});
    }
    processMetaArgs(token) {
        if (this.getTokenType(token) !== this.tokenType.CallExpression)
            return null;
        const args = token.arguments;
        let meta = {};
        if (args.length === 2) {
            const value = this.getStringValue(args[1]);
            if (typeof value !== 'string')
                return {};
            meta = { [this.formatFnArg(args[0])]: value };
        }
        else if (args.length === 1)
            meta = this.serializeObjExp(args[0]);
        return meta;
    }
    getMetaInfo(callStack) {
        return callStack.reduce((metaCalls, exp) => {
            if (this.getTokenType(exp) !== this.tokenType.CallExpression)
                return metaCalls;
            const callee = this.getCalleeToken(exp);
            const calleeType = this.getTokenType(callee);
            const isCalleeMemberExp = calleeType === this.tokenType.PropertyAccessExpression;
            if (isCalleeMemberExp && this.getMemberFnName(exp) === 'meta')
                return [this.processMetaArgs(exp)].concat(metaCalls);
            return metaCalls;
        }, []);
    }
    static isSkipped(originalToken, token = originalToken) {
        var _a, _b;
        const needSkip = ((_a = token === null || token === void 0 ? void 0 : token.property) === null || _a === void 0 ? void 0 : _a.name) === SKIP_PROPERTY_NAME || ((_b = token === null || token === void 0 ? void 0 : token.name) === null || _b === void 0 ? void 0 : _b.text) === SKIP_PROPERTY_NAME;
        if (!needSkip) {
            token = token.callee || token.tag || token.object || token.expression;
            return token ? TestFileParserBase.isSkipped(originalToken, token) : false;
        }
        return true;
    }
    checkExpDefineTargetName(type, apiFn) {
        //NOTE: fixture('fixtureName').chainFn or test('testName').chainFn
        const isDirectCall = type === this.tokenType.Identifier;
        //NOTE: fixture.skip('fixtureName'), test.only('testName') etc.
        const isMemberCall = type === this.tokenType.PropertyAccessExpression &&
            METHODS_SPECIFYING_NAME.indexOf(apiFn) > -1;
        //NOTE: fixture.before().after()('fixtureName'), test.before()`testName`.after() etc.
        const isTailCall = type === this.tokenType.CallExpression;
        return isDirectCall || isMemberCall || isTailCall;
    }
    analyzeToken(token) {
        const tokenType = this.tokenType;
        const currTokenType = this.getTokenType(token);
        switch (currTokenType) {
            case tokenType.ExpressionStatement:
            case tokenType.TypeAssertionExpression:
                return this.analyzeToken(token.expression);
            case tokenType.FunctionDeclaration:
            case tokenType.FunctionExpression:
                if (this.isAsyncFn(token))
                    return null;
                return this.getFunctionBody(token).map(this.analyzeToken, this);
            case tokenType.VariableDeclaration:
            case tokenType.VariableStatement: {
                const variableValue = this.getRValue(token); // Skip variable declarations like `var foo;`
                return variableValue ? this.analyzeToken(variableValue) : null;
            }
            case tokenType.CallExpression:
            case tokenType.PropertyAccessExpression:
            case tokenType.TaggedTemplateExpression:
                return this.analyzeFnCall(token);
            case tokenType.ReturnStatement:
                return token.argument ? this.analyzeToken(token.argument) : null;
        }
        return null;
    }
    collectTestCafeCalls(astBody) {
        let calls = [];
        astBody.forEach(token => {
            const callExps = this.analyzeToken(token);
            if (callExps)
                calls = calls.concat(callExps);
        });
        return calls;
    }
    analyze(astBody) {
        const fixtures = [];
        const testCafeAPICalls = this.collectTestCafeCalls(astBody);
        testCafeAPICalls.forEach(call => {
            if (!call || typeof call.value !== 'string')
                return;
            if (call.fnName === 'fixture') {
                fixtures.push(new Fixture(call.value, call.start, call.end, call.loc, call.meta, call.isSkipped));
                return;
            }
            if (!fixtures.length)
                return;
            // NOTE: If the fixture is skipped, mark all the tests in the fixture skipped, otherwise, use the current test identifier
            const currentFixture = fixtures[fixtures.length - 1];
            const testIsSkipped = currentFixture.isSkipped || call.isSkipped;
            const test = new Test(call.value, call.start, call.end, call.loc, call.meta, testIsSkipped);
            currentFixture.tests.push(test);
        });
        return fixtures;
    }
    async readFile(filePath) {
        let fileContent = '';
        try {
            fileContent = await promisified_functions_1.readFile(filePath, 'utf8');
        }
        catch (err) {
            throw new runtime_1.GeneralError(types_1.RUNTIME_ERRORS.cannotFindSpecifiedTestSource, filePath);
        }
        return fileContent;
    }
    async getTestList(filePath) {
        const fileContent = await this.readFile(filePath);
        return this.parse(fileContent);
    }
    getTestListFromCode(code) {
        return this.parse(code);
    }
}
exports.TestFileParserBase = TestFileParserBase;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGVzdC1maWxlLXBhcnNlci1iYXNlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2NvbXBpbGVyL3Rlc3QtZmlsZS90ZXN0LWZpbGUtcGFyc2VyLWJhc2UuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsNkVBQTZEO0FBQzdELCtCQUE4QjtBQUM5QixrREFBb0Q7QUFDcEQsOENBQW9EO0FBRXBELE1BQU0sdUJBQXVCLEdBQUcsQ0FBQyxNQUFNLEVBQUUsTUFBTSxDQUFDLENBQUM7QUFDakQsTUFBTSxzQkFBc0IsR0FBSSwyQkFBMkIsQ0FBQztBQUM1RCxNQUFNLGtCQUFrQixHQUFRLE1BQU0sQ0FBQztBQUV2QyxTQUFTLE1BQU0sQ0FBRSxHQUFHO0lBQ2hCLHVEQUF1RDtJQUN2RCxNQUFNLE9BQU8sR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLEVBQUUsRUFBRSxHQUFHLENBQUMsQ0FBQztJQUV2QyxzSEFBc0g7SUFDdEgsOEhBQThIO0lBQzlILG1EQUFtRDtJQUNuRCxPQUFPLE9BQU8sQ0FBQyxRQUFRLENBQUM7SUFDeEIsT0FBTyxPQUFPLENBQUMsY0FBYyxDQUFDO0lBRTlCLE9BQU8sT0FBTyxDQUFDO0FBQ25CLENBQUM7QUFFRCxNQUFhLE9BQU87SUFDaEIsWUFBYSxJQUFJLEVBQUUsS0FBSyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsSUFBSSxFQUFFLFNBQVM7UUFDL0MsSUFBSSxDQUFDLElBQUksR0FBUSxJQUFJLENBQUM7UUFDdEIsSUFBSSxDQUFDLEdBQUcsR0FBUyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDN0IsSUFBSSxDQUFDLEtBQUssR0FBTyxLQUFLLENBQUM7UUFDdkIsSUFBSSxDQUFDLEdBQUcsR0FBUyxHQUFHLENBQUM7UUFDckIsSUFBSSxDQUFDLElBQUksR0FBUSxJQUFJLENBQUM7UUFDdEIsSUFBSSxDQUFDLEtBQUssR0FBTyxFQUFFLENBQUM7UUFDcEIsSUFBSSxDQUFDLFNB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QyxRQUFRLENBQUUsUUFBUTtRQUNwQixJQUFJLFdBQVcsR0FBRyxFQUFFLENBQUM7UUFFckIsSUFBSTtZQUNBLFdBQVcsR0FBRyxNQUFNLGdDQUFRLENBQUMsUUFBUSxFQUFFLE1BQU0sQ0FBQyxDQUFDO1NBQ2xEO1FBRUQsT0FBTyxHQUFHLEVBQUU7WUFDUixNQUFNLElBQUksc0JBQVksQ0FBQyxzQkFBYyxDQUFDLDZCQUE2QixFQUFFLFFBQVEsQ0FBQyxDQUFDO1NBQ2xGO1FBRUQsT0FBTyxXQUFXLENBQUM7SUFDdkIsQ0FBQztJQUVELEtBQUssQ0FBQyxXQUFXLENBQUUsUUFBUTtRQUN2QixNQUFNLFdBQVcsR0FBRyxNQUFNLElBQUksQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLENBQUM7UUFFbEQsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLFdBQVcsQ0FBQyxDQUFDO0lBQ25DLENBQUM7SUFFRCxtQkFBbUIsQ0FBRSxJQUFJO1FBQ3JCLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUM1QixDQUFDO0NBQ0o7QUF4UEQsZ0RBd1BDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcmVhZEZpbGUgfSBmcm9tICcuLi8uLi91dGlscy9wcm9taXNpZmllZC1mdW5jdGlvbnMnO1xuaW1wb3J0IHsgZm9ybWF0IH0gZnJvbSAndXRpbCc7XG5pbXBvcnQgeyBHZW5lcmFsRXJyb3IgfSBmcm9tICcuLi8uLi9lcnJvcnMvcnVudGltZSc7XG5pbXBvcnQgeyBSVU5USU1FX0VSUk9SUyB9IGZyb20gJy4uLy4uL2Vycm9ycy90eXBlcyc7XG5cbmNvbnN0IE1FVEhPRFNfU1BFQ0lGWUlOR19OQU1FID0gWydvbmx5JywgJ3NraXAnXTtcbmNvbnN0IENPTVBVVEVEX05BTUVfVEVYVF9UTVAgID0gJzxjb21wdXRlZCBuYW1lPihsaW5lOiAlcyknO1xuY29uc3QgU0tJUF9QUk9QRVJUWV9OQU1FICAgICAgPSAnc2tpcCc7XG5cbmZ1bmN0aW9uIGdldExvYyAobG9jKSB7XG4gICAgLy8gTk9URTogRG9uJ3QgbW9kaWZ5IHRoZSBCYWJlbCdzIHBhcnNlciBkYXRhIHN0cnVjdHVyZVxuICAgIGNvbnN0IGxvY0NvcHkgPSBPYmplY3QuYXNzaWduKHt9LCBsb2MpO1xuXG4gICAgLy8gTk9URTogJ2ZpbGVOYW1lJyBhbmQgJ2lkZW50aWZpZXJOYW1lJyBmaWVsZHMgd2l0aCAndW5kZWZpbmVkJyB2YWx1ZXMgYWRkZWQgaW4gdGhlIFNvdXJjZUxvY2F0aW9uIGNsYXNzIGNvbnN0cnVjdG9yLlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iYWJlbC9iYWJlbC9ibG9iL2Q1MWFhNmQ3NjE3N2I1NDQ1OTBjZGZlMzg2OGY5ZjRkMzNkODgxM2QvcGFja2FnZXMvYmFiZWwtcGFyc2VyL3NyYy91dGlsL2xvY2F0aW9uLmpzI0wyMlxuICAgIC8vIFNpbmNlIHRoaXMgaXMgdXNlbGVzcyBpbmZvcm1hdGlvbiwgd2UgcmVtb3ZlIGl0LlxuICAgIGRlbGV0ZSBsb2NDb3B5LmZpbGVuYW1lO1xuICAgIGRlbGV0ZSBsb2NDb3B5LmlkZW50aWZpZXJOYW1lO1xuXG4gICAgcmV0dXJuIGxvY0NvcHk7XG59XG5cbmV4cG9ydCBjbGFzcyBGaXh0dXJlIHtcbiAgICBjb25zdHJ1Y3RvciAobmFtZSwgc3RhcnQsIGVuZCwgbG9jLCBtZXRhLCBpc1NraXBwZWQpIHtcbiAgICAgICAgdGhpcy5uYW1lICAgICAgPSBuYW1lO1xuICAgICAgICB0aGlzLmxvYyAgICAgICA9IGdldExvYyhsb2MpO1xuICAgICAgICB0aGlzLnN0YXJ0ICAgICA9IHN0YXJ0O1xuICAgICAgICB0aGlzLmVuZCAgICAgICA9IGVuZDtcbiAgICAgICAgdGhpcy5tZXRhICAgICAgPSBtZXRhO1xuICAgICAgICB0aGlzLnRlc3RzICAgICA9IFtdO1xuICAgICAgICB0aGlzLmlzU2tpcHBlZCA9ICEhaXNTa2lwcGVkO1xuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIFRlc3Qge1xuICAgIGNvbnN0cnVjdG9yIChuYW1lLCBzdGFydCwgZW5kLCBsb2MsIG1ldGEsIGlzU2tpcHBlZCkge1xuICAgICAgICB0aGlzLm5hbWUgICAgICA9IG5hbWU7XG4gICAgICAgIHRoaXMubG9jICAgICAgID0gZ2V0TG9jKGxvYyk7XG4gICAgICAgIHRoaXMuc3RhcnQgICAgID0gc3RhcnQ7XG4gICAgICAgIHRoaXMuZW5kICAgICAgID0gZW5kO1xuICAgICAgICB0aGlzLm1ldGEgICAgICA9IG1ldGE7XG4gICAgICAgIHRoaXMuaXNTa2lwcGVkID0gISFpc1NraXBwZWQ7XG4gICAgfVxufVxuXG5leHBvcnQgY2xhc3MgVGVzdEZpbGVQYXJzZXJCYXNlIHtcbiAgICBjb25zdHJ1Y3RvciAodG9rZW5UeXBlKSB7XG4gICAgICAgIHRoaXMudG9rZW5UeXBlID0gdG9rZW5UeXBlO1xuICAgIH1cblxuICAgIHN0YXRpYyBmb3JtYXRDb21wdXRlZE5hbWUgKGxpbmUpIHtcbiAgICAgICAgcmV0dXJuIGZvcm1hdChDT01QVVRFRF9OQU1FX1RFWFRfVE1QLCBsaW5lKTtcbiAgICB9XG5cbiAgICBpc0FzeW5jRm4gKC8qIHRva2VuICovKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7XG4gICAgfVxuXG4gICAgZ2V0UlZhbHVlICgvKiB0b2tlbiAqLykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZCcpO1xuICAgIH1cblxuICAgIGdldEZ1bmN0aW9uQm9keSAoLyogdG9rZW4gKi8pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQnKTtcbiAgICB9XG5cbiAgICBmb3JtYXRGbkRhdGEgKC8qIG5hbWUsIHZhbHVlLCB0b2tlbiAqLykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZCcpO1xuICAgIH1cblxuICAgIGFuYWx5emVNZW1iZXJFeHAgKC8qIHRva2VuICovKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7XG4gICAgfVxuXG4gICAgZm9ybWF0Rm5BcmcgKC8qIGFyZyAqLykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZCcpO1xuICAgIH1cblxuICAgIGdldEZuQ2FsbCAoLyogdG9rZW4gKi8pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQnKTtcbiAgICB9XG5cbiAgICBnZXRUYWdnZWRUZW1wbGF0ZUV4cCAoLyogdG9rZW4gKi8pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQnKTtcbiAgICB9XG5cbiAgICBhbmFseXplRm5DYWxsICgvKiB0b2tlbiAqLykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZCcpO1xuICAgIH1cblxuICAgIHBhcnNlICgvKiBmaWxlUGF0aCwgY29kZSAqLykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZCcpO1xuICAgIH1cblxuICAgIGdldFRva2VuVHlwZSAoLyogdG9rZW4gKi8pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQnKTtcbiAgICB9XG5cbiAgICBnZXRDYWxsZWVUb2tlbiAoLyogdG9rZW4gKi8pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQnKTtcbiAgICB9XG5cbiAgICBnZXRNZW1iZXJGbk5hbWUgKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZCcpO1xuICAgIH1cblxuICAgIGdldEtleVZhbHVlICgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQnKTtcbiAgICB9XG5cbiAgICBnZXRTdHJpbmdWYWx1ZSAoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7XG4gICAgfVxuXG4gICAgaXNBcGlGbiAoZm4pIHtcbiAgICAgICAgcmV0dXJuIGZuID09PSAnZml4dHVyZScgfHwgZm4gPT09ICd0ZXN0JztcbiAgICB9XG5cbiAgICBzZXJpYWxpemVPYmpFeHAgKHRva2VuKSB7XG4gICAgICAgIGlmICh0aGlzLmdldFRva2VuVHlwZSh0b2tlbikgIT09IHRoaXMudG9rZW5UeXBlLk9iamVjdExpdGVyYWxFeHByZXNzaW9uKVxuICAgICAgICAgICAgcmV0dXJuIHt9O1xuXG4gICAgICAgIHJldHVybiB0b2tlbi5wcm9wZXJ0aWVzLnJlZHVjZSgob2JqLCBwcm9wKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGtleSwgdmFsdWUgfSA9IHRoaXMuZ2V0S2V5VmFsdWUocHJvcCk7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSByZXR1cm4ge307XG5cbiAgICAgICAgICAgIG9ialtrZXldID0gdmFsdWU7XG5cbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH0sIHt9KTtcbiAgICB9XG5cbiAgICBwcm9jZXNzTWV0YUFyZ3MgKHRva2VuKSB7XG4gICAgICAgIGlmICh0aGlzLmdldFRva2VuVHlwZSh0b2tlbikgIT09IHRoaXMudG9rZW5UeXBlLkNhbGxFeHByZXNzaW9uKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgY29uc3QgYXJncyA9IHRva2VuLmFyZ3VtZW50cztcblxuICAgICAgICBsZXQgbWV0YSA9IHt9O1xuXG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmdldFN0cmluZ1ZhbHVlKGFyZ3NbMV0pO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykgcmV0dXJuIHt9O1xuXG4gICAgICAgICAgICBtZXRhID0geyBbdGhpcy5mb3JtYXRGbkFyZyhhcmdzWzBdKV06IHZhbHVlIH07XG4gICAgICAgIH1cblxuICAgICAgICBlbHNlIGlmIChhcmdzLmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICAgIG1ldGEgPSB0aGlzLnNlcmlhbGl6ZU9iakV4cChhcmdzWzBdKTtcblxuICAgICAgICByZXR1cm4gbWV0YTtcbiAgICB9XG5cbiAgICBnZXRNZXRhSW5mbyAoY2FsbFN0YWNrKSB7XG4gICAgICAgIHJldHVybiBjYWxsU3RhY2sucmVkdWNlKChtZXRhQ2FsbHMsIGV4cCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0VG9rZW5UeXBlKGV4cCkgIT09IHRoaXMudG9rZW5UeXBlLkNhbGxFeHByZXNzaW9uKVxuICAgICAgICAgICAgICAgIHJldHVybiBtZXRhQ2FsbHM7XG5cbiAgICAgICAgICAgIGNvbnN0IGNhbGxlZSAgICAgICAgICAgID0gdGhpcy5nZXRDYWxsZWVUb2tlbihleHApO1xuICAgICAgICAgICAgY29uc3QgY2FsbGVlVHlwZSAgICAgICAgPSB0aGlzLmdldFRva2VuVHlwZShjYWxsZWUpO1xuICAgICAgICAgICAgY29uc3QgaXNDYWxsZWVNZW1iZXJFeHAgPSBjYWxsZWVUeXBlID09PSB0aGlzLnRva2VuVHlwZS5Qcm9wZXJ0eUFjY2Vzc0V4cHJlc3Npb247XG5cbiAgICAgICAgICAgIGlmIChpc0NhbGxlZU1lbWJlckV4cCAmJiB0aGlzLmdldE1lbWJlckZuTmFtZShleHApID09PSAnbWV0YScpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFt0aGlzLnByb2Nlc3NNZXRhQXJncyhleHApXS5jb25jYXQobWV0YUNhbGxzKTtcblxuICAgICAgICAgICAgcmV0dXJuIG1ldGFDYWxscztcbiAgICAgICAgfSwgW10pO1xuICAgIH1cblxuICAgIHN0YXRpYyBpc1NraXBwZWQgKG9yaWdpbmFsVG9rZW4sIHRva2VuID0gb3JpZ2luYWxUb2tlbikge1xuICAgICAgICBjb25zdCBuZWVkU2tpcCA9IHRva2VuPy5wcm9wZXJ0eT8ubmFtZSA9PT0gU0tJUF9QUk9QRVJUWV9OQU1FIHx8IHRva2VuPy5uYW1lPy50ZXh0ID09PSBTS0lQX1BST1BFUlRZX05BTUU7XG5cbiAgICAgICAgaWYgKCFuZWVkU2tpcCkge1xuICAgICAgICAgICAgdG9rZW4gPSB0b2tlbi5jYWxsZWUgfHwgdG9rZW4udGFnIHx8IHRva2VuLm9iamVjdCB8fCB0b2tlbi5leHByZXNzaW9uO1xuXG4gICAgICAgICAgICByZXR1cm4gdG9rZW4gPyBUZXN0RmlsZVBhcnNlckJhc2UuaXNTa2lwcGVkKG9yaWdpbmFsVG9rZW4sIHRva2VuKSA6IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgY2hlY2tFeHBEZWZpbmVUYXJnZXROYW1lICh0eXBlLCBhcGlGbikge1xuICAgICAgICAvL05PVEU6IGZpeHR1cmUoJ2ZpeHR1cmVOYW1lJykuY2hhaW5GbiBvciB0ZXN0KCd0ZXN0TmFtZScpLmNoYWluRm5cbiAgICAgICAgY29uc3QgaXNEaXJlY3RDYWxsID0gdHlwZSA9PT0gdGhpcy50b2tlblR5cGUuSWRlbnRpZmllcjtcblxuICAgICAgICAvL05PVEU6IGZpeHR1cmUuc2tpcCgnZml4dHVyZU5hbWUnKSwgdGVzdC5vbmx5KCd0ZXN0TmFtZScpIGV0Yy5cbiAgICAgICAgY29uc3QgaXNNZW1iZXJDYWxsID0gdHlwZSA9PT0gdGhpcy50b2tlblR5cGUuUHJvcGVydHlBY2Nlc3NFeHByZXNzaW9uICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1FVEhPRFNfU1BFQ0lGWUlOR19OQU1FLmluZGV4T2YoYXBpRm4pID4gLTE7XG5cbiAgICAgICAgLy9OT1RFOiBmaXh0dXJlLmJlZm9yZSgpLmFmdGVyKCkoJ2ZpeHR1cmVOYW1lJyksIHRlc3QuYmVmb3JlKClgdGVzdE5hbWVgLmFmdGVyKCkgZXRjLlxuICAgICAgICBjb25zdCBpc1RhaWxDYWxsID0gdHlwZSA9PT0gdGhpcy50b2tlblR5cGUuQ2FsbEV4cHJlc3Npb247XG5cbiAgICAgICAgcmV0dXJuIGlzRGlyZWN0Q2FsbCB8fCBpc01lbWJlckNhbGwgfHwgaXNUYWlsQ2FsbDtcbiAgICB9XG5cbiAgICBhbmFseXplVG9rZW4gKHRva2VuKSB7XG4gICAgICAgIGNvbnN0IHRva2VuVHlwZSAgICAgPSB0aGlzLnRva2VuVHlwZTtcbiAgICAgICAgY29uc3QgY3VyclRva2VuVHlwZSA9IHRoaXMuZ2V0VG9rZW5UeXBlKHRva2VuKTtcblxuICAgICAgICBzd2l0Y2ggKGN1cnJUb2tlblR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgdG9rZW5UeXBlLkV4cHJlc3Npb25TdGF0ZW1lbnQ6XG4gICAgICAgICAgICBjYXNlIHRva2VuVHlwZS5UeXBlQXNzZXJ0aW9uRXhwcmVzc2lvbjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hbmFseXplVG9rZW4odG9rZW4uZXhwcmVzc2lvbik7XG5cbiAgICAgICAgICAgIGNhc2UgdG9rZW5UeXBlLkZ1bmN0aW9uRGVjbGFyYXRpb246XG4gICAgICAgICAgICBjYXNlIHRva2VuVHlwZS5GdW5jdGlvbkV4cHJlc3Npb246XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNBc3luY0ZuKHRva2VuKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRGdW5jdGlvbkJvZHkodG9rZW4pLm1hcCh0aGlzLmFuYWx5emVUb2tlbiwgdGhpcyk7XG5cbiAgICAgICAgICAgIGNhc2UgdG9rZW5UeXBlLlZhcmlhYmxlRGVjbGFyYXRpb246XG4gICAgICAgICAgICBjYXNlIHRva2VuVHlwZS5WYXJpYWJsZVN0YXRlbWVudDoge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhcmlhYmxlVmFsdWUgPSB0aGlzLmdldFJWYWx1ZSh0b2tlbik7IC8vIFNraXAgdmFyaWFibGUgZGVjbGFyYXRpb25zIGxpa2UgYHZhciBmb287YFxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhcmlhYmxlVmFsdWUgPyB0aGlzLmFuYWx5emVUb2tlbih2YXJpYWJsZVZhbHVlKSA6IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIHRva2VuVHlwZS5DYWxsRXhwcmVzc2lvbjpcbiAgICAgICAgICAgIGNhc2UgdG9rZW5UeXBlLlByb3BlcnR5QWNjZXNzRXhwcmVzc2lvbjpcbiAgICAgICAgICAgIGNhc2UgdG9rZW5UeXBlLlRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hbmFseXplRm5DYWxsKHRva2VuKTtcblxuICAgICAgICAgICAgY2FzZSB0b2tlblR5cGUuUmV0dXJuU3RhdGVtZW50OlxuICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbi5hcmd1bWVudCA/IHRoaXMuYW5hbHl6ZVRva2VuKHRva2VuLmFyZ3VtZW50KSA6IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb2xsZWN0VGVzdENhZmVDYWxscyAoYXN0Qm9keSkge1xuICAgICAgICBsZXQgY2FsbHMgPSBbXTtcblxuICAgICAgICBhc3RCb2R5LmZvckVhY2godG9rZW4gPT4ge1xuICAgICAgICAgICAgY29uc3QgY2FsbEV4cHMgPSB0aGlzLmFuYWx5emVUb2tlbih0b2tlbik7XG5cbiAgICAgICAgICAgIGlmIChjYWxsRXhwcylcbiAgICAgICAgICAgICAgICBjYWxscyA9IGNhbGxzLmNvbmNhdChjYWxsRXhwcyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBjYWxscztcbiAgICB9XG5cbiAgICBhbmFseXplIChhc3RCb2R5KSB7XG4gICAgICAgIGNvbnN0IGZpeHR1cmVzICAgICAgICAgPSBbXTtcbiAgICAgICAgY29uc3QgdGVzdENhZmVBUElDYWxscyA9IHRoaXMuY29sbGVjdFRlc3RDYWZlQ2FsbHMoYXN0Qm9keSk7XG5cbiAgICAgICAgdGVzdENhZmVBUElDYWxscy5mb3JFYWNoKGNhbGwgPT4ge1xuICAgICAgICAgICAgaWYgKCFjYWxsIHx8IHR5cGVvZiBjYWxsLnZhbHVlICE9PSAnc3RyaW5nJykgcmV0dXJuO1xuXG4gICAgICAgICAgICBpZiAoY2FsbC5mbk5hbWUgPT09ICdmaXh0dXJlJykge1xuICAgICAgICAgICAgICAgIGZpeHR1cmVzLnB1c2gobmV3IEZpeHR1cmUoY2FsbC52YWx1ZSwgY2FsbC5zdGFydCwgY2FsbC5lbmQsIGNhbGwubG9jLCBjYWxsLm1ldGEsIGNhbGwuaXNTa2lwcGVkKSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghZml4dHVyZXMubGVuZ3RoKSByZXR1cm47XG5cbiAgICAgICAgICAgIC8vIE5PVEU6IElmIHRoZSBmaXh0dXJlIGlzIHNraXBwZWQsIG1hcmsgYWxsIHRoZSB0ZXN0cyBpbiB0aGUgZml4dHVyZSBza2lwcGVkLCBvdGhlcndpc2UsIHVzZSB0aGUgY3VycmVudCB0ZXN0IGlkZW50aWZpZXJcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRGaXh0dXJlID0gZml4dHVyZXNbZml4dHVyZXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBjb25zdCB0ZXN0SXNTa2lwcGVkICA9IGN1cnJlbnRGaXh0dXJlLmlzU2tpcHBlZCB8fCBjYWxsLmlzU2tpcHBlZDtcbiAgICAgICAgICAgIGNvbnN0IHRlc3QgICAgICAgICAgID0gbmV3IFRlc3QoY2FsbC52YWx1ZSwgY2FsbC5zdGFydCwgY2FsbC5lbmQsIGNhbGwubG9jLCBjYWxsLm1ldGEsIHRlc3RJc1NraXBwZWQpO1xuXG4gICAgICAgICAgICBjdXJyZW50Rml4dHVyZS50ZXN0cy5wdXNoKHRlc3QpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gZml4dHVyZXM7XG4gICAgfVxuXG4gICAgYXN5bmMgcmVhZEZpbGUgKGZpbGVQYXRoKSB7XG4gICAgICAgIGxldCBmaWxlQ29udGVudCA9ICcnO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmaWxlQ29udGVudCA9IGF3YWl0IHJlYWRGaWxlKGZpbGVQYXRoLCAndXRmOCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEdlbmVyYWxFcnJvcihSVU5USU1FX0VSUk9SUy5jYW5ub3RGaW5kU3BlY2lmaWVkVGVzdFNvdXJjZSwgZmlsZVBhdGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZpbGVDb250ZW50O1xuICAgIH1cblxuICAgIGFzeW5jIGdldFRlc3RMaXN0IChmaWxlUGF0aCkge1xuICAgICAgICBjb25zdCBmaWxlQ29udGVudCA9IGF3YWl0IHRoaXMucmVhZEZpbGUoZmlsZVBhdGgpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlKGZpbGVDb250ZW50KTtcbiAgICB9XG5cbiAgICBnZXRUZXN0TGlzdEZyb21Db2RlIChjb2RlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlKGNvZGUpO1xuICAgIH1cbn1cbiJdfQ==