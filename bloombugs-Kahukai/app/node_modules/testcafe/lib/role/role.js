"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
const phase_1 = __importDefault(require("./phase"));
const testcafe_hammerhead_1 = require("testcafe-hammerhead");
const marker_symbol_1 = __importDefault(require("./marker-symbol"));
const nanoid_1 = __importDefault(require("nanoid"));
class Role extends events_1.EventEmitter {
    constructor(loginUrl, initFn, options = {}) {
        super();
        this[marker_symbol_1.default] = true;
        this.id = nanoid_1.default(7);
        this.phase = loginUrl ? phase_1.default.uninitialized : phase_1.default.initialized;
        this.loginUrl = loginUrl;
        this._initFn = initFn;
        this.opts = options;
        this.redirectUrl = null;
        this.stateSnapshot = testcafe_hammerhead_1.StateSnapshot.empty();
        this.initErr = null;
    }
    async _storeStateSnapshot(testRun) {
        var _a;
        if (this.initErr)
            return;
        this.stateSnapshot = await testRun.getStateSnapshot();
        await ((_a = testRun === null || testRun === void 0 ? void 0 : testRun.compilerService) === null || _a === void 0 ? void 0 : _a.updateRoleProperty({
            roleId: this.id,
            name: 'stateSnapshot',
            value: this.stateSnapshot,
        }));
    }
    _wrapTestFn(testRun) {
        this._initFn = () => {
            var _a;
            return (_a = testRun.compilerService) === null || _a === void 0 ? void 0 : _a.executeRoleInitFn({
                testRunId: testRun.id,
                roleId: this.id,
            });
        };
    }
    async _executeInitFn(testRun) {
        var _a;
        try {
            if (testRun.compilerService)
                this._wrapTestFn(testRun);
            let fn = () => this._initFn(testRun);
            fn = testRun.decoratePreventEmitActionEvents(fn, { prevent: false });
            fn = testRun.decorateDisableDebugBreakpoints(fn, { disable: false });
            await fn();
        }
        catch (err) {
            this.initErr = err;
            await ((_a = testRun === null || testRun === void 0 ? void 0 : testRun.compilerService) === null || _a === void 0 ? void 0 : _a.updateRoleProperty({
                roleId: this.id,
                name: 'initErr',
                value: this.initErr,
            }));
        }
    }
    async initialize(testRun) {
        var _a;
        this.phase = phase_1.default.pendingInitialization;
        await testRun.switchToCleanRun(this.loginUrl);
        await this._executeInitFn(testRun);
        await this._storeStateSnapshot(testRun);
        if (this.opts.preserveUrl)
            await this.setCurrentUrlAsRedirectUrl(testRun);
        this.phase = phase_1.default.initialized;
        await ((_a = testRun.compilerService) === null || _a === void 0 ? void 0 : _a.updateRoleProperty({
            roleId: this.id,
            name: 'phase',
            value: this.phase,
        }));
        this.emit('initialized');
    }
    async setCurrentUrlAsRedirectUrl(testRun) {
        var _a;
        this.redirectUrl = await testRun.getCurrentUrl();
        await ((_a = testRun.compilerService) === null || _a === void 0 ? void 0 : _a.updateRoleProperty({
            roleId: this.id,
            name: 'redirectUrl',
            value: this.redirectUrl,
        }));
    }
    static from(init) {
        if (!init)
            return null;
        const serializedRole = init;
        const role = new Role(serializedRole.loginUrl, serializedRole._initFn, serializedRole.opts);
        role.id = serializedRole.id;
        role.phase = serializedRole.phase;
        role.redirectUrl = serializedRole.redirectUrl;
        role.stateSnapshot = serializedRole.stateSnapshot;
        role.initErr = serializedRole.initErr;
        return role;
    }
}
exports.default = Role;
module.exports = exports.default;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicm9sZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9yb2xlL3JvbGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxtQ0FBc0M7QUFDdEMsb0RBQWdDO0FBQ2hDLDZEQUFvRDtBQUNwRCxvRUFBeUM7QUFDekMsb0RBQTRCO0FBRzVCLE1BQXFCLElBQUssU0FBUSxxQkFBWTtJQVcxQyxZQUFvQixRQUF1QixFQUFFLE1BQXVCLEVBQUUsT0FBTyxHQUFHLEVBQUU7UUFDOUUsS0FBSyxFQUFFLENBQUM7UUFFUixJQUFJLENBQUMsdUJBQVUsQ0FBQyxHQUFLLElBQUksQ0FBQztRQUMxQixJQUFJLENBQUMsRUFBRSxHQUFjLGdCQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDL0IsSUFBSSxDQUFDLEtBQUssR0FBVyxRQUFRLENBQUMsQ0FBQyxDQUFDLGVBQVMsQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDLGVBQVMsQ0FBQyxXQUFXLENBQUM7UUFDaEYsSUFBSSxDQUFDLFFBQVEsR0FBUSxRQUFRLENBQUM7UUFDOUIsSUFBSSxDQUFDLE9BQU8sR0FBUyxNQUFNLENBQUM7UUFDNUIsSUFBSSxDQUFDLElBQUksR0FBWSxPQUFPLENBQUM7UUFDN0IsSUFBSSxDQUFDLFdBQVcsR0FBSyxJQUFJLENBQUM7UUFDMUIsSUFBSSxDQUFDLGFBQWEsR0FBRyxtQ0FBYSxDQUFDLEtBQUssRUFBRSxDQUFDO1FBQzNDLElBQUksQ0FBQyxPQUFPLEdBQVMsSUFBSSxDQUFDO0lBQzlCLENBQUM7SUFFTyxLQUFLLENBQUMsbUJBQW1CLENBQUUsT0FBZ0I7O1FBQy9DLElBQUksSUFBSSxDQUFDLE9BQU87WUFDWixPQUFPO1FBRVgsSUFBSSxDQUFDLGFBQWEsR0FBRyxNQUFNLE9BQU8sQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDO1FBRXRELGFBQU0sT0FBTyxhQUFQLE9BQU8sdUJBQVAsT0FBTyxDQUFFLGVBQWUsMENBQUUsa0JBQWtCLENBQUM7WUFD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TSxjQUFjLEdBQUcsSUFBWSxDQUFDO1FBRXBDLE1BQU0sSUFBSSxHQUFHLElBQUksSUFBSSxDQUFDLGNBQWMsQ0FBQyxRQUFRLEVBQUUsY0FBYyxDQUFDLE9BQU8sRUFBRSxjQUFjLENBQUMsSUFBSSxDQUFDLENBQUM7UUFFNUYsSUFBSSxDQUFDLEVBQUUsR0FBYyxjQUFjLENBQUMsRUFBRSxDQUFDO1FBQ3ZDLElBQUksQ0FBQyxLQUFLLEdBQVcsY0FBYyxDQUFDLEtBQUssQ0FBQztRQUMxQyxJQUFJLENBQUMsV0FBVyxHQUFLLGNBQWMsQ0FBQyxXQUFXLENBQUM7UUFDaEQsSUFBSSxDQUFDLGFBQWEsR0FBRyxjQUFjLENBQUMsYUFBYSxDQUFDO1FBQ2xELElBQUksQ0FBQyxPQUFPLEdBQVMsY0FBYyxDQUFDLE9BQU8sQ0FBQztRQUU1QyxPQUFPLElBQUksQ0FBQztJQUNoQixDQUFDO0NBQ0o7QUF0SEQsdUJBc0hDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnZXZlbnRzJztcbmltcG9ydCBSb2xlUGhhc2UgZnJvbSAnLi9waGFzZSc7XG5pbXBvcnQgeyBTdGF0ZVNuYXBzaG90IH0gZnJvbSAndGVzdGNhZmUtaGFtbWVyaGVhZCc7XG5pbXBvcnQgcm9sZU1hcmtlciBmcm9tICcuL21hcmtlci1zeW1ib2wnO1xuaW1wb3J0IG5hbm9pZCBmcm9tICduYW5vaWQnO1xuaW1wb3J0IFRlc3RSdW4gZnJvbSAnLi4vdGVzdC1ydW4nO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSb2xlIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgICBwdWJsaWMgaWQ6IHN0cmluZztcbiAgICBwdWJsaWMgcGhhc2U6IFJvbGVQaGFzZTtcbiAgICBwdWJsaWMgbG9naW5Vcmw6IHN0cmluZyB8IG51bGw7XG4gICAgcHVibGljIHJlZGlyZWN0VXJsOiBzdHJpbmcgfCBudWxsO1xuICAgIHB1YmxpYyBfaW5pdEZuOiBGdW5jdGlvbiB8IG51bGw7XG4gICAgcHVibGljIG9wdHM6IFJvbGVPcHRpb25zO1xuICAgIHB1YmxpYyBpbml0RXJyOiBudWxsIHwgRXJyb3I7XG4gICAgcHVibGljIHN0YXRlU25hcHNob3Q6IFN0YXRlU25hcHNob3Q7XG4gICAgcHJpdmF0ZSBbcm9sZU1hcmtlcl06IGJvb2xlYW47XG5cbiAgICBwdWJsaWMgY29uc3RydWN0b3IgKGxvZ2luVXJsOiBzdHJpbmcgfCBudWxsLCBpbml0Rm46IEZ1bmN0aW9uIHwgbnVsbCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgdGhpc1tyb2xlTWFya2VyXSAgID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pZCAgICAgICAgICAgID0gbmFub2lkKDcpO1xuICAgICAgICB0aGlzLnBoYXNlICAgICAgICAgPSBsb2dpblVybCA/IFJvbGVQaGFzZS51bmluaXRpYWxpemVkIDogUm9sZVBoYXNlLmluaXRpYWxpemVkO1xuICAgICAgICB0aGlzLmxvZ2luVXJsICAgICAgPSBsb2dpblVybDtcbiAgICAgICAgdGhpcy5faW5pdEZuICAgICAgID0gaW5pdEZuO1xuICAgICAgICB0aGlzLm9wdHMgICAgICAgICAgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLnJlZGlyZWN0VXJsICAgPSBudWxsO1xuICAgICAgICB0aGlzLnN0YXRlU25hcHNob3QgPSBTdGF0ZVNuYXBzaG90LmVtcHR5KCk7XG4gICAgICAgIHRoaXMuaW5pdEVyciAgICAgICA9IG51bGw7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyBfc3RvcmVTdGF0ZVNuYXBzaG90ICh0ZXN0UnVuOiBUZXN0UnVuKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGlmICh0aGlzLmluaXRFcnIpXG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgdGhpcy5zdGF0ZVNuYXBzaG90ID0gYXdhaXQgdGVzdFJ1bi5nZXRTdGF0ZVNuYXBzaG90KCk7XG5cbiAgICAgICAgYXdhaXQgdGVzdFJ1bj8uY29tcGlsZXJTZXJ2aWNlPy51cGRhdGVSb2xlUHJvcGVydHkoe1xuICAgICAgICAgICAgcm9sZUlkOiB0aGlzLmlkLFxuICAgICAgICAgICAgbmFtZTogICAnc3RhdGVTbmFwc2hvdCcsXG4gICAgICAgICAgICB2YWx1ZTogIHRoaXMuc3RhdGVTbmFwc2hvdCxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfd3JhcFRlc3RGbiAodGVzdFJ1bjogVGVzdFJ1bik6IHZvaWQge1xuICAgICAgICB0aGlzLl9pbml0Rm4gPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGVzdFJ1bi5jb21waWxlclNlcnZpY2U/LmV4ZWN1dGVSb2xlSW5pdEZuKHtcbiAgICAgICAgICAgICAgICB0ZXN0UnVuSWQ6IHRlc3RSdW4uaWQsXG4gICAgICAgICAgICAgICAgcm9sZUlkOiAgICB0aGlzLmlkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyBfZXhlY3V0ZUluaXRGbiAodGVzdFJ1bjogVGVzdFJ1bik6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHRlc3RSdW4uY29tcGlsZXJTZXJ2aWNlKVxuICAgICAgICAgICAgICAgIHRoaXMuX3dyYXBUZXN0Rm4odGVzdFJ1bik7XG5cbiAgICAgICAgICAgIGxldCBmbiA9ICgpOiBQcm9taXNlPHZvaWQ+ID0+ICh0aGlzLl9pbml0Rm4gYXMgRnVuY3Rpb24pKHRlc3RSdW4pO1xuXG4gICAgICAgICAgICBmbiA9IHRlc3RSdW4uZGVjb3JhdGVQcmV2ZW50RW1pdEFjdGlvbkV2ZW50cyhmbiwgeyBwcmV2ZW50OiBmYWxzZSB9KTtcbiAgICAgICAgICAgIGZuID0gdGVzdFJ1bi5kZWNvcmF0ZURpc2FibGVEZWJ1Z0JyZWFrcG9pbnRzKGZuLCB7IGRpc2FibGU6IGZhbHNlIH0pO1xuXG4gICAgICAgICAgICBhd2FpdCBmbigpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdEVyciA9IGVycjtcblxuICAgICAgICAgICAgYXdhaXQgdGVzdFJ1bj8uY29tcGlsZXJTZXJ2aWNlPy51cGRhdGVSb2xlUHJvcGVydHkoe1xuICAgICAgICAgICAgICAgIHJvbGVJZDogdGhpcy5pZCxcbiAgICAgICAgICAgICAgICBuYW1lOiAgICdpbml0RXJyJyxcbiAgICAgICAgICAgICAgICB2YWx1ZTogIHRoaXMuaW5pdEVycixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIGFzeW5jIGluaXRpYWxpemUgKHRlc3RSdW46IFRlc3RSdW4pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgdGhpcy5waGFzZSA9IFJvbGVQaGFzZS5wZW5kaW5nSW5pdGlhbGl6YXRpb247XG5cbiAgICAgICAgYXdhaXQgdGVzdFJ1bi5zd2l0Y2hUb0NsZWFuUnVuKHRoaXMubG9naW5VcmwgYXMgc3RyaW5nKTtcblxuICAgICAgICBhd2FpdCB0aGlzLl9leGVjdXRlSW5pdEZuKHRlc3RSdW4pO1xuICAgICAgICBhd2FpdCB0aGlzLl9zdG9yZVN0YXRlU25hcHNob3QodGVzdFJ1bik7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0cy5wcmVzZXJ2ZVVybClcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc2V0Q3VycmVudFVybEFzUmVkaXJlY3RVcmwodGVzdFJ1bik7XG5cbiAgICAgICAgdGhpcy5waGFzZSA9IFJvbGVQaGFzZS5pbml0aWFsaXplZDtcblxuICAgICAgICBhd2FpdCB0ZXN0UnVuLmNvbXBpbGVyU2VydmljZT8udXBkYXRlUm9sZVByb3BlcnR5KHtcbiAgICAgICAgICAgIHJvbGVJZDogdGhpcy5pZCxcbiAgICAgICAgICAgIG5hbWU6ICAgJ3BoYXNlJyxcbiAgICAgICAgICAgIHZhbHVlOiAgdGhpcy5waGFzZSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5lbWl0KCdpbml0aWFsaXplZCcpO1xuICAgIH1cblxuICAgIHB1YmxpYyBhc3luYyBzZXRDdXJyZW50VXJsQXNSZWRpcmVjdFVybCAodGVzdFJ1bjogVGVzdFJ1bik6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICB0aGlzLnJlZGlyZWN0VXJsID0gYXdhaXQgdGVzdFJ1bi5nZXRDdXJyZW50VXJsKCk7XG5cbiAgICAgICAgYXdhaXQgdGVzdFJ1bi5jb21waWxlclNlcnZpY2U/LnVwZGF0ZVJvbGVQcm9wZXJ0eSh7XG4gICAgICAgICAgICByb2xlSWQ6IHRoaXMuaWQsXG4gICAgICAgICAgICBuYW1lOiAgICdyZWRpcmVjdFVybCcsXG4gICAgICAgICAgICB2YWx1ZTogIHRoaXMucmVkaXJlY3RVcmwsXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgZnJvbSAoaW5pdDogdW5rbm93bik6IFJvbGUgfCBudWxsIHtcbiAgICAgICAgaWYgKCFpbml0KVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgY29uc3Qgc2VyaWFsaXplZFJvbGUgPSBpbml0IGFzIFJvbGU7XG5cbiAgICAgICAgY29uc3Qgcm9sZSA9IG5ldyBSb2xlKHNlcmlhbGl6ZWRSb2xlLmxvZ2luVXJsLCBzZXJpYWxpemVkUm9sZS5faW5pdEZuLCBzZXJpYWxpemVkUm9sZS5vcHRzKTtcblxuICAgICAgICByb2xlLmlkICAgICAgICAgICAgPSBzZXJpYWxpemVkUm9sZS5pZDtcbiAgICAgICAgcm9sZS5waGFzZSAgICAgICAgID0gc2VyaWFsaXplZFJvbGUucGhhc2U7XG4gICAgICAgIHJvbGUucmVkaXJlY3RVcmwgICA9IHNlcmlhbGl6ZWRSb2xlLnJlZGlyZWN0VXJsO1xuICAgICAgICByb2xlLnN0YXRlU25hcHNob3QgPSBzZXJpYWxpemVkUm9sZS5zdGF0ZVNuYXBzaG90O1xuICAgICAgICByb2xlLmluaXRFcnIgICAgICAgPSBzZXJpYWxpemVkUm9sZS5pbml0RXJyO1xuXG4gICAgICAgIHJldHVybiByb2xlO1xuICAgIH1cbn1cbiJdfQ==