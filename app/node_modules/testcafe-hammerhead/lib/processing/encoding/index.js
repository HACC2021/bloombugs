"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const zlib_1 = __importDefault(require("zlib"));
const promisified_functions_1 = require("../../utils/promisified-functions");
const brotli_1 = require("./brotli");
const iconv_lite_1 = __importDefault(require("iconv-lite"));
const GZIP_CONTENT_ENCODING = 'gzip';
const DEFLATE_CONTENT_ENCODING = 'deflate';
const BROTLI_CONTENT_ENCODING = 'br';
// NOTE: IIS has a bug when it sends 'raw deflate' compressed data for the 'Deflate' Accept-Encoding header.
// (see: http://zoompf.com/2012/02/lose-the-wait-http-compression)
async function inflateWithFallback(data) {
    try {
        return await promisified_functions_1.inflate(data);
    }
    catch (err) {
        if (err.code === 'Z_DATA_ERROR')
            return await promisified_functions_1.inflateRaw(data);
        throw err;
    }
}
async function decodeContent(content, encoding, charset) {
    if (encoding === GZIP_CONTENT_ENCODING) {
        // NOTE: https://github.com/request/request/pull/2492/files
        // Be more lenient with decoding compressed responses, since (very rarely)
        // servers send slightly invalid gzip responses that are still accepted
        // by common browsers.
        // Always using Z_SYNC_FLUSH is what cURL does.
        // GH-1915
        content = await promisified_functions_1.gunzip(content, { flush: zlib_1.default.Z_SYNC_FLUSH, finishFlush: zlib_1.default.Z_SYNC_FLUSH });
    }
    else if (encoding === DEFLATE_CONTENT_ENCODING)
        content = await inflateWithFallback(content);
    else if (encoding === BROTLI_CONTENT_ENCODING)
        content = await brotli_1.brotliDecompress(content);
    charset.fromBOM(content);
    return iconv_lite_1.default.decode(content, charset.get());
}
exports.decodeContent = decodeContent;
async function encodeContent(content, encoding, charset) {
    const encodedContent = iconv_lite_1.default.encode(content, charset.get(), { addBOM: charset.isFromBOM() });
    if (encoding === GZIP_CONTENT_ENCODING)
        return promisified_functions_1.gzip(encodedContent);
    if (encoding === DEFLATE_CONTENT_ENCODING)
        return promisified_functions_1.deflate(encodedContent);
    if (encoding === BROTLI_CONTENT_ENCODING)
        return brotli_1.brotliCompress(encodedContent);
    return encodedContent;
}
exports.encodeContent = encodeContent;
