import { __assign, __extends } from "tslib";
import clone from 'lodash/clone';
import cloneDeep from 'lodash/cloneDeep';
import isEqual from 'lodash/isEqual';
import noop from 'lodash/noop';
import omit from 'lodash/omit';
import setWith from 'lodash/setWith';
import { BaseForm } from './BaseForm';
export function Validated(Base) {
    // @ts-expect-error: Mixin class problem.
    var ValidatedForm = /** @class */ (function (_super) {
        __extends(ValidatedForm, _super);
        function ValidatedForm(props) {
            var _this = _super.call(this, props) || this;
            _this.state = __assign(__assign({}, _this.state), { error: null, validate: false, validating: false, validator: _this.getContextSchema().getValidator(props.validator) });
            _this.onValidate = _this.validate = _this.onValidate.bind(_this);
            _this.onValidateModel = _this.validateModel =
                _this.onValidateModel.bind(_this);
            return _this;
        }
        ValidatedForm.prototype.getContextError = function () {
            var _a;
            return (_a = _super.prototype.getContextError.call(this)) !== null && _a !== void 0 ? _a : this.state.error;
        };
        ValidatedForm.prototype.getContext = function () {
            return __assign(__assign({}, _super.prototype.getContext.call(this)), { validating: this.state.validating });
        };
        ValidatedForm.prototype.getNativeFormProps = function () {
            return omit(_super.prototype.getNativeFormProps.call(this), [
                'onValidate',
                'validate',
                'validator',
            ]);
        };
        ValidatedForm.prototype.componentDidUpdate = function (prevProps, prevState, snapshot) {
            var _this = this;
            _super.prototype.componentDidUpdate.call(this, prevProps, prevState, snapshot);
            var _a = this.props, model = _a.model, schema = _a.schema, validate = _a.validate, validator = _a.validator;
            if (schema !== prevProps.schema || validator !== prevProps.validator) {
                this.setState({ validator: schema.getValidator(validator) }, function () {
                    if (shouldRevalidate(validate, _this.state.validate)) {
                        _this.onValidate();
                    }
                });
            }
            else if (!isEqual(model, prevProps.model) &&
                shouldRevalidate(validate, this.state.validate)) {
                this.onValidateModel(model);
            }
        };
        ValidatedForm.prototype.onChange = function (key, value) {
            if (shouldRevalidate(this.props.validate, this.state.validate)) {
                this.onValidate(key, value);
            }
            _super.prototype.onChange.call(this, key, value);
        };
        ValidatedForm.prototype.__reset = function (state) {
            return __assign(__assign({}, _super.prototype.__reset.call(this, state)), { error: null, validate: false, validating: false });
        };
        ValidatedForm.prototype.onSubmit = function (event) {
            var _this = this;
            if (event) {
                event.preventDefault();
                event.stopPropagation();
            }
            this.setState({ submitted: true, validate: true });
            var result = this.onValidate().then(function (error) {
                if (error !== null) {
                    return Promise.reject(error);
                }
                // Validation failed (i.e. returned an error), so no error is present
                // both in the props nor the state.
                return _super.prototype.onSubmit.call(_this).catch(function (error) {
                    _this.setState({ error: error });
                    throw error;
                });
            });
            result.catch(noop);
            return result;
        };
        ValidatedForm.prototype.onValidate = function (key, value) {
            var model = this.getContextModel();
            if (model && key) {
                model = setWith(clone(model), key, cloneDeep(value), clone);
            }
            return this.onValidateModel(model);
        };
        ValidatedForm.prototype.onValidateModel = function (originalModel) {
            var _this = this;
            var model = this.getModel('validate', originalModel);
            // Using `then` allows using the same code for both synchronous and
            // asynchronous cases. We could use `await` here, but it would make all
            // calls asynchronous, unnecessary delaying synchronous validation.
            var then = makeThen(function () {
                _this.setState({ validating: true });
            });
            return then(this.state.validator(model), function (error) {
                if (error === void 0) { error = null; }
                return then(_this.props.onValidate(model, error), function (error) {
                    var _a;
                    if (error === void 0) { error = null; }
                    // Do not copy the error from props to the state.
                    error = _this.props.error === error ? null : error;
                    // If the whole operation was synchronous and resulted in the same
                    // error, we can skip the re-render.
                    _this.setState(function (state) {
                        return state.error === error && !state.validating
                            ? null
                            : { error: error, validating: false };
                    });
                    // A predefined error takes precedence over the validation one.
                    return Promise.resolve((_a = _this.props.error) !== null && _a !== void 0 ? _a : error);
                });
            });
        };
        ValidatedForm.Validated = Validated;
        ValidatedForm.displayName = "Validated" + Base.displayName;
        ValidatedForm.defaultProps = __assign(__assign({}, Base.defaultProps), { onValidate: function (model, error) {
                return error;
            }, validate: 'onChangeAfterSubmit' });
        return ValidatedForm;
    }(Base));
    return ValidatedForm;
}
function makeThen(callIfAsync) {
    function then(value, fn) {
        if (value instanceof Promise) {
            callIfAsync();
            return value.then(fn);
        }
        return fn(value);
    }
    return then;
}
function shouldRevalidate(inProps, inState) {
    return (inProps === 'onChange' || (inProps === 'onChangeAfterSubmit' && inState));
}
export var ValidatedForm = Validated(BaseForm);
