"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = require("path");
const lodash_1 = require("lodash");
const internal_modules_prefix_1 = __importDefault(require("./internal-modules-prefix"));
const BABEL = require.resolve('@babel/core');
const BABEL_MODULES_DIR = BABEL.replace(new RegExp(`^(.*${lodash_1.escapeRegExp(path_1.sep)}node_modules${lodash_1.escapeRegExp(path_1.sep)})(.*)`), '$1');
const BABEL_7 = BABEL_MODULES_DIR + '@babel';
const BABEL_RELATED = BABEL_MODULES_DIR + 'babel-';
const REGENERATOR_RUNTIME = BABEL_MODULES_DIR + 'regenerator-runtime' + path_1.sep;
const GENSYNC = BABEL_MODULES_DIR + 'gensync'; // NOTE: @babel/parser uses this module internally.
const TESTCAFE_LIB = path_1.join(__dirname, '../');
const TESTCAFE_BIN = path_1.join(__dirname, '../../bin');
const TESTCAFE_SRC = path_1.join(__dirname, '../../src');
const TESTCAFE_HAMMERHEAD = require.resolve('testcafe-hammerhead');
const SOURCE_MAP_SUPPORT = require.resolve('source-map-support');
const INTERNAL_STARTS_WITH_PATH_SEGMENTS = [
    TESTCAFE_LIB,
    TESTCAFE_BIN,
    TESTCAFE_SRC,
    BABEL_RELATED,
    REGENERATOR_RUNTIME,
    GENSYNC,
    BABEL_7,
    internal_modules_prefix_1.default,
];
const INTERNAL_INCLUDES_PATH_SEGMENTS = [
    SOURCE_MAP_SUPPORT,
    TESTCAFE_HAMMERHEAD,
];
function isInternalFile(filename = '') {
    return !filename ||
        !filename.includes(path_1.sep) ||
        INTERNAL_INCLUDES_PATH_SEGMENTS.some(pathSegment => filename.includes(pathSegment)) ||
        INTERNAL_STARTS_WITH_PATH_SEGMENTS.some(pathSegment => filename.startsWith(pathSegment));
}
function default_1(frame) {
    // NOTE: filter out the internals of node.js and assertion libraries
    const filename = frame.getFileName();
    return isInternalFile(filename);
}
exports.default = default_1;
module.exports = exports.default;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaXMtaW50ZXJuYWwtc3RhY2stZnJhbWUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvZXJyb3JzL2lzLWludGVybmFsLXN0YWNrLWZyYW1lLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsK0JBQWlDO0FBQ2pDLG1DQUFrRDtBQUNsRCx3RkFBZ0U7QUFHaEUsTUFBTSxLQUFLLEdBQWlCLE9BQU8sQ0FBQyxPQUFPLENBQUMsYUFBYSxDQUFDLENBQUM7QUFDM0QsTUFBTSxpQkFBaUIsR0FBSyxLQUFLLENBQUMsT0FBTyxDQUFDLElBQUksTUFBTSxDQUFDLE9BQU8scUJBQVEsQ0FBQyxVQUFHLENBQUMsZUFBZSxxQkFBUSxDQUFDLFVBQUcsQ0FBQyxPQUFPLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQztBQUNySCxNQUFNLE9BQU8sR0FBZSxpQkFBaUIsR0FBRyxRQUFRLENBQUM7QUFDekQsTUFBTSxhQUFhLEdBQVMsaUJBQWlCLEdBQUcsUUFBUSxDQUFDO0FBQ3pELE1BQU0sbUJBQW1CLEdBQUcsaUJBQWlCLEdBQUcscUJBQXFCLEdBQUcsVUFBRyxDQUFDO0FBQzVFLE1BQU0sT0FBTyxHQUFlLGlCQUFpQixHQUFHLFNBQVMsQ0FBQyxDQUFDLG1EQUFtRDtBQUM5RyxNQUFNLFlBQVksR0FBVSxXQUFJLENBQUMsU0FBUyxFQUFFLEtBQUssQ0FBQyxDQUFDO0FBQ25ELE1BQU0sWUFBWSxHQUFVLFdBQUksQ0FBQyxTQUFTLEVBQUUsV0FBVyxDQUFDLENBQUM7QUFDekQsTUFBTSxZQUFZLEdBQVUsV0FBSSxDQUFDLFNBQVMsRUFBRSxXQUFXLENBQUMsQ0FBQztBQUN6RCxNQUFNLG1CQUFtQixHQUFHLE9BQU8sQ0FBQyxPQUFPLENBQUMscUJBQXFCLENBQUMsQ0FBQztBQUNuRSxNQUFNLGtCQUFrQixHQUFJLE9BQU8sQ0FBQyxPQUFPLENBQUMsb0JBQW9CLENBQUMsQ0FBQztBQUVsRSxNQUFNLGtDQUFrQyxHQUFHO0lBQ3ZDLFlBQVk7SUFDWixZQUFZO0lBQ1osWUFBWTtJQUNaLGFBQWE7SUFDYixtQkFBbUI7SUFDbkIsT0FBTztJQUNQLE9BQU87SUFDUCxpQ0FBdUI7Q0FDMUIsQ0FBQztBQUVGLE1BQU0sK0JBQStCLEdBQUc7SUFDcEMsa0JBQWtCO0lBQ2xCLG1CQUFtQjtDQUN0QixDQUFDO0FBRUYsU0FBUyxjQUFjLENBQUUsV0FBbUIsRUFBRTtJQUMxQyxPQUFPLENBQUMsUUFBUTtRQUNaLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxVQUFHLENBQUM7UUFDdkIsK0JBQStCLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxFQUFFLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUNuRixrQ0FBa0MsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLEVBQUUsQ0FBQyxRQUFRLENBQUMsVUFBVSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUM7QUFDakcsQ0FBQztBQUVELG1CQUF5QixLQUFpQjtJQUN0QyxvRUFBb0U7SUFDcEUsTUFBTSxRQUFRLEdBQUcsS0FBSyxDQUFDLFdBQVcsRUFBRSxDQUFDO0lBRXJDLE9BQU8sY0FBYyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0FBQ3BDLENBQUM7QUFMRCw0QkFLQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHNlcCwgam9pbiB9IGZyb20gJ3BhdGgnO1xuaW1wb3J0IHsgZXNjYXBlUmVnRXhwIGFzIGVzY2FwZVJlIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBJTlRFUk5BTF9NT0RVTEVTX1BSRUZJWCBmcm9tICcuL2ludGVybmFsLW1vZHVsZXMtcHJlZml4JztcbmltcG9ydCB7IFN0YWNrRnJhbWUgfSBmcm9tICdlcnJvci1zdGFjay1wYXJzZXInO1xuXG5jb25zdCBCQUJFTCAgICAgICAgICAgICAgID0gcmVxdWlyZS5yZXNvbHZlKCdAYmFiZWwvY29yZScpO1xuY29uc3QgQkFCRUxfTU9EVUxFU19ESVIgICA9IEJBQkVMLnJlcGxhY2UobmV3IFJlZ0V4cChgXiguKiR7ZXNjYXBlUmUoc2VwKX1ub2RlX21vZHVsZXMke2VzY2FwZVJlKHNlcCl9KSguKilgKSwgJyQxJyk7XG5jb25zdCBCQUJFTF83ICAgICAgICAgICAgID0gQkFCRUxfTU9EVUxFU19ESVIgKyAnQGJhYmVsJztcbmNvbnN0IEJBQkVMX1JFTEFURUQgICAgICAgPSBCQUJFTF9NT0RVTEVTX0RJUiArICdiYWJlbC0nO1xuY29uc3QgUkVHRU5FUkFUT1JfUlVOVElNRSA9IEJBQkVMX01PRFVMRVNfRElSICsgJ3JlZ2VuZXJhdG9yLXJ1bnRpbWUnICsgc2VwO1xuY29uc3QgR0VOU1lOQyAgICAgICAgICAgICA9IEJBQkVMX01PRFVMRVNfRElSICsgJ2dlbnN5bmMnOyAvLyBOT1RFOiBAYmFiZWwvcGFyc2VyIHVzZXMgdGhpcyBtb2R1bGUgaW50ZXJuYWxseS5cbmNvbnN0IFRFU1RDQUZFX0xJQiAgICAgICAgPSBqb2luKF9fZGlybmFtZSwgJy4uLycpO1xuY29uc3QgVEVTVENBRkVfQklOICAgICAgICA9IGpvaW4oX19kaXJuYW1lLCAnLi4vLi4vYmluJyk7XG5jb25zdCBURVNUQ0FGRV9TUkMgICAgICAgID0gam9pbihfX2Rpcm5hbWUsICcuLi8uLi9zcmMnKTtcbmNvbnN0IFRFU1RDQUZFX0hBTU1FUkhFQUQgPSByZXF1aXJlLnJlc29sdmUoJ3Rlc3RjYWZlLWhhbW1lcmhlYWQnKTtcbmNvbnN0IFNPVVJDRV9NQVBfU1VQUE9SVCAgPSByZXF1aXJlLnJlc29sdmUoJ3NvdXJjZS1tYXAtc3VwcG9ydCcpO1xuXG5jb25zdCBJTlRFUk5BTF9TVEFSVFNfV0lUSF9QQVRIX1NFR01FTlRTID0gW1xuICAgIFRFU1RDQUZFX0xJQixcbiAgICBURVNUQ0FGRV9CSU4sXG4gICAgVEVTVENBRkVfU1JDLFxuICAgIEJBQkVMX1JFTEFURUQsXG4gICAgUkVHRU5FUkFUT1JfUlVOVElNRSxcbiAgICBHRU5TWU5DLFxuICAgIEJBQkVMXzcsXG4gICAgSU5URVJOQUxfTU9EVUxFU19QUkVGSVgsXG5dO1xuXG5jb25zdCBJTlRFUk5BTF9JTkNMVURFU19QQVRIX1NFR01FTlRTID0gW1xuICAgIFNPVVJDRV9NQVBfU1VQUE9SVCxcbiAgICBURVNUQ0FGRV9IQU1NRVJIRUFELFxuXTtcblxuZnVuY3Rpb24gaXNJbnRlcm5hbEZpbGUgKGZpbGVuYW1lOiBzdHJpbmcgPSAnJyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAhZmlsZW5hbWUgfHxcbiAgICAgICAgIWZpbGVuYW1lLmluY2x1ZGVzKHNlcCkgfHxcbiAgICAgICAgSU5URVJOQUxfSU5DTFVERVNfUEFUSF9TRUdNRU5UUy5zb21lKHBhdGhTZWdtZW50ID0+IGZpbGVuYW1lLmluY2x1ZGVzKHBhdGhTZWdtZW50KSkgfHxcbiAgICAgICAgSU5URVJOQUxfU1RBUlRTX1dJVEhfUEFUSF9TRUdNRU5UUy5zb21lKHBhdGhTZWdtZW50ID0+IGZpbGVuYW1lLnN0YXJ0c1dpdGgocGF0aFNlZ21lbnQpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKGZyYW1lOiBTdGFja0ZyYW1lKTogYm9vbGVhbiB7XG4gICAgLy8gTk9URTogZmlsdGVyIG91dCB0aGUgaW50ZXJuYWxzIG9mIG5vZGUuanMgYW5kIGFzc2VydGlvbiBsaWJyYXJpZXNcbiAgICBjb25zdCBmaWxlbmFtZSA9IGZyYW1lLmdldEZpbGVOYW1lKCk7XG5cbiAgICByZXR1cm4gaXNJbnRlcm5hbEZpbGUoZmlsZW5hbWUpO1xufVxuIl19