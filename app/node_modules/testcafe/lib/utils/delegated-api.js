"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.delegateAPI = exports.getDelegatedAPIList = void 0;
const API_IMPLEMENTATION_METHOD_RE = /^_(\S+)\$(getter|setter)?$/;
function getDelegatedAPIList(src) {
    return Object
        .getOwnPropertyNames(src)
        .map(prop => {
        const match = prop.match(API_IMPLEMENTATION_METHOD_RE);
        if (match) {
            return {
                srcProp: prop,
                apiProp: match[1],
                accessor: match[2],
            };
        }
        return null;
    })
        .filter(item => !!item);
}
exports.getDelegatedAPIList = getDelegatedAPIList;
function delegateAPI(dest, apiList, opts) {
    apiList.forEach(({ srcProp, apiProp, accessor }) => {
        let fn = function (...args) {
            if (opts.proxyMethod)
                opts.proxyMethod();
            let handler = null;
            if (opts.useCurrentCtxAsHandler)
                handler = this;
            else if (opts.getHandler)
                handler = opts.getHandler(apiProp, accessor);
            else
                handler = opts.handler;
            return handler[srcProp](...args);
        };
        // NOTE: need to create named function to process possible err.stack correctly
        const createNamedFunction = new Function('srcProp', 'apiProp', 'accessor', 'opts', `
            return ${fn.toString().replace('function', 'function ' + apiProp)}
        `);
        fn = createNamedFunction(srcProp, apiProp, accessor, opts);
        if (accessor === 'getter')
            Object.defineProperty(dest, apiProp, { get: fn, configurable: true });
        else if (accessor === 'setter')
            Object.defineProperty(dest, apiProp, { set: fn, configurable: true });
        else {
            // NOTE: need to create `property` but not a `function` to stop on `debugger`
            // before the action is called
            Object.defineProperty(dest, apiProp, {
                get() {
                    if (this.shouldStop && this.shouldStop(apiProp)) {
                        // eslint-disable-next-line no-debugger
                        debugger;
                    }
                    return fn;
                },
                configurable: true,
            });
        }
    });
}
exports.delegateAPI = delegateAPI;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGVsZWdhdGVkLWFwaS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlscy9kZWxlZ2F0ZWQtYXBpLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLE1BQU0sNEJBQTRCLEdBQUcsNEJBQTRCLENBQUM7QUFFbEUsU0FBZ0IsbUJBQW1CLENBQUUsR0FBRztJQUNwQyxPQUFPLE1BQU07U0FDUixtQkFBbUIsQ0FBQyxHQUFHLENBQUM7U0FDeEIsR0FBRyxDQUFDLElBQUksQ0FBQyxFQUFFO1FBQ1IsTUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyw0QkFBNEIsQ0FBQyxDQUFDO1FBRXZELElBQUksS0FBSyxFQUFFO1lBQ1AsT0FBTztnQkFDSCxPQUFPLEVBQUcsSUFBSTtnQkFDZCxPQUFPLEVBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQztnQkFDbEIsUUFBUSxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUM7YUFDckIsQ0FBQztTQUNMO1FBRUQsT0FBTyxJQUFJLENBQUM7SUFDaEIsQ0FBQyxDQUFDO1NBQ0QsTUFBTSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ2hDLENBQUM7QUFqQkQsa0RBaUJDO0FBRUQsU0FBZ0IsV0FBVyxDQUFFLElBQUksRUFBRSxPQUFPLEVBQUUsSUFBSTtJQUM1QyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUMsRUFBRSxPQUFPLEVBQUUsT0FBTyxFQUFFLFFBQVEsRUFBRSxFQUFFLEVBQUU7UUFDL0MsSUFBSSxFQUFFLEdBQUcsVUFBVSxHQUFHLElBQUk7WUFDdEIsSUFBSSxJQUFJLENBQUMsV0FBVztnQkFDaEIsSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDO1lBRXZCLElBQUksT0FBTyxHQUFHLElBQUksQ0FBQztZQUVuQixJQUFJLElBQUksQ0FBQyxzQkFBc0I7Z0JBQzNCLE9BQU8sR0FBRyxJQUFJLENBQUM7aUJBRWQsSUFBSSxJQUFJLENBQUMsVUFBVTtnQkFDcEIsT0FBTyxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsT0FBTyxFQUFFLFFBQVEsQ0FBQyxDQUFDOztnQkFHN0MsT0FBTyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUM7WUFFM0IsT0FBTyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQztRQUNyQyxDQUFDLENBQUM7UUFFRiw4RUFBOEU7UUFDOUUsTUFBTSxtQkFBbUIsR0FBRyxJQUFJLFFBQVEsQ0FBQyxTQUFTLEVBQUUsU0FBUyxFQUFFLFVBQVUsRUFBRSxNQUFNLEVBQUU7cUJBQ3RFLEVBQUUsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxPQUFPLENBQUMsVUFBVSxFQUFFLFdBQVcsR0FBRyxPQUFPLENBQUM7U0FDcEUsQ0FBQyxDQUFDO1FBRUgsRUFBRSxHQUFHLG1CQUFtQixDQUFDLE9BQU8sRUFBRSxPQUFPLEVBQUUsUUFBUSxFQUFFLElBQUksQ0FBQyxDQUFDO1FBRTNELElBQUksUUFBUSxLQUFLLFFBQVE7WUFDckIsTUFBTSxDQUFDLGNBQWMsQ0FBQyxJQUFJLEVBQUUsT0FBTyxFQUFFLEVBQUUsR0FBRyxFQUFFLEVBQUUsRUFBRSxZQUFZLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQzthQUVyRSxJQUFJLFFBQVEsS0FBSyxRQUFRO1lBQzFCLE1BQU0sQ0FBQyxjQUFjLENBQUMsSUFBSSxFQUFFLE9BQU8sRUFBRSxFQUFFLEdBQUcsRUFBRSxFQUFFLEVBQUUsWUFBWSxFQUFFLElBQUksRUFBRSxDQUFDLENBQUM7YUFFckU7WUFDRCw2RUFBNkU7WUFDN0UsOEJBQThCO1lBQzlCLE1BQU0sQ0FBQyxjQUFjLENBQUMsSUFBSSxFQUFFLE9BQU8sRUFBRTtnQkFDakMsR0FBRztvQkFDQyxJQUFJLElBQUksQ0FBQyxVQUFVLElBQUksSUFBSSxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsRUFBRTt3QkFDN0MsdUNBQXVDO3dCQUN2QyxRQUFRLENBQUM7cUJBQ1o7b0JBRUQsT0FBTyxFQUFFLENBQUM7Z0JBQ2QsQ0FBQztnQkFDRCxZQUFZLEVBQUUsSUFBSTthQUNyQixDQUFDLENBQUM7U0FDTjtJQUNMLENBQUMsQ0FBQyxDQUFDO0FBQ1AsQ0FBQztBQWpERCxrQ0FpREMiLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBBUElfSU1QTEVNRU5UQVRJT05fTUVUSE9EX1JFID0gL15fKFxcUyspXFwkKGdldHRlcnxzZXR0ZXIpPyQvO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGVsZWdhdGVkQVBJTGlzdCAoc3JjKSB7XG4gICAgcmV0dXJuIE9iamVjdFxuICAgICAgICAuZ2V0T3duUHJvcGVydHlOYW1lcyhzcmMpXG4gICAgICAgIC5tYXAocHJvcCA9PiB7XG4gICAgICAgICAgICBjb25zdCBtYXRjaCA9IHByb3AubWF0Y2goQVBJX0lNUExFTUVOVEFUSU9OX01FVEhPRF9SRSk7XG5cbiAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHNyY1Byb3A6ICBwcm9wLFxuICAgICAgICAgICAgICAgICAgICBhcGlQcm9wOiAgbWF0Y2hbMV0sXG4gICAgICAgICAgICAgICAgICAgIGFjY2Vzc29yOiBtYXRjaFsyXSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSlcbiAgICAgICAgLmZpbHRlcihpdGVtID0+ICEhaXRlbSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWxlZ2F0ZUFQSSAoZGVzdCwgYXBpTGlzdCwgb3B0cykge1xuICAgIGFwaUxpc3QuZm9yRWFjaCgoeyBzcmNQcm9wLCBhcGlQcm9wLCBhY2Nlc3NvciB9KSA9PiB7XG4gICAgICAgIGxldCBmbiA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgICAgICBpZiAob3B0cy5wcm94eU1ldGhvZClcbiAgICAgICAgICAgICAgICBvcHRzLnByb3h5TWV0aG9kKCk7XG5cbiAgICAgICAgICAgIGxldCBoYW5kbGVyID0gbnVsbDtcblxuICAgICAgICAgICAgaWYgKG9wdHMudXNlQ3VycmVudEN0eEFzSGFuZGxlcilcbiAgICAgICAgICAgICAgICBoYW5kbGVyID0gdGhpcztcblxuICAgICAgICAgICAgZWxzZSBpZiAob3B0cy5nZXRIYW5kbGVyKVxuICAgICAgICAgICAgICAgIGhhbmRsZXIgPSBvcHRzLmdldEhhbmRsZXIoYXBpUHJvcCwgYWNjZXNzb3IpO1xuXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgaGFuZGxlciA9IG9wdHMuaGFuZGxlcjtcblxuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZXJbc3JjUHJvcF0oLi4uYXJncyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gTk9URTogbmVlZCB0byBjcmVhdGUgbmFtZWQgZnVuY3Rpb24gdG8gcHJvY2VzcyBwb3NzaWJsZSBlcnIuc3RhY2sgY29ycmVjdGx5XG4gICAgICAgIGNvbnN0IGNyZWF0ZU5hbWVkRnVuY3Rpb24gPSBuZXcgRnVuY3Rpb24oJ3NyY1Byb3AnLCAnYXBpUHJvcCcsICdhY2Nlc3NvcicsICdvcHRzJywgYFxuICAgICAgICAgICAgcmV0dXJuICR7Zm4udG9TdHJpbmcoKS5yZXBsYWNlKCdmdW5jdGlvbicsICdmdW5jdGlvbiAnICsgYXBpUHJvcCl9XG4gICAgICAgIGApO1xuXG4gICAgICAgIGZuID0gY3JlYXRlTmFtZWRGdW5jdGlvbihzcmNQcm9wLCBhcGlQcm9wLCBhY2Nlc3Nvciwgb3B0cyk7XG5cbiAgICAgICAgaWYgKGFjY2Vzc29yID09PSAnZ2V0dGVyJylcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkZXN0LCBhcGlQcm9wLCB7IGdldDogZm4sIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9KTtcblxuICAgICAgICBlbHNlIGlmIChhY2Nlc3NvciA9PT0gJ3NldHRlcicpXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZGVzdCwgYXBpUHJvcCwgeyBzZXQ6IGZuLCBjb25maWd1cmFibGU6IHRydWUgfSk7XG5cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBOT1RFOiBuZWVkIHRvIGNyZWF0ZSBgcHJvcGVydHlgIGJ1dCBub3QgYSBgZnVuY3Rpb25gIHRvIHN0b3Agb24gYGRlYnVnZ2VyYFxuICAgICAgICAgICAgLy8gYmVmb3JlIHRoZSBhY3Rpb24gaXMgY2FsbGVkXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZGVzdCwgYXBpUHJvcCwge1xuICAgICAgICAgICAgICAgIGdldCAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNob3VsZFN0b3AgJiYgdGhpcy5zaG91bGRTdG9wKGFwaVByb3ApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZGVidWdnZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnZ2VyO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZuO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbiJdfQ==