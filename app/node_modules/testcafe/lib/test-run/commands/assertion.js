"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const type_1 = __importDefault(require("./type"));
const base_1 = __importDefault(require("./base"));
const options_1 = require("./options");
const runtime_1 = require("../../errors/runtime");
const test_run_1 = require("../../errors/test-run");
const execute_js_expression_1 = require("../execute-js-expression");
const utils_1 = require("./utils");
const argument_1 = require("./validations/argument");
// Initializers
function initAssertionOptions(name, val) {
    return new options_1.AssertionOptions(val, true);
}
//Initializers
function initAssertionParameter(name, val, { skipVisibilityCheck, testRun }) {
    try {
        if (utils_1.isJSExpression(val))
            val = execute_js_expression_1.executeJsExpression(val.value, testRun, { skipVisibilityCheck });
        return val;
    }
    catch (err) {
        throw new test_run_1.AssertionExecutableArgumentError(name, val.value, err, err instanceof runtime_1.APIError);
    }
}
const NOT_REPORTED_PROPERTIES = ['id', 'originActual'];
// Commands
class AssertionCommand extends base_1.default {
    constructor(obj, testRun, validateProperties) {
        super(obj, testRun, type_1.default.assertion, validateProperties);
    }
    _getAssignableProperties() {
        return [
            { name: 'id', type: argument_1.nonEmptyStringArgument, required: false },
            { name: 'assertionType', type: argument_1.nonEmptyStringArgument, required: true },
            { name: 'originActual', defaultValue: void 0 },
            { name: 'actual', init: initAssertionParameter, defaultValue: void 0 },
            { name: 'expected', init: initAssertionParameter, defaultValue: void 0 },
            { name: 'expected2', init: initAssertionParameter, defaultValue: void 0 },
            { name: 'message', type: argument_1.stringArgument, defaultValue: null },
            { name: 'options', type: argument_1.actionOptions, init: initAssertionOptions, required: true },
        ];
    }
    static get NOT_REPORTED_PROPERTIES() {
        return NOT_REPORTED_PROPERTIES;
    }
}
exports.default = AssertionCommand;
module.exports = exports.default;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXNzZXJ0aW9uLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL3Rlc3QtcnVuL2NvbW1hbmRzL2Fzc2VydGlvbi5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLGtEQUEwQjtBQUMxQixrREFBaUM7QUFDakMsdUNBQTZDO0FBQzdDLGtEQUFnRDtBQUNoRCxvREFBeUU7QUFDekUsb0VBQStEO0FBQy9ELG1DQUF5QztBQUV6QyxxREFJZ0M7QUFHaEMsZUFBZTtBQUNmLFNBQVMsb0JBQW9CLENBQUUsSUFBSSxFQUFFLEdBQUc7SUFDcEMsT0FBTyxJQUFJLDBCQUFnQixDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsQ0FBQztBQUMzQyxDQUFDO0FBRUQsY0FBYztBQUNkLFNBQVMsc0JBQXNCLENBQUUsSUFBSSxFQUFFLEdBQUcsRUFBRSxFQUFFLG1CQUFtQixFQUFFLE9BQU8sRUFBRTtJQUN4RSxJQUFJO1FBQ0EsSUFBSSxzQkFBYyxDQUFDLEdBQUcsQ0FBQztZQUNuQixHQUFHLEdBQUcsMkNBQW1CLENBQUMsR0FBRyxDQUFDLEtBQUssRUFBRSxPQUFPLEVBQUUsRUFBRSxtQkFBbUIsRUFBRSxDQUFDLENBQUM7UUFFM0UsT0FBTyxHQUFHLENBQUM7S0FDZDtJQUNELE9BQU8sR0FBRyxFQUFFO1FBQ1IsTUFBTSxJQUFJLDJDQUFnQyxDQUFDLElBQUksRUFBRSxHQUFHLENBQUMsS0FBSyxFQUFFLEdBQUcsRUFBRSxHQUFHLFlBQVksa0JBQVEsQ0FBQyxDQUFDO0tBQzdGO0FBQ0wsQ0FBQztBQUVELE1BQU0sdUJBQXVCLEdBQUcsQ0FBQyxJQUFJLEVBQUUsY0FBYyxDQUFDLENBQUM7QUFFdkQsV0FBVztBQUNYLE1BQXFCLGdCQUFpQixTQUFRLGNBQVc7SUFDckQsWUFBYSxHQUFHLEVBQUUsT0FBTyxFQUFFLGtCQUFrQjtRQUN6QyxLQUFLLENBQUMsR0FBRyxFQUFFLE9BQU8sRUFBRSxjQUFJLENBQUMsU0FBUyxFQUFFLGtCQUFrQixDQUFDLENBQUM7SUFDNUQsQ0FBQztJQUVELHdCQUF3QjtRQUNwQixPQUFPO1lBQ0gsRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxpQ0FBc0IsRUFBRSxRQUFRLEVBQUUsS0FBSyxFQUFFO1lBQzdELEVBQUUsSUFBSSxFQUFFLGVBQWUsRUFBRSxJQUFJLEVBQUUsaUNBQXNCLEVBQUUsUUFBUSxFQUFFLElBQUksRUFBRTtZQUN2RSxFQUFFLElBQUksRUFBRSxjQUFjLEVBQUUsWUFBWSxFQUFFLEtBQUssQ0FBQyxFQUFFO1lBQzlDLEVBQUUsSUFBSSxFQUFFLFFBQVEsRUFBRSxJQUFJLEVBQUUsc0JBQXNCLEVBQUUsWUFBWSxFQUFFLEtBQUssQ0FBQyxFQUFFO1lBQ3RFLEVBQUUsSUFBSSxFQUFFLFVBQVUsRUFBRSxJQUFJLEVBQUUsc0JBQXNCLEVBQUUsWUFBWSxFQUFFLEtBQUssQ0FBQyxFQUFFO1lBQ3hFLEVBQUUsSUFBSSxFQUFFLFdBQVcsRUFBRSxJQUFJLEVBQUUsc0JBQXNCLEVBQUUsWUFBWSxFQUFFLEtBQUssQ0FBQyxFQUFFO1lBQ3pFLEVBQUUsSUFBSSxFQUFFLFNBQVMsRUFBRSxJQUFJLEVBQUUseUJBQWMsRUFBRSxZQUFZLEVBQUUsSUFBSSxFQUFFO1lBQzdELEVBQUUsSUFBSSxFQUFFLFNBQVMsRUFBRSxJQUFJLEVBQUUsd0JBQWEsRUFBRSxJQUFJLEVBQUUsb0JBQW9CLEVBQUUsUUFBUSxFQUFFLElBQUksRUFBRTtTQUN2RixDQUFDO0lBQ04sQ0FBQztJQUVELE1BQU0sS0FBSyx1QkFBdUI7UUFDOUIsT0FBTyx1QkFBdUIsQ0FBQztJQUNuQyxDQUFDO0NBQ0o7QUFyQkQsbUNBcUJDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFRZUEUgZnJvbSAnLi90eXBlJztcbmltcG9ydCBDb21tYW5kQmFzZSBmcm9tICcuL2Jhc2UnO1xuaW1wb3J0IHsgQXNzZXJ0aW9uT3B0aW9ucyB9IGZyb20gJy4vb3B0aW9ucyc7XG5pbXBvcnQgeyBBUElFcnJvciB9IGZyb20gJy4uLy4uL2Vycm9ycy9ydW50aW1lJztcbmltcG9ydCB7IEFzc2VydGlvbkV4ZWN1dGFibGVBcmd1bWVudEVycm9yIH0gZnJvbSAnLi4vLi4vZXJyb3JzL3Rlc3QtcnVuJztcbmltcG9ydCB7IGV4ZWN1dGVKc0V4cHJlc3Npb24gfSBmcm9tICcuLi9leGVjdXRlLWpzLWV4cHJlc3Npb24nO1xuaW1wb3J0IHsgaXNKU0V4cHJlc3Npb24gfSBmcm9tICcuL3V0aWxzJztcblxuaW1wb3J0IHtcbiAgICBzdHJpbmdBcmd1bWVudCxcbiAgICBhY3Rpb25PcHRpb25zLFxuICAgIG5vbkVtcHR5U3RyaW5nQXJndW1lbnQsXG59IGZyb20gJy4vdmFsaWRhdGlvbnMvYXJndW1lbnQnO1xuXG5cbi8vIEluaXRpYWxpemVyc1xuZnVuY3Rpb24gaW5pdEFzc2VydGlvbk9wdGlvbnMgKG5hbWUsIHZhbCkge1xuICAgIHJldHVybiBuZXcgQXNzZXJ0aW9uT3B0aW9ucyh2YWwsIHRydWUpO1xufVxuXG4vL0luaXRpYWxpemVyc1xuZnVuY3Rpb24gaW5pdEFzc2VydGlvblBhcmFtZXRlciAobmFtZSwgdmFsLCB7IHNraXBWaXNpYmlsaXR5Q2hlY2ssIHRlc3RSdW4gfSkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmIChpc0pTRXhwcmVzc2lvbih2YWwpKVxuICAgICAgICAgICAgdmFsID0gZXhlY3V0ZUpzRXhwcmVzc2lvbih2YWwudmFsdWUsIHRlc3RSdW4sIHsgc2tpcFZpc2liaWxpdHlDaGVjayB9KTtcblxuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRocm93IG5ldyBBc3NlcnRpb25FeGVjdXRhYmxlQXJndW1lbnRFcnJvcihuYW1lLCB2YWwudmFsdWUsIGVyciwgZXJyIGluc3RhbmNlb2YgQVBJRXJyb3IpO1xuICAgIH1cbn1cblxuY29uc3QgTk9UX1JFUE9SVEVEX1BST1BFUlRJRVMgPSBbJ2lkJywgJ29yaWdpbkFjdHVhbCddO1xuXG4vLyBDb21tYW5kc1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXNzZXJ0aW9uQ29tbWFuZCBleHRlbmRzIENvbW1hbmRCYXNlIHtcbiAgICBjb25zdHJ1Y3RvciAob2JqLCB0ZXN0UnVuLCB2YWxpZGF0ZVByb3BlcnRpZXMpIHtcbiAgICAgICAgc3VwZXIob2JqLCB0ZXN0UnVuLCBUWVBFLmFzc2VydGlvbiwgdmFsaWRhdGVQcm9wZXJ0aWVzKTtcbiAgICB9XG5cbiAgICBfZ2V0QXNzaWduYWJsZVByb3BlcnRpZXMgKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyBuYW1lOiAnaWQnLCB0eXBlOiBub25FbXB0eVN0cmluZ0FyZ3VtZW50LCByZXF1aXJlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ2Fzc2VydGlvblR5cGUnLCB0eXBlOiBub25FbXB0eVN0cmluZ0FyZ3VtZW50LCByZXF1aXJlZDogdHJ1ZSB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnb3JpZ2luQWN0dWFsJywgZGVmYXVsdFZhbHVlOiB2b2lkIDAgfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ2FjdHVhbCcsIGluaXQ6IGluaXRBc3NlcnRpb25QYXJhbWV0ZXIsIGRlZmF1bHRWYWx1ZTogdm9pZCAwIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdleHBlY3RlZCcsIGluaXQ6IGluaXRBc3NlcnRpb25QYXJhbWV0ZXIsIGRlZmF1bHRWYWx1ZTogdm9pZCAwIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdleHBlY3RlZDInLCBpbml0OiBpbml0QXNzZXJ0aW9uUGFyYW1ldGVyLCBkZWZhdWx0VmFsdWU6IHZvaWQgMCB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnbWVzc2FnZScsIHR5cGU6IHN0cmluZ0FyZ3VtZW50LCBkZWZhdWx0VmFsdWU6IG51bGwgfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ29wdGlvbnMnLCB0eXBlOiBhY3Rpb25PcHRpb25zLCBpbml0OiBpbml0QXNzZXJ0aW9uT3B0aW9ucywgcmVxdWlyZWQ6IHRydWUgfSxcbiAgICAgICAgXTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0IE5PVF9SRVBPUlRFRF9QUk9QRVJUSUVTICgpIHtcbiAgICAgICAgcmV0dXJuIE5PVF9SRVBPUlRFRF9QUk9QRVJUSUVTO1xuICAgIH1cbn1cbiJdfQ==